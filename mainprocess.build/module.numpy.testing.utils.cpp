// Generated code for Python source for module 'numpy.testing.utils'
// created by Nuitka version 0.5.19

// This code is in part copyright 2016 Kay Hayen.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "nuitka/prelude.hpp"

#include "__helpers.hpp"

// The _module_numpy$testing$utils is a Python object pointer of module type.

// Note: For full compatibility with CPython, every module variable access
// needs to go through it except for cases where the module cannot possibly
// have changed in the mean time.

PyObject *module_numpy$testing$utils;
PyDictObject *moduledict_numpy$testing$utils;

// The module constants used
static PyObject *const_str_digest_50e4cc95dfbb393fb8a962e3fe72cc12;
extern PyObject *const_str_plain_split;
extern PyObject *const_str_plain_difflib;
extern PyObject *const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
extern PyObject *const_list_int_0_list;
extern PyObject *const_str_plain_nan;
static PyObject *const_str_plain_r_func;
static PyObject *const_str_plain_pathname;
static PyObject *const_str_plain_mgr;
extern PyObject *const_str_plain_reduced;
static PyObject *const_tuple_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1_tuple;
extern PyObject *const_str_plain_getvalue;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_digest_119597c8dc0968aaf226da43c6fe7f86;
static PyObject *const_str_plain_safe_comparison;
static PyObject *const_str_plain_diff_list;
static PyObject *const_str_digest_4b7c0e7f23efc5fa89db71ab487de5e1;
extern PyObject *const_str_plain_failures;
extern PyObject *const_str_plain_rtol;
static PyObject *const_str_digest_80faa6a434267444203aa2503ce280fc;
extern PyObject *const_str_plain_invalid;
extern PyObject *const_tuple_int_0_tuple;
extern PyObject *const_str_plain_iscomplexobj;
extern PyObject *const_str_plain_astr;
static PyObject *const_str_plain_callable_obj;
extern PyObject *const_tuple_str_plain_x_tuple;
static PyObject *const_str_digest_ba3a38dfc99e9008935c1c3fb4efa93f;
extern PyObject *const_str_plain_category;
extern PyObject *const_float_1_0;
static PyObject *const_str_plain_comparison;
extern PyObject *const_str_plain_i;
extern PyObject *const_str_plain_inf;
static PyObject *const_str_plain_rundocs;
extern PyObject *const_str_plain_warnings;
extern PyObject *const_str_plain_search;
extern PyObject *const_str_plain_d;
extern PyObject *const_str_plain_inp;
static PyObject *const_str_plain_d3;
static PyObject *const_tuple_str_plain_isnan_tuple;
extern PyObject *const_str_plain_args;
static PyObject *const_str_plain_unary;
extern PyObject *const_str_plain_nose;
extern PyObject *const_str_plain_mkdtemp;
extern PyObject *const_str_plain_d1;
static PyObject *const_str_digest_f4e551f0ba39cf5d79afe90ee6966e81;
static PyObject *const_str_plain_binary;
extern PyObject *const_str_plain___exit__;
extern PyObject *const_str_plain_tempdir;
static PyObject *const_str_digest_763dafaf263503aed0533c163ee5f659;
extern PyObject *const_int_neg_1;
extern PyObject *const_str_plain_tmpdir;
extern PyObject *const_str_plain_c;
static PyObject *const_str_plain_assert_almost_equal;
extern PyObject *const_str_plain_isnan;
extern PyObject *const_str_plain_results;
extern PyObject *const_tuple_false_none_tuple;
extern PyObject *const_str_plain_sep;
static PyObject *const_str_plain_GetPerformanceAttributes;
static PyObject *const_dict_c05cf8ed9016cad683e758f62a6613d4;
extern PyObject *const_str_plain_op;
static PyObject *const_str_digest_ef2d5d7b0c9e4f3b1e50776d5d0fa6e5;
extern PyObject *const_str_plain_os;
static PyObject *const_long_neg_2147483648;
extern PyObject *const_str_plain_y;
static PyObject *const_str_plain_actuali;
extern PyObject *const_str_plain_find;
static PyObject *const_str_plain_spacing;
static PyObject *const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
extern PyObject *const_str_plain_out;
static PyObject *const_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1;
static PyObject *const_str_plain_significant;
static PyObject *const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple;
static PyObject *const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple;
static PyObject *const_str_plain_actualr;
static PyObject *const_tuple_22011052c50ffffeee9babd5969d09da_tuple;
extern PyObject *const_str_plain_DocTestRunner;
static PyObject *const_str_plain__build_err_msg;
static PyObject *const_str_plain__proc_pid_stat;
static PyObject *const_str_digest_d6b3345eef013f973e768c3ac758531f;
static PyObject *const_dict_ff8ef3bf3e81fbdb8830624987bd4652;
static PyObject *const_tuple_str_plain_ndarray_tuple;
static PyObject *const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple;
extern PyObject *const_str_digest_a45c67b2be89c200cea2763464bafa08;
extern PyObject *const_str_plain_isinf;
static PyObject *const_str_plain__record;
static PyObject *const_str_plain_chk_same_position;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_issubdtype;
extern PyObject *const_str_plain_memusage;
static PyObject *const_str_plain_assert_approx_equal;
static PyObject *const_str_plain__module;
extern PyObject *const_str_plain_items;
static PyObject *const_str_digest_13df72bccf988d02cd7b35fa667a8f38;
extern PyObject *const_str_plain_arrays;
extern PyObject *const_str_plain_nosetester;
extern PyObject *const_str_plain_err_msg;
static PyObject *const_str_digest_ca97b54f456b9d063ac2656c890932f6;
static PyObject *const_str_plain_nulp;
static PyObject *const_tuple_str_plain_import_nose_tuple;
extern PyObject *const_float_0_5;
extern PyObject *const_float_0_0;
static PyObject *const_str_plain_sc_desired;
extern PyObject *const_str_plain___name__;
extern PyObject *const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8;
static PyObject *const_str_digest_6f8248c0cd0a61aee0231b6be5326ece;
extern PyObject *const_str_plain_ndarray;
static PyObject *const_str_digest_8f7e46a753006e8bd692e624f140d763;
static PyObject *const_tuple_str_plain_partial_tuple;
static PyObject *const_str_plain_cls_attr;
static PyObject *const_str_plain_ref;
static PyObject *const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple;
static PyObject *const_tuple_int_pos_7_str_empty_true_tuple;
extern PyObject *const_str_plain_array_repr;
static PyObject *const_str_digest_6cc5cefb53b579746bcbb4d68e503416;
extern PyObject *const_str_plain_ret;
extern PyObject *const_str_plain_ravel;
extern PyObject *const_tuple_str_plain_issubdtype_tuple;
extern PyObject *const_tuple_int_pos_10000_tuple;
static PyObject *const_str_plain_OpenQuery;
extern PyObject *const_str_plain_message;
extern PyObject *const_str_plain_basestring;
static PyObject *const_str_plain__diff;
static PyObject *const_str_digest_e6c9ce73383c66ad08c690eb2446230f;
extern PyObject *const_str_plain_filename;
extern PyObject *const_str_plain_match;
extern PyObject *const_str_plain_verbose;
static PyObject *const_str_plain_assert_array_equal;
static PyObject *const_str_digest_3720bdeeb610c78f6c12dfac8edb8c59;
extern PyObject *const_str_plain_kw;
static PyObject *const_dict_117eec822878c8a1e3d3fe65ec8106fd;
extern PyObject *const_tuple_str_plain_isfunction_tuple;
static PyObject *const_str_plain_gisfinite;
extern PyObject *const_tuple_cc0d7a281e580497181b34c5d19dd2ca_tuple;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_digest_58cd5d23011fe45d68c661820d95e72a;
static PyObject *const_str_plain_smsg;
extern PyObject *const_str_plain_always;
static PyObject *const_str_digest_9fe74df5f37fb0f3159d9349320195f0;
extern PyObject *const_tuple_str_plain_ignore_tuple;
static PyObject *const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple;
static PyObject *const_tuple_str_plain__load_time_str_plain_time_tuple;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_plain_build_err_msg;
static PyObject *const_str_plain_assert_raises_regexp;
extern PyObject *const_str_plain_power;
extern PyObject *const_str_digest_67205772204d1e33862eb50e826ab1cb;
extern PyObject *const_str_plain_Differ;
static PyObject *const_str_plain_win32pdh;
static PyObject *const_str_digest_9f56a9d5b59582b4c0da971506f2216a;
extern PyObject *const_str_plain_raises;
extern PyObject *const_str_plain_asanyarray;
extern PyObject *const_str_plain_exception;
extern PyObject *const_str_plain_compile;
static PyObject *const_tuple_str_digest_f68e5190fae8b666170c0081d799be3d_tuple;
extern PyObject *const_str_plain_exc_value;
extern PyObject *const_str_plain_imag;
static PyObject *const_str_digest_903d6b58b25be7a46249f406f02b7d41;
extern PyObject *const_str_plain_self;
extern PyObject *const_tuple_str_plain_x_str_plain_y_tuple;
extern PyObject *const_str_plain_bool;
static PyObject *const_str_plain_desired;
static PyObject *const_str_plain_assert_no_warnings;
extern PyObject *const_str_plain_float;
extern PyObject *const_str_plain_log10;
extern PyObject *const_str_plain_operator;
extern PyObject *const_str_plain_result_type;
static PyObject *const_tuple_str_plain_zeros_str_plain_float64_tuple;
extern PyObject *const_str_plain_raise_on_error;
static PyObject *const_tuple_428ef0c7dcad024f447304283fd888c5_tuple;
extern PyObject *const_str_plain_methods;
extern PyObject *const_str_plain_mod;
static PyObject *const_str_plain_WarningMessage;
extern PyObject *const_int_pos_9;
static PyObject *const_str_plain__entered;
static PyObject *const_str_digest_97ac1738f0f1baa91e1ac43976924303;
extern PyObject *const_str_plain_code;
extern PyObject *const_str_plain_insert;
extern PyObject *const_tuple_str_plain_self_str_plain_msg_tuple;
static PyObject *const_str_plain_y_id;
static PyObject *const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple;
extern PyObject *const_str_plain_isfinite;
extern PyObject *const_str_plain_dtype;
extern PyObject *const_str_plain_module;
extern PyObject *const_tuple_str_plain_args_str_plain_kwargs_tuple;
extern PyObject *const_tuple_str_space_tuple;
static PyObject *const_tuple_str_digest_414106dd45b7d5d635f248d06d3dd69b_tuple;
static PyObject *const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple;
static PyObject *const_str_plain_vdt;
static PyObject *const_int_pos_79;
static PyObject *const_str_plain_maxulp;
static PyObject *const_str_plain___warningregistry__;
static PyObject *const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple;
extern PyObject *const_str_plain_platform;
extern PyObject *const_str_plain_exec;
static PyObject *const_str_plain_expected_regexp;
static PyObject *const_str_digest_3f5c98e5e86d39b731c4b8112a088b23;
static PyObject *const_str_digest_98da8b224f1d546fc73cc79ce8ec2f64;
static PyObject *const_str_plain_sc_actual;
static PyObject *const_str_plain_x_id;
extern PyObject *const_str_plain_zeros;
extern PyObject *const_tuple_str_plain_StringIO_tuple;
static PyObject *const_str_digest_10016e38cd632602d89b215a3ff5e326;
static PyObject *const_str_plain_ry;
static PyObject *const_str_plain_rx;
static PyObject *const_tuple_str_empty_true_str_empty_int_pos_6_tuple;
extern PyObject *const_dict_aae7649b9175b1ed5738500d56e46831;
static PyObject *const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
extern PyObject *const_str_plain_close;
extern PyObject *const_str_plain_readline;
extern PyObject *const_str_plain_atol;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple;
extern PyObject *const_str_plain_re;
extern PyObject *const_str_plain_rc;
extern PyObject *const_str_plain_cond;
extern PyObject *const_str_plain__getframe;
static PyObject *const_str_plain__AssertRaisesContext;
static PyObject *const_str_digest_a972e06f82fc56ec857dbfbe96117f49;
static PyObject *const_str_digest_c8d28aa411cf9a88d9aed194157300dd;
extern PyObject *const_str_plain_isclose;
extern PyObject *const_str_plain_float32;
static PyObject *const_str_plain__WARNING_DETAILS;
extern PyObject *const_str_plain_isscalar;
extern PyObject *const_str_plain_map;
static PyObject *const_tuple_str_digest_b8872718382dd39ffa4013e303d20ce5_tuple;
static PyObject *const_str_plain_assert_array_max_ulp;
extern PyObject *const_str_plain_max;
static PyObject *const_str_digest_8e1fb0dba5305fae554d7725ccda8ffe;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_ff575ecee9f5e6569e4868830fcd1828;
extern PyObject *const_str_plain_update;
extern PyObject *const_str_plain_random;
static PyObject *const_tuple_str_plain_astr_str_plain_dict_tuple;
extern PyObject *const_str_plain_str;
extern PyObject *const_str_plain_StringIO;
extern PyObject *const_str_plain_runstring;
static PyObject *const_tuple_str_digest_d712c8efe69b6cc6265cde822508613c_tuple;
static PyObject *const_str_plain_code_str;
static PyObject *const_str_plain_nulp_diff;
extern PyObject *const_str_plain___metaclass__;
extern PyObject *const_str_plain_simplefilter;
extern PyObject *const_str_plain_number;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple;
extern PyObject *const_dict_a00acf95180a0925f15877b623331589;
static PyObject *const_str_plain__integer_repr;
static PyObject *const_str_plain_hasval;
static PyObject *const_tuple_none_int_neg_1_none_none_tuple;
extern PyObject *const_str_plain_around;
static PyObject *const_str_digest_e6a3e69014088c1412fde6a02c7b5f18;
static PyObject *const_list_cc63f582defe892cc1040360b3f654ab_list;
static PyObject *const_str_digest_2ba8069a0e65272b7d5eefe3de48df04;
static PyObject *const_str_plain_isnumber;
extern PyObject *const_tuple_str_newline_tuple;
extern PyObject *const_int_pos_14;
static PyObject *const_str_plain_class_modules;
static PyObject *const_str_plain_x_isinf;
static PyObject *const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple;
static PyObject *const_str_digest_9272fa8326047e802806f21006304928;
extern PyObject *const_str_plain___lt__;
static PyObject *const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple;
extern PyObject *const_str_plain_time;
static PyObject *const_str_plain_gisnan;
extern PyObject *const_str_plain_record;
static PyObject *const_str_plain__warnreg_copies;
static PyObject *const_str_plain_local_values;
extern PyObject *const_str_plain_path;
static PyObject *const_str_digest_6d3284250f43666c7365582071a75109;
static PyObject *const_str_plain_union;
extern PyObject *const_str_plain_empty;
static PyObject *const_str_digest_a3a2dd55b816c9490fff0582d282bf95;
extern PyObject *const_str_plain_lineno;
static PyObject *const_float_0_01;
static PyObject *const_str_plain_CollectQueryData;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_aee23a7bc27675cbddeb9e3733927de8;
extern PyObject *const_str_plain_d2;
static PyObject *const_str_plain__assert_valid_refcount;
extern PyObject *const_str_plain_regex;
static PyObject *const_str_digest_d240ce9b96be4e59a73232989ed6258b;
extern PyObject *const_str_plain_all;
static PyObject *const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple;
static PyObject *const_str_digest_2504623327411b88e755c287d1ce7706;
static PyObject *const_tuple_str_plain_isfinite_str_plain_errstate_tuple;
extern PyObject *const_str_plain_scale;
static PyObject *const_str_digest_b8db3dccafc565b29732d3a675d809bc;
extern PyObject *const_str_plain_test;
static PyObject *const_str_plain__load_time;
static PyObject *const_str_digest_5e34d323ebf92513bcf9eee50bcad1a1;
static PyObject *const_str_plain_assert_string_equal;
static PyObject *const_str_digest_7448f51d5d6a82072cd1cfc231b95107;
static PyObject *const_float_1e_minus_07;
static PyObject *const_str_plain__gen_alignment_data;
extern PyObject *const_str_plain_DeprecationWarning;
extern PyObject *const_int_pos_24;
static PyObject *const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple;
extern PyObject *const_str_plain_np;
extern PyObject *const_str_plain_nt;
extern PyObject *const_str_plain_log;
extern PyObject *const_str_plain_f_globals;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple;
static PyObject *const_str_plain_CloseQuery;
static PyObject *const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple;
static PyObject *const_str_digest_78ccf3b264ec8c8b4336a7805cf6825b;
extern PyObject *const_str_plain_diff;
static PyObject *const_str_plain_exception_class;
extern PyObject *const_str_plain_splitext;
static PyObject *const_str_plain_decorate_methods;
extern PyObject *const_str_plain_tempfile;
static PyObject *const_str_plain_PDH_FMT_LONG;
static PyObject *const_str_plain_clear_and_catch_warnings;
extern PyObject *const_str_plain_arange;
extern PyObject *const_tuple_int_pos_1_tuple;
static PyObject *const_str_digest_4d26dfd9260b3b477170dd03ec01459a;
static PyObject *const_str_digest_205d9edff1d3f9adea34722be04b48c3;
static PyObject *const_str_digest_619d3f0d2ce117f4f715069e9c27f3fb;
extern PyObject *const_str_plain_tests;
extern PyObject *const_tuple_none_none_none_tuple;
extern PyObject *const_str_plain_frame;
extern PyObject *const_str_plain_float64;
static PyObject *const_str_plain_showwarning;
extern PyObject *const_str_plain_write;
extern PyObject *const_str_plain_tools;
extern PyObject *const_str_plain_pop;
extern PyObject *const_str_plain_pattern;
extern PyObject *const_tuple_int_0_int_pos_1_int_pos_2_tuple;
extern PyObject *const_str_plain_header;
static PyObject *const_tuple_str_plain_s_str_plain_msg_tuple;
extern PyObject *const_str_plain_globs;
extern PyObject *const_str_plain_isfunction;
static PyObject *const_str_digest_d0bd227ac888e31c52f69b54a1abf325;
static PyObject *const_tuple_bb3e481db1dd6ff7a20e545b3e6ed040_tuple;
static PyObject *const_str_plain_partial;
extern PyObject *const_int_pos_13;
static PyObject *const_str_plain_isactnan;
extern PyObject *const_int_pos_100;
extern PyObject *const_str_plain_tolist;
extern PyObject *const_str_plain_tb;
extern PyObject *const_str_plain_type;
static PyObject *const_str_plain_ay;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_plain_print_assert_equal;
static PyObject *const_str_plain_assert_array_compare;
extern PyObject *const_str_plain_subok;
static PyObject *const_str_digest_5d720dbb105833cafa470af4c6a246e5;
extern PyObject *const_tuple_str_plain_any_tuple;
extern PyObject *const_str_plain_msg;
extern PyObject *const_str_plain_real;
static PyObject *const_str_plain_WarningManager;
static PyObject *const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple;
extern PyObject *const_str_plain__m;
extern PyObject *const_str_plain_read;
extern PyObject *const_str_plain_view;
static PyObject *const_str_plain_x_isnan;
static PyObject *const_str_digest_f68e5190fae8b666170c0081d799be3d;
extern PyObject *const_str_plain_size;
extern PyObject *const_str_plain_numpy;
static PyObject *const_str_plain_assert_warns;
static PyObject *const_str_plain_Process;
extern PyObject *const_str_digest_3501979af1b70861f5e9d6a0f04129bf;
static PyObject *const_str_plain_DESIRED;
static PyObject *const_str_digest_794995e7a92670372eca23dc277265d0;
static PyObject *const_str_plain_format_exc;
extern PyObject *const_str_plain_file;
extern PyObject *const_str_plain_val;
static PyObject *const_long_neg_9223372036854775808;
static PyObject *const_str_digest_f17ec8fa29d8c2f383bd2b681e08c700;
static PyObject *const_str_plain__showwarning;
extern PyObject *const_str_plain_core;
static PyObject *const_str_digest_77842bb9b08e5dafb20eb78d1603a7b5;
static PyObject *const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple;
extern PyObject *const_str_plain_f_locals;
static PyObject *const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple;
static PyObject *const_tuple_str_plain_mkdtemp_tuple;
static PyObject *const_str_digest_dc6af44bedb1bd2ed8631e928612f8de;
extern PyObject *const_str_plain_rand;
static PyObject *const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple;
extern PyObject *const_str_plain_common_type;
extern PyObject *const_str_plain_int64;
static PyObject *const_tuple_67cbd1c28cbabbc57077461585c71131_tuple;
extern PyObject *const_int_pos_22;
static PyObject *const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple;
static PyObject *const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple;
static PyObject *const_str_plain_y_isnan;
extern PyObject *const_int_pos_10;
extern PyObject *const_int_pos_11;
extern PyObject *const_int_pos_12;
extern PyObject *const_str_plain_errstate;
static PyObject *const_str_digest_bfe64da05de8ea9d3dc43fbc0c1219dc;
extern PyObject *const_str_plain_exc_type;
static PyObject *const_tuple_int_pos_100_int_pos_100_tuple;
static PyObject *const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple;
static PyObject *const_str_plain_IgnoreException;
static PyObject *const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple;
static PyObject *const_str_digest_93bdfe3c415d4fa99cb2dd3e286cd6d4;
extern PyObject *const_tuple_str_empty_true_tuple;
extern PyObject *const_str_plain_expected;
static PyObject *const_str_digest_456ba859d4899c52c81b368fddf2b93e;
static PyObject *const_tuple_str_plain_nan_tuple;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple;
static PyObject *const_str_plain_gisinf;
extern PyObject *const_int_pos_6;
extern PyObject *const_str_plain_modules;
extern PyObject *const_int_pos_4;
extern PyObject *const_int_pos_5;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_int_pos_1;
static PyObject *const_str_plain_measure;
extern PyObject *const_int_pos_8;
static PyObject *const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple;
extern PyObject *const_str_plain_assert_;
static PyObject *const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple;
extern PyObject *const_int_pos_7;
extern PyObject *const_str_plain_array;
static PyObject *const_tuple_5eda0b27f24d46759a2212549f83add5_tuple;
static PyObject *const_str_plain_test_string;
static PyObject *const_str_plain_assert_raises_regex_impl;
extern PyObject *const_tuple_int_pos_1_none_tuple;
extern PyObject *const_str_plain_getpid;
extern PyObject *const_str_plain_utils;
extern PyObject *const_str_plain_decimal;
extern PyObject *const_str_plain_run;
static PyObject *const_str_digest_414106dd45b7d5d635f248d06d3dd69b;
extern PyObject *const_str_plain_DocTestFinder;
extern PyObject *const_str_plain_join;
extern PyObject *const_str_plain_io;
extern PyObject *const_str_plain_count;
extern PyObject *const_str_plain_doctest;
extern PyObject *const_str_plain_functools;
extern PyObject *const_str_plain_instance;
extern PyObject *const_str_plain_attr;
static PyObject *const_str_digest_e730e08a5048288138d6a29cf19c1970;
extern PyObject *const_str_plain_counter;
static PyObject *const_str_digest_81dc02c5320ca87464caf6ab2dc34793;
extern PyObject *const_str_plain_M;
extern PyObject *const_str_plain_flat;
extern PyObject *const_str_plain___eq__;
static PyObject *const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple;
extern PyObject *const_str_angle_string;
extern PyObject *const_str_plain___enter__;
static PyObject *const_str_digest_265f4d1ed58984854390f83322ffa237;
extern PyObject *const_int_pos_10000;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain_GetFormattedCounterValue;
static PyObject *const_str_plain_comp;
extern PyObject *const_str_plain__;
static PyObject *const_str_digest_7ac790b77fb2e800593801101da6838e;
static PyObject *const_str_plain_aliased;
static PyObject *const_str_plain_getrefcount;
extern PyObject *const_str_plain_shape;
extern PyObject *const_str_plain_l;
extern PyObject *const_str_plain_m;
extern PyObject *const_str_plain_o;
static PyObject *const_str_digest_e4fd0081f7638fce2542d5bc15151444;
extern PyObject *const_str_plain_j;
extern PyObject *const_str_plain_k;
extern PyObject *const_str_plain_compat_func_name;
extern PyObject *const_str_plain_basename;
extern PyObject *const_str_plain_f;
extern PyObject *const_str_plain_a;
extern PyObject *const_str_plain_b;
static PyObject *const_str_digest_4768c214d294535d1b934026c8fbb084;
extern PyObject *const_str_plain_line;
extern PyObject *const_str_plain_floor;
extern PyObject *const_str_plain_x;
static PyObject *const_str_plain_efmt;
extern PyObject *const_str_plain_z;
static PyObject *const_tuple_565527652c835353ad2b809796ba3ff4_tuple;
extern PyObject *const_str_plain_t;
extern PyObject *const_dict_d457aeaf5237c8e9bb82fdcc508844e3;
extern PyObject *const_str_plain_r;
extern PyObject *const_str_plain_s;
static PyObject *const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple;
extern PyObject *const_tuple_none_true_tuple;
static PyObject *const_str_plain__filters;
static PyObject *const_str_plain_npany;
static PyObject *const_str_digest_1f4842fd9edf1f66aa4685a11b6b5629;
static PyObject *const_str_plain_exc_name;
static PyObject *const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple;
static PyObject *const_str_digest_a4d91958b6481ca3e50f61fc19ae9d9b;
extern PyObject *const_str_plain_reshape;
extern PyObject *const_str_plain_jiffies;
static PyObject *const_str_digest_1b1287ebb1d4b1f4e8307f127391cdb6;
extern PyObject *const_str_plain_char;
static PyObject *const_str_digest_9070b22dec0007c1ed173e33a0aa0267;
static PyObject *const_str_digest_d712c8efe69b6cc6265cde822508613c;
extern PyObject *const_str_plain_precision;
extern PyObject *const_str_plain_imp;
static PyObject *const_str_digest_26a84684c8f1d9eaff79f73dc42d465f;
extern PyObject *const_str_plain_load_module;
extern PyObject *const_str_plain___all__;
extern PyObject *const_str_plain_funcname;
extern PyObject *const_int_0;
extern PyObject *const_str_plain_repr;
static PyObject *const_str_digest_f3aa1440a461949e616dcc68ee318c24;
static PyObject *const_str_plain_actual;
static PyObject *const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple;
static PyObject *const_tuple_str_plain_x_str_plain_np_tuple;
static PyObject *const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple;
extern PyObject *const_str_digest_bf444768bd6e1671ab2a507b3ebb9a78;
extern PyObject *const_tuple_str_empty_tuple;
static PyObject *const_str_plain_max_size;
static PyObject *const_str_digest_c73eac2486e2c9ab7692c43bd0d41203;
static PyObject *const_str_digest_02cd502966ce4ffa202bd7af634f2b08;
static PyObject *const_str_digest_91ae8b8c54cb3ed81a3eec57351d8df9;
static PyObject *const_str_plain_decorator;
extern PyObject *const_str_plain_append;
extern PyObject *const_str_plain_exc_info;
extern PyObject *const_str_plain_object;
extern PyObject *const_str_digest_b8872718382dd39ffa4013e303d20ce5;
extern PyObject *const_str_plain_print_function;
extern PyObject *const_str_angle_lambda;
extern PyObject *const_str_plain_copy;
extern PyObject *const_str_plain_issubclass;
extern PyObject *const_str_plain_func;
static PyObject *const_tuple_23579b8f33cf06464b97783a718253a4_tuple;
extern PyObject *const_dict_empty;
static PyObject *const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple;
static PyObject *const_tuple_false_tuple_empty_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_assert_array_almost_equal;
static PyObject *const_str_plain_assert_array_almost_equal_nulp;
extern PyObject *const_str_plain_filterwarnings;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_assert_allclose;
extern PyObject *const_float_10_0;
static PyObject *const_str_plain_assert_raises_regex;
extern PyObject *const_str_plain_function;
static PyObject *const_str_digest_33b666deea9552cec7dcfd3e4a99577a;
extern PyObject *const_str_plain_catch_warnings;
extern PyObject *const_str_plain_shutil;
extern PyObject *const_float_100_0;
static PyObject *const_str_digest_34e2f0683aaa71a2e4c98472a81cd441;
static PyObject *const_str_plain_contextmanager;
static PyObject *const_tuple_ed821113c19ffc8f967f602208d037c4_tuple;
static PyObject *const_str_plain_ACTUAL;
static PyObject *const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple;
static PyObject *const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple;
static PyObject *const_str_plain_warning_class;
static PyObject *const_tuple_long_neg_2147483648_tuple;
static PyObject *const_str_plain_mod_reg;
extern PyObject *const_str_plain_format;
static PyObject *const_tuple_int_pos_6_str_empty_true_tuple;
static PyObject *const_str_plain_yinfid;
static PyObject *const_tuple_49c70cfa143642b7953372e431b26b96_tuple;
static PyObject *const_str_digest_927431f33ccd0218ef72e4d9f521f626;
static PyObject *const_str_plain_RemoveCounter;
extern PyObject *const_str_plain___str__;
static PyObject *const_str_plain_inp2;
extern PyObject *const_str_plain_runner;
extern PyObject *const_str_plain_equal_nan;
extern PyObject *const_str_plain_abs;
static PyObject *const_tuple_str_plain_isinf_str_plain_errstate_tuple;
extern PyObject *const_str_plain_import_nose;
static PyObject *const_str_plain_isdesnan;
extern PyObject *const_str_plain_round;
extern PyObject *const_str_plain_machine;
static PyObject *const_tuple_944de8a92e09905a5d1b64e02c8558ea_tuple;
extern PyObject *const_str_plain_find_module;
static PyObject *const_str_digest_f4e00ed389370710d6e3415961014f9a;
extern PyObject *const_tuple_str_plain___tuple;
extern PyObject *const_str_plain_version_info;
static PyObject *const_dict_568ac7eccabc8d891d945f2840f427e7;
static PyObject *const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple;
static PyObject *const_str_digest_9080e25adf8a6e98de54bc174ec4ddea;
static PyObject *const_str_digest_6880cd150b36fa901d13829084b91966;
static PyObject *const_tuple_long_neg_9223372036854775808_tuple;
extern PyObject *const_str_plain___module__;
static PyObject *const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple;
extern PyObject *const_str_plain_locs;
extern PyObject *const_str_plain_splitlines;
extern PyObject *const_str_plain_dirname;
static PyObject *const_str_digest_70e70eb6e19e3ba7a8df4bc2c8ec15e1;
extern PyObject *const_str_plain_division;
extern PyObject *const_str_plain_list;
static PyObject *const_str_plain_times;
static PyObject *const_str_plain_y_isinf;
static PyObject *const_tuple_str_plain_python_int_0_tuple;
extern PyObject *const_str_plain_rstrip;
static PyObject *const_str_plain_assert_equal;
extern PyObject *const_str_plain_astype;
static PyObject *const_str_plain_usecomplex;
extern PyObject *const_str_plain_int32;
static PyObject *const_str_plain_testmatch;
extern PyObject *const_str_digest_fef7e379d8b29f70158a022afa317baa;
extern PyObject *const_str_plain_enumerate;
extern PyObject *const_tuple_str_plain_always_tuple;
extern PyObject *const_str_plain_ax;
static PyObject *const_str_plain_integer_repr;
static PyObject *const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple;
extern PyObject *const_str_plain_where;
extern PyObject *const_str_plain_values;
static PyObject *const_str_digest_1640eb8691b27b74c67f931efa0239c2;
static PyObject *const_str_digest_4dca8d1d7b81245cb563f97f4156f581;
static PyObject *const_str_digest_10bbed5c16f2cf6e80902c569bddb5f4;
extern PyObject *const_str_plain_compare;
static PyObject *const_tuple_str_digest_a3a2dd55b816c9490fff0582d282bf95_tuple;
extern PyObject *const_str_plain_numeric;
static PyObject *const_str_plain_processName;
static PyObject *const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple;
extern PyObject *const_str_plain_signbit;
extern PyObject *const_str_plain_dict;
extern PyObject *const_str_newline;
extern PyObject *const_str_plain_label;
static PyObject *const_str_plain_MakeCounterPath;
extern PyObject *const_str_plain_pprint;
static PyObject *const_str_digest_65b92a364d9686732f28856d1578c69f;
static PyObject *const_str_plain__category_name;
static PyObject *const_str_plain_desiredr;
static PyObject *const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple;
static PyObject *const_str_digest_8159168790756c2f5fb8ca65599559de;
static PyObject *const_tuple_501a23729e7545fd650e3d9d37994226_tuple;
extern PyObject *const_str_plain_assert_raises;
static PyObject *const_str_plain_filters;
extern PyObject *const_str_plain_traceback;
static PyObject *const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple;
extern PyObject *const_str_space;
extern PyObject *const_str_plain_inspect;
static PyObject *const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple;
static PyObject *const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple;
static PyObject *const_str_plain_elapsed;
static PyObject *const_str_plain_inp1;
static PyObject *const_str_plain_max_nulp;
static PyObject *const_str_plain_inum;
extern PyObject *const_str_plain_names;
static PyObject *const_str_plain_assert_array_less;
static PyObject *const_tuple_09dcbffd359d480fc172eae968ca9191_tuple;
extern PyObject *const_str_plain_failureException;
extern PyObject *const_str_plain_ignore;
static PyObject *const_str_digest_01f1c58babb9e9d1a30d908b35924c3d;
extern PyObject *const_str_plain_any;
extern PyObject *const_str_plain_absolute_import;
extern PyObject *const_str_plain_st;
static PyObject *const_str_plain_xinfid;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain_AddCounter;
static PyObject *const_str_digest_08ce15b16d2d1d5917a837f2d3c754b7;
extern PyObject *const_str_plain_float_;
static PyObject *const_str_digest_91d13b44af9a5a13a2155d933ca121b5;
extern PyObject *const_str_plain_description;
extern PyObject *const_str_plain_impl;
extern PyObject *const_str_plain_python;
extern PyObject *const_str_plain_tuple;
extern PyObject *const_str_empty;
static PyObject *const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple;
extern PyObject *const_str_digest_4dcaa53e76b317037ea1e395a40c5c89;
extern PyObject *const_str_plain_rmtree;
static PyObject *const_str_digest_8b83d5866bfb89b1d61fc7b4d1c462b2;
static PyObject *const_str_plain_hq;
static PyObject *const_str_plain_contextlib;
extern PyObject *const_str_plain_result;
static PyObject *const_str_plain_hc;
extern PyObject *const_str_plain_linux;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_desiredi;
static PyObject *const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple;
static PyObject *const_str_digest_43e8d9e479afe33589f6c45c6a84edf4;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_digest_50e4cc95dfbb393fb8a962e3fe72cc12 = UNSTREAM_STRING( &constant_bin[ 573112 ], 20, 0 );
    const_str_plain_r_func = UNSTREAM_STRING( &constant_bin[ 711072 ], 6, 1 );
    const_str_plain_pathname = UNSTREAM_STRING( &constant_bin[ 667960 ], 8, 1 );
    const_str_plain_mgr = UNSTREAM_STRING( &constant_bin[ 144374 ], 3, 1 );
    const_tuple_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1_tuple = PyTuple_New( 1 );
    const_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1 = UNSTREAM_STRING( &constant_bin[ 1782205 ], 17, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1_tuple, 0, const_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1 ); Py_INCREF( const_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1 );
    const_str_digest_119597c8dc0968aaf226da43c6fe7f86 = UNSTREAM_STRING( &constant_bin[ 1782222 ], 84, 0 );
    const_str_plain_safe_comparison = UNSTREAM_STRING( &constant_bin[ 1782306 ], 15, 1 );
    const_str_plain_diff_list = UNSTREAM_STRING( &constant_bin[ 1782321 ], 9, 1 );
    const_str_digest_4b7c0e7f23efc5fa89db71ab487de5e1 = UNSTREAM_STRING( &constant_bin[ 1782330 ], 1243, 0 );
    const_str_digest_80faa6a434267444203aa2503ce280fc = UNSTREAM_STRING( &constant_bin[ 1783573 ], 309, 0 );
    const_str_plain_callable_obj = UNSTREAM_STRING( &constant_bin[ 1783882 ], 12, 1 );
    const_str_digest_ba3a38dfc99e9008935c1c3fb4efa93f = UNSTREAM_STRING( &constant_bin[ 1783894 ], 27, 0 );
    const_str_plain_comparison = UNSTREAM_STRING( &constant_bin[ 259071 ], 10, 1 );
    const_str_plain_rundocs = UNSTREAM_STRING( &constant_bin[ 1783921 ], 7, 1 );
    const_str_plain_d3 = UNSTREAM_STRING( &constant_bin[ 709285 ], 2, 1 );
    const_tuple_str_plain_isnan_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_isnan_tuple, 0, const_str_plain_isnan ); Py_INCREF( const_str_plain_isnan );
    const_str_plain_unary = UNSTREAM_STRING( &constant_bin[ 1242934 ], 5, 1 );
    const_str_digest_f4e551f0ba39cf5d79afe90ee6966e81 = UNSTREAM_STRING( &constant_bin[ 1783928 ], 356, 0 );
    const_str_plain_binary = UNSTREAM_STRING( &constant_bin[ 147789 ], 6, 1 );
    const_str_digest_763dafaf263503aed0533c163ee5f659 = UNSTREAM_STRING( &constant_bin[ 1784284 ], 141, 0 );
    const_str_plain_assert_almost_equal = UNSTREAM_STRING( &constant_bin[ 1784425 ], 19, 1 );
    const_str_plain_GetPerformanceAttributes = UNSTREAM_STRING( &constant_bin[ 1784444 ], 24, 1 );
    const_dict_c05cf8ed9016cad683e758f62a6613d4 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_c05cf8ed9016cad683e758f62a6613d4, const_str_plain_verbose, Py_False );
    assert( PyDict_Size( const_dict_c05cf8ed9016cad683e758f62a6613d4 ) == 1 );
    const_str_digest_ef2d5d7b0c9e4f3b1e50776d5d0fa6e5 = UNSTREAM_STRING( &constant_bin[ 1784468 ], 16, 0 );
    const_long_neg_2147483648 = PyLong_FromLong( -2147483647l ); // To be corrected with -1 in-place next lines.
    CHECK_OBJECT( const_int_pos_1 );
    const_long_neg_2147483648 = PyNumber_InPlaceSubtract( const_long_neg_2147483648, PyLong_FromLong( 1 ) );
    const_str_plain_actuali = UNSTREAM_STRING( &constant_bin[ 1784484 ], 7, 1 );
    const_str_plain_spacing = UNSTREAM_STRING( &constant_bin[ 477906 ], 7, 1 );
    const_str_digest_0c802ca97afbb39d58c81bee322d6fe6 = UNSTREAM_STRING( &constant_bin[ 1784491 ], 44, 0 );
    const_str_plain_significant = UNSTREAM_STRING( &constant_bin[ 530304 ], 11, 1 );
    const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple, 1, const_str_plain_record ); Py_INCREF( const_str_plain_record );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple, 2, const_str_plain_modules ); Py_INCREF( const_str_plain_modules );
    const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple, 0, const_str_plain_dtype ); Py_INCREF( const_str_plain_dtype );
    PyTuple_SET_ITEM( const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    const_str_plain_max_size = UNSTREAM_STRING( &constant_bin[ 1784535 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple, 2, const_str_plain_max_size ); Py_INCREF( const_str_plain_max_size );
    const_str_plain_actualr = UNSTREAM_STRING( &constant_bin[ 1784543 ], 7, 1 );
    const_tuple_22011052c50ffffeee9babd5969d09da_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 0, const_str_plain_header ); Py_INCREF( const_str_plain_header );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 1, const_str_plain_decimal ); Py_INCREF( const_str_plain_decimal );
    const_str_plain_actual = UNSTREAM_STRING( &constant_bin[ 14807 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 2, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    const_str_plain_desired = UNSTREAM_STRING( &constant_bin[ 15433 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 3, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 4, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 5, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    const_str_plain__build_err_msg = UNSTREAM_STRING( &constant_bin[ 1784550 ], 14, 1 );
    const_str_plain__proc_pid_stat = UNSTREAM_STRING( &constant_bin[ 1784564 ], 14, 1 );
    const_str_digest_d6b3345eef013f973e768c3ac758531f = UNSTREAM_STRING( &constant_bin[ 1784578 ], 42, 0 );
    const_dict_ff8ef3bf3e81fbdb8830624987bd4652 = _PyDict_NewPresized( 1 );
    const_str_plain_hasval = UNSTREAM_STRING( &constant_bin[ 1784620 ], 6, 1 );
    const_str_digest_02cd502966ce4ffa202bd7af634f2b08 = UNSTREAM_STRING( &constant_bin[ 1784626 ], 4, 0 );
    PyDict_SetItem( const_dict_ff8ef3bf3e81fbdb8830624987bd4652, const_str_plain_hasval, const_str_digest_02cd502966ce4ffa202bd7af634f2b08 );
    assert( PyDict_Size( const_dict_ff8ef3bf3e81fbdb8830624987bd4652 ) == 1 );
    const_tuple_str_plain_ndarray_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ndarray_tuple, 0, const_str_plain_ndarray ); Py_INCREF( const_str_plain_ndarray );
    const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, 0, const_str_plain_iscomplexobj ); Py_INCREF( const_str_plain_iscomplexobj );
    PyTuple_SET_ITEM( const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, 1, const_str_plain_real ); Py_INCREF( const_str_plain_real );
    PyTuple_SET_ITEM( const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, 2, const_str_plain_imag ); Py_INCREF( const_str_plain_imag );
    const_str_plain__record = UNSTREAM_STRING( &constant_bin[ 46287 ], 7, 1 );
    const_str_plain_chk_same_position = UNSTREAM_STRING( &constant_bin[ 1784630 ], 17, 1 );
    const_str_plain_assert_approx_equal = UNSTREAM_STRING( &constant_bin[ 1784647 ], 19, 1 );
    const_str_plain__module = UNSTREAM_STRING( &constant_bin[ 44401 ], 7, 1 );
    const_str_digest_13df72bccf988d02cd7b35fa667a8f38 = UNSTREAM_STRING( &constant_bin[ 1784666 ], 391, 0 );
    const_str_digest_ca97b54f456b9d063ac2656c890932f6 = UNSTREAM_STRING( &constant_bin[ 1785057 ], 49, 0 );
    const_str_plain_nulp = UNSTREAM_STRING( &constant_bin[ 1782557 ], 4, 1 );
    const_tuple_str_plain_import_nose_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_import_nose_tuple, 0, const_str_plain_import_nose ); Py_INCREF( const_str_plain_import_nose );
    const_str_plain_sc_desired = UNSTREAM_STRING( &constant_bin[ 1785106 ], 10, 1 );
    const_str_digest_6f8248c0cd0a61aee0231b6be5326ece = UNSTREAM_STRING( &constant_bin[ 1785116 ], 596, 0 );
    const_str_digest_8f7e46a753006e8bd692e624f140d763 = UNSTREAM_STRING( &constant_bin[ 1785712 ], 395, 0 );
    const_tuple_str_plain_partial_tuple = PyTuple_New( 1 );
    const_str_plain_partial = UNSTREAM_STRING( &constant_bin[ 460394 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_partial_tuple, 0, const_str_plain_partial ); Py_INCREF( const_str_plain_partial );
    const_str_plain_cls_attr = UNSTREAM_STRING( &constant_bin[ 1786107 ], 8, 1 );
    const_str_plain_ref = UNSTREAM_STRING( &constant_bin[ 531 ], 3, 1 );
    const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple, 1, const_str_plain_isfinite ); Py_INCREF( const_str_plain_isfinite );
    PyTuple_SET_ITEM( const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple, 2, const_str_plain_errstate ); Py_INCREF( const_str_plain_errstate );
    PyTuple_SET_ITEM( const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple, 3, const_str_plain_st ); Py_INCREF( const_str_plain_st );
    const_tuple_int_pos_7_str_empty_true_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_int_pos_7_str_empty_true_tuple, 0, const_int_pos_7 ); Py_INCREF( const_int_pos_7 );
    PyTuple_SET_ITEM( const_tuple_int_pos_7_str_empty_true_tuple, 1, const_str_empty ); Py_INCREF( const_str_empty );
    PyTuple_SET_ITEM( const_tuple_int_pos_7_str_empty_true_tuple, 2, Py_True ); Py_INCREF( Py_True );
    const_str_digest_6cc5cefb53b579746bcbb4d68e503416 = UNSTREAM_STRING( &constant_bin[ 1786115 ], 26, 0 );
    const_str_plain_OpenQuery = UNSTREAM_STRING( &constant_bin[ 1786141 ], 9, 1 );
    const_str_plain__diff = UNSTREAM_STRING( &constant_bin[ 31244 ], 5, 1 );
    const_str_digest_e6c9ce73383c66ad08c690eb2446230f = UNSTREAM_STRING( &constant_bin[ 1786150 ], 2092, 0 );
    const_str_plain_assert_array_equal = UNSTREAM_STRING( &constant_bin[ 1787409 ], 18, 1 );
    const_str_digest_3720bdeeb610c78f6c12dfac8edb8c59 = UNSTREAM_STRING( &constant_bin[ 1788242 ], 1137, 0 );
    const_dict_117eec822878c8a1e3d3fe65ec8106fd = _PyDict_NewPresized( 1 );
    const_str_digest_08ce15b16d2d1d5917a837f2d3c754b7 = UNSTREAM_STRING( &constant_bin[ 1088009 ], 4, 0 );
    PyDict_SetItem( const_dict_117eec822878c8a1e3d3fe65ec8106fd, const_str_plain_hasval, const_str_digest_08ce15b16d2d1d5917a837f2d3c754b7 );
    assert( PyDict_Size( const_dict_117eec822878c8a1e3d3fe65ec8106fd ) == 1 );
    const_str_plain_gisfinite = UNSTREAM_STRING( &constant_bin[ 1789379 ], 9, 1 );
    const_str_digest_58cd5d23011fe45d68c661820d95e72a = UNSTREAM_STRING( &constant_bin[ 1789388 ], 184, 0 );
    const_str_plain_smsg = UNSTREAM_STRING( &constant_bin[ 1789572 ], 4, 1 );
    const_str_digest_9fe74df5f37fb0f3159d9349320195f0 = UNSTREAM_STRING( &constant_bin[ 1789576 ], 670, 0 );
    const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 0, const_str_plain_op ); Py_INCREF( const_str_plain_op );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 1, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 2, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 3, const_str_plain_c ); Py_INCREF( const_str_plain_c );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 4, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 5, const_str_plain_rc ); Py_INCREF( const_str_plain_rc );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 6, const_str_plain_j ); Py_INCREF( const_str_plain_j );
    PyTuple_SET_ITEM( const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 7, const_str_plain_d ); Py_INCREF( const_str_plain_d );
    const_tuple_str_plain__load_time_str_plain_time_tuple = PyTuple_New( 2 );
    const_str_plain__load_time = UNSTREAM_STRING( &constant_bin[ 1790246 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain__load_time_str_plain_time_tuple, 0, const_str_plain__load_time ); Py_INCREF( const_str_plain__load_time );
    PyTuple_SET_ITEM( const_tuple_str_plain__load_time_str_plain_time_tuple, 1, const_str_plain_time ); Py_INCREF( const_str_plain_time );
    const_str_plain_build_err_msg = UNSTREAM_STRING( &constant_bin[ 1784551 ], 13, 1 );
    const_str_plain_assert_raises_regexp = UNSTREAM_STRING( &constant_bin[ 1790256 ], 20, 1 );
    const_str_plain_win32pdh = UNSTREAM_STRING( &constant_bin[ 1790276 ], 8, 1 );
    const_str_digest_9f56a9d5b59582b4c0da971506f2216a = UNSTREAM_STRING( &constant_bin[ 1790284 ], 1862, 0 );
    const_tuple_str_digest_f68e5190fae8b666170c0081d799be3d_tuple = PyTuple_New( 1 );
    const_str_digest_f68e5190fae8b666170c0081d799be3d = UNSTREAM_STRING( &constant_bin[ 1792146 ], 10, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f68e5190fae8b666170c0081d799be3d_tuple, 0, const_str_digest_f68e5190fae8b666170c0081d799be3d ); Py_INCREF( const_str_digest_f68e5190fae8b666170c0081d799be3d );
    const_str_digest_903d6b58b25be7a46249f406f02b7d41 = UNSTREAM_STRING( &constant_bin[ 1792156 ], 723, 0 );
    const_str_plain_assert_no_warnings = UNSTREAM_STRING( &constant_bin[ 1792879 ], 18, 1 );
    const_tuple_str_plain_zeros_str_plain_float64_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_zeros_str_plain_float64_tuple, 0, const_str_plain_zeros ); Py_INCREF( const_str_plain_zeros );
    PyTuple_SET_ITEM( const_tuple_str_plain_zeros_str_plain_float64_tuple, 1, const_str_plain_float64 ); Py_INCREF( const_str_plain_float64 );
    const_tuple_428ef0c7dcad024f447304283fd888c5_tuple = PyTuple_New( 6 );
    const_str_plain_warning_class = UNSTREAM_STRING( &constant_bin[ 1792897 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 0, const_str_plain_warning_class ); Py_INCREF( const_str_plain_warning_class );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 1, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 2, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 3, const_str_plain_kw ); Py_INCREF( const_str_plain_kw );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 4, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 5, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_WarningMessage = UNSTREAM_STRING( &constant_bin[ 1792910 ], 14, 1 );
    const_str_plain__entered = UNSTREAM_STRING( &constant_bin[ 1792924 ], 8, 1 );
    const_str_digest_97ac1738f0f1baa91e1ac43976924303 = UNSTREAM_STRING( &constant_bin[ 1792932 ], 68, 0 );
    const_str_plain_y_id = UNSTREAM_STRING( &constant_bin[ 1793000 ], 4, 1 );
    const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple, 1, const_str_plain_record ); Py_INCREF( const_str_plain_record );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple, 2, const_str_plain_module ); Py_INCREF( const_str_plain_module );
    const_tuple_str_digest_414106dd45b7d5d635f248d06d3dd69b_tuple = PyTuple_New( 1 );
    const_str_digest_414106dd45b7d5d635f248d06d3dd69b = UNSTREAM_STRING( &constant_bin[ 30744 ], 2, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_414106dd45b7d5d635f248d06d3dd69b_tuple, 0, const_str_digest_414106dd45b7d5d635f248d06d3dd69b ); Py_INCREF( const_str_digest_414106dd45b7d5d635f248d06d3dd69b );
    const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 2, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 3, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    const_str_plain_vdt = UNSTREAM_STRING( &constant_bin[ 1793004 ], 3, 1 );
    const_int_pos_79 = PyInt_FromLong( 79l );
    const_str_plain_maxulp = UNSTREAM_STRING( &constant_bin[ 1793007 ], 6, 1 );
    const_str_plain___warningregistry__ = UNSTREAM_STRING( &constant_bin[ 1793013 ], 19, 1 );
    const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple = PyTuple_New( 16 );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 0, const_str_plain_filename ); Py_INCREF( const_str_plain_filename );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 1, const_str_plain_raise_on_error ); Py_INCREF( const_str_plain_raise_on_error );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 2, const_str_plain_doctest ); Py_INCREF( const_str_plain_doctest );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 3, const_str_plain_imp ); Py_INCREF( const_str_plain_imp );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 4, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 5, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 6, const_str_plain_path ); Py_INCREF( const_str_plain_path );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 7, const_str_plain_file ); Py_INCREF( const_str_plain_file );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 8, const_str_plain_pathname ); Py_INCREF( const_str_plain_pathname );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 9, const_str_plain_description ); Py_INCREF( const_str_plain_description );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 10, const_str_plain_m ); Py_INCREF( const_str_plain_m );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 11, const_str_plain_tests ); Py_INCREF( const_str_plain_tests );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 12, const_str_plain_runner ); Py_INCREF( const_str_plain_runner );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 13, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 14, const_str_plain_out ); Py_INCREF( const_str_plain_out );
    PyTuple_SET_ITEM( const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 15, const_str_plain_test ); Py_INCREF( const_str_plain_test );
    const_str_plain_expected_regexp = UNSTREAM_STRING( &constant_bin[ 1783662 ], 15, 1 );
    const_str_digest_3f5c98e5e86d39b731c4b8112a088b23 = UNSTREAM_STRING( &constant_bin[ 1793032 ], 31, 0 );
    const_str_digest_98da8b224f1d546fc73cc79ce8ec2f64 = UNSTREAM_STRING( &constant_bin[ 1793063 ], 32, 0 );
    const_str_plain_sc_actual = UNSTREAM_STRING( &constant_bin[ 1793095 ], 9, 1 );
    const_str_plain_x_id = UNSTREAM_STRING( &constant_bin[ 1793104 ], 4, 1 );
    const_str_digest_10016e38cd632602d89b215a3ff5e326 = UNSTREAM_STRING( &constant_bin[ 1793108 ], 2443, 0 );
    const_str_plain_ry = UNSTREAM_STRING( &constant_bin[ 2482 ], 2, 1 );
    const_str_plain_rx = UNSTREAM_STRING( &constant_bin[ 703812 ], 2, 1 );
    const_tuple_str_empty_true_str_empty_int_pos_6_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_empty_true_str_empty_int_pos_6_tuple, 0, const_str_empty ); Py_INCREF( const_str_empty );
    PyTuple_SET_ITEM( const_tuple_str_empty_true_str_empty_int_pos_6_tuple, 1, Py_True ); Py_INCREF( Py_True );
    PyTuple_SET_ITEM( const_tuple_str_empty_true_str_empty_int_pos_6_tuple, 2, const_str_empty ); Py_INCREF( const_str_empty );
    PyTuple_SET_ITEM( const_tuple_str_empty_true_str_empty_int_pos_6_tuple, 3, const_int_pos_6 ); Py_INCREF( const_int_pos_6 );
    const_str_digest_92d25e009369af0f8a9ad22719acbbe8 = UNSTREAM_STRING( &constant_bin[ 1795551 ], 12, 0 );
    const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, 0, const_str_plain_around ); Py_INCREF( const_str_plain_around );
    PyTuple_SET_ITEM( const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, 1, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    PyTuple_SET_ITEM( const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, 2, const_str_plain_float_ ); Py_INCREF( const_str_plain_float_ );
    PyTuple_SET_ITEM( const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, 3, const_str_plain_result_type ); Py_INCREF( const_str_plain_result_type );
    PyTuple_SET_ITEM( const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, 4, const_str_plain_array ); Py_INCREF( const_str_plain_array );
    const_str_plain__AssertRaisesContext = UNSTREAM_STRING( &constant_bin[ 1795563 ], 20, 1 );
    const_str_digest_a972e06f82fc56ec857dbfbe96117f49 = UNSTREAM_STRING( &constant_bin[ 1795583 ], 67, 0 );
    const_str_digest_c8d28aa411cf9a88d9aed194157300dd = UNSTREAM_STRING( &constant_bin[ 1389 ], 2, 0 );
    const_str_plain__WARNING_DETAILS = UNSTREAM_STRING( &constant_bin[ 1795650 ], 16, 1 );
    const_tuple_str_digest_b8872718382dd39ffa4013e303d20ce5_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b8872718382dd39ffa4013e303d20ce5_tuple, 0, const_str_digest_b8872718382dd39ffa4013e303d20ce5 ); Py_INCREF( const_str_digest_b8872718382dd39ffa4013e303d20ce5 );
    const_str_plain_assert_array_max_ulp = UNSTREAM_STRING( &constant_bin[ 1782886 ], 20, 1 );
    const_str_digest_8e1fb0dba5305fae554d7725ccda8ffe = UNSTREAM_STRING( &constant_bin[ 1795666 ], 42, 0 );
    const_str_digest_ff575ecee9f5e6569e4868830fcd1828 = UNSTREAM_STRING( &constant_bin[ 1795708 ], 385, 0 );
    const_tuple_str_plain_astr_str_plain_dict_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_astr_str_plain_dict_tuple, 0, const_str_plain_astr ); Py_INCREF( const_str_plain_astr );
    PyTuple_SET_ITEM( const_tuple_str_plain_astr_str_plain_dict_tuple, 1, const_str_plain_dict ); Py_INCREF( const_str_plain_dict );
    const_tuple_str_digest_d712c8efe69b6cc6265cde822508613c_tuple = PyTuple_New( 1 );
    const_str_digest_d712c8efe69b6cc6265cde822508613c = UNSTREAM_STRING( &constant_bin[ 33220 ], 2, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d712c8efe69b6cc6265cde822508613c_tuple, 0, const_str_digest_d712c8efe69b6cc6265cde822508613c ); Py_INCREF( const_str_digest_d712c8efe69b6cc6265cde822508613c );
    const_str_plain_code_str = UNSTREAM_STRING( &constant_bin[ 7535 ], 8, 1 );
    const_str_plain_nulp_diff = UNSTREAM_STRING( &constant_bin[ 1796093 ], 9, 1 );
    const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple = PyTuple_New( 5 );
    const_float_1e_minus_07 = UNSTREAM_FLOAT( &constant_bin[ 1796102 ] );
    PyTuple_SET_ITEM( const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple, 0, const_float_1e_minus_07 ); Py_INCREF( const_float_1e_minus_07 );
    PyTuple_SET_ITEM( const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple, 2, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple, 3, const_str_empty ); Py_INCREF( const_str_empty );
    PyTuple_SET_ITEM( const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple, 4, Py_True ); Py_INCREF( Py_True );
    const_str_plain__integer_repr = UNSTREAM_STRING( &constant_bin[ 1796110 ], 13, 1 );
    const_tuple_none_int_neg_1_none_none_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_none_int_neg_1_none_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_neg_1_none_none_tuple, 1, const_int_neg_1 ); Py_INCREF( const_int_neg_1 );
    PyTuple_SET_ITEM( const_tuple_none_int_neg_1_none_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_neg_1_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    const_str_digest_e6a3e69014088c1412fde6a02c7b5f18 = UNSTREAM_STRING( &constant_bin[ 1796123 ], 30, 0 );
    const_list_cc63f582defe892cc1040360b3f654ab_list = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 1796153 ], 549 );
    const_str_digest_2ba8069a0e65272b7d5eefe3de48df04 = UNSTREAM_STRING( &constant_bin[ 1796702 ], 927, 0 );
    const_str_plain_isnumber = UNSTREAM_STRING( &constant_bin[ 1797629 ], 8, 1 );
    const_str_plain_class_modules = UNSTREAM_STRING( &constant_bin[ 1797637 ], 13, 1 );
    const_str_plain_x_isinf = UNSTREAM_STRING( &constant_bin[ 1797650 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple, 1, const_str_plain_mod ); Py_INCREF( const_str_plain_mod );
    const_str_plain_mod_reg = UNSTREAM_STRING( &constant_bin[ 1797657 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple, 2, const_str_plain_mod_reg ); Py_INCREF( const_str_plain_mod_reg );
    const_str_digest_9272fa8326047e802806f21006304928 = UNSTREAM_STRING( &constant_bin[ 1797664 ], 37, 0 );
    const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple = PyTuple_New( 3 );
    const_str_plain_processName = UNSTREAM_STRING( &constant_bin[ 1797701 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple, 0, const_str_plain_processName ); Py_INCREF( const_str_plain_processName );
    PyTuple_SET_ITEM( const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple, 1, const_str_plain_instance ); Py_INCREF( const_str_plain_instance );
    PyTuple_SET_ITEM( const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple, 2, const_str_plain_win32pdh ); Py_INCREF( const_str_plain_win32pdh );
    const_str_plain_gisnan = UNSTREAM_STRING( &constant_bin[ 1797712 ], 6, 1 );
    const_str_plain__warnreg_copies = UNSTREAM_STRING( &constant_bin[ 1797718 ], 15, 1 );
    const_str_plain_local_values = UNSTREAM_STRING( &constant_bin[ 1797733 ], 12, 1 );
    const_str_digest_6d3284250f43666c7365582071a75109 = UNSTREAM_STRING( &constant_bin[ 1797745 ], 1092, 0 );
    const_str_plain_union = UNSTREAM_STRING( &constant_bin[ 781966 ], 5, 1 );
    const_str_digest_a3a2dd55b816c9490fff0582d282bf95 = UNSTREAM_STRING( &constant_bin[ 14215 ], 2, 0 );
    const_float_0_01 = UNSTREAM_FLOAT( &constant_bin[ 1798837 ] );
    const_str_plain_CollectQueryData = UNSTREAM_STRING( &constant_bin[ 1798845 ], 16, 1 );
    const_str_digest_aee23a7bc27675cbddeb9e3733927de8 = UNSTREAM_STRING( &constant_bin[ 1798861 ], 329, 0 );
    const_str_plain__assert_valid_refcount = UNSTREAM_STRING( &constant_bin[ 1799190 ], 22, 1 );
    const_str_digest_d240ce9b96be4e59a73232989ed6258b = UNSTREAM_STRING( &constant_bin[ 1799212 ], 20, 0 );
    const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple, 1, const_str_plain_exc_info ); Py_INCREF( const_str_plain_exc_info );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple, 2, const_str_plain_mod ); Py_INCREF( const_str_plain_mod );
    const_str_digest_2504623327411b88e755c287d1ce7706 = UNSTREAM_STRING( &constant_bin[ 1799232 ], 24, 0 );
    const_tuple_str_plain_isfinite_str_plain_errstate_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_isfinite_str_plain_errstate_tuple, 0, const_str_plain_isfinite ); Py_INCREF( const_str_plain_isfinite );
    PyTuple_SET_ITEM( const_tuple_str_plain_isfinite_str_plain_errstate_tuple, 1, const_str_plain_errstate ); Py_INCREF( const_str_plain_errstate );
    const_str_digest_b8db3dccafc565b29732d3a675d809bc = UNSTREAM_STRING( &constant_bin[ 1799256 ], 47, 0 );
    const_str_digest_5e34d323ebf92513bcf9eee50bcad1a1 = UNSTREAM_STRING( &constant_bin[ 1799303 ], 103, 0 );
    const_str_plain_assert_string_equal = UNSTREAM_STRING( &constant_bin[ 1789650 ], 19, 1 );
    const_str_digest_7448f51d5d6a82072cd1cfc231b95107 = UNSTREAM_STRING( &constant_bin[ 1799406 ], 43, 0 );
    const_str_plain__gen_alignment_data = UNSTREAM_STRING( &constant_bin[ 1799449 ], 19, 1 );
    const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 0, const_str_plain_rx ); Py_INCREF( const_str_plain_rx );
    PyTuple_SET_ITEM( const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 1, const_str_plain_ry ); Py_INCREF( const_str_plain_ry );
    PyTuple_SET_ITEM( const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 2, const_str_plain_vdt ); Py_INCREF( const_str_plain_vdt );
    PyTuple_SET_ITEM( const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 3, const_str_plain_diff ); Py_INCREF( const_str_plain_diff );
    PyTuple_SET_ITEM( const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 4, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple, 1, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple, 2, const_str_plain_comparison ); Py_INCREF( const_str_plain_comparison );
    const_str_plain_CloseQuery = UNSTREAM_STRING( &constant_bin[ 1799468 ], 10, 1 );
    const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 1, const_str_plain_regex ); Py_INCREF( const_str_plain_regex );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 2, const_str_plain_callable_obj ); Py_INCREF( const_str_plain_callable_obj );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 3, const_str_plain_a ); Py_INCREF( const_str_plain_a );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 4, const_str_plain_kw ); Py_INCREF( const_str_plain_kw );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 5, const_str_plain_mgr ); Py_INCREF( const_str_plain_mgr );
    PyTuple_SET_ITEM( const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 6, const_str_plain__AssertRaisesContext ); Py_INCREF( const_str_plain__AssertRaisesContext );
    const_str_digest_78ccf3b264ec8c8b4336a7805cf6825b = UNSTREAM_STRING( &constant_bin[ 1799478 ], 14, 0 );
    const_str_plain_exception_class = UNSTREAM_STRING( &constant_bin[ 1783612 ], 15, 1 );
    const_str_plain_decorate_methods = UNSTREAM_STRING( &constant_bin[ 1796363 ], 16, 1 );
    const_str_plain_PDH_FMT_LONG = UNSTREAM_STRING( &constant_bin[ 1799492 ], 12, 1 );
    const_str_plain_clear_and_catch_warnings = UNSTREAM_STRING( &constant_bin[ 1796678 ], 24, 1 );
    const_str_digest_4d26dfd9260b3b477170dd03ec01459a = UNSTREAM_STRING( &constant_bin[ 1787772 ], 20, 0 );
    const_str_digest_205d9edff1d3f9adea34722be04b48c3 = UNSTREAM_STRING( &constant_bin[ 1799504 ], 81, 0 );
    const_str_digest_619d3f0d2ce117f4f715069e9c27f3fb = UNSTREAM_STRING( &constant_bin[ 1799585 ], 33, 0 );
    const_str_plain_showwarning = UNSTREAM_STRING( &constant_bin[ 1796918 ], 11, 1 );
    const_tuple_str_plain_s_str_plain_msg_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_msg_tuple, 0, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_msg_tuple, 1, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_digest_d0bd227ac888e31c52f69b54a1abf325 = UNSTREAM_STRING( &constant_bin[ 91539 ], 7, 0 );
    const_tuple_bb3e481db1dd6ff7a20e545b3e6ed040_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 1799618 ], 326 );
    const_str_plain_isactnan = UNSTREAM_STRING( &constant_bin[ 1799944 ], 8, 1 );
    const_str_plain_ay = UNSTREAM_STRING( &constant_bin[ 1447 ], 2, 1 );
    const_str_plain_print_assert_equal = UNSTREAM_STRING( &constant_bin[ 1796409 ], 18, 1 );
    const_str_plain_assert_array_compare = UNSTREAM_STRING( &constant_bin[ 1799952 ], 20, 1 );
    const_str_digest_5d720dbb105833cafa470af4c6a246e5 = UNSTREAM_STRING( &constant_bin[ 1799972 ], 10, 0 );
    const_str_plain_WarningManager = UNSTREAM_STRING( &constant_bin[ 1797416 ], 14, 1 );
    const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 0, const_str_plain_exception_class ); Py_INCREF( const_str_plain_exception_class );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 1, const_str_plain_expected_regexp ); Py_INCREF( const_str_plain_expected_regexp );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 2, const_str_plain_callable_obj ); Py_INCREF( const_str_plain_callable_obj );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 3, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 4, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 5, const_str_plain_nose ); Py_INCREF( const_str_plain_nose );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 6, const_str_plain__AssertRaisesContext ); Py_INCREF( const_str_plain__AssertRaisesContext );
    PyTuple_SET_ITEM( const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 7, const_str_plain_impl ); Py_INCREF( const_str_plain_impl );
    const_str_plain_x_isnan = UNSTREAM_STRING( &constant_bin[ 1799830 ], 7, 1 );
    const_str_plain_assert_warns = UNSTREAM_STRING( &constant_bin[ 1796598 ], 12, 1 );
    const_str_plain_Process = UNSTREAM_STRING( &constant_bin[ 92928 ], 7, 1 );
    const_str_plain_DESIRED = UNSTREAM_STRING( &constant_bin[ 1792146 ], 7, 1 );
    const_str_digest_794995e7a92670372eca23dc277265d0 = UNSTREAM_STRING( &constant_bin[ 1799982 ], 21, 0 );
    const_str_plain_format_exc = UNSTREAM_STRING( &constant_bin[ 50031 ], 10, 1 );
    const_long_neg_9223372036854775808 = UNSTREAM_CONSTANT( &constant_bin[ 1800003 ], 13 );
    const_str_digest_f17ec8fa29d8c2f383bd2b681e08c700 = UNSTREAM_STRING( &constant_bin[ 1800016 ], 39, 0 );
    const_str_plain__showwarning = UNSTREAM_STRING( &constant_bin[ 1800055 ], 12, 1 );
    const_str_digest_77842bb9b08e5dafb20eb78d1603a7b5 = UNSTREAM_STRING( &constant_bin[ 1800067 ], 737, 0 );
    const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple = PyTuple_New( 14 );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    const_str_plain_xinfid = UNSTREAM_STRING( &constant_bin[ 1800804 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 2, const_str_plain_xinfid ); Py_INCREF( const_str_plain_xinfid );
    const_str_plain_yinfid = UNSTREAM_STRING( &constant_bin[ 1800810 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 3, const_str_plain_yinfid ); Py_INCREF( const_str_plain_yinfid );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 4, const_str_plain_dtype ); Py_INCREF( const_str_plain_dtype );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 5, const_str_plain_z ); Py_INCREF( const_str_plain_z );
    const_str_plain_npany = UNSTREAM_STRING( &constant_bin[ 1800816 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 6, const_str_plain_npany ); Py_INCREF( const_str_plain_npany );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 7, const_str_plain_result_type ); Py_INCREF( const_str_plain_result_type );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 8, const_str_plain_array ); Py_INCREF( const_str_plain_array );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 9, const_str_plain_issubdtype ); Py_INCREF( const_str_plain_issubdtype );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 10, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 11, const_str_plain_float_ ); Py_INCREF( const_str_plain_float_ );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 12, const_str_plain_around ); Py_INCREF( const_str_plain_around );
    PyTuple_SET_ITEM( const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 13, const_str_plain_decimal ); Py_INCREF( const_str_plain_decimal );
    const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, 0, const_str_plain_ndarray ); Py_INCREF( const_str_plain_ndarray );
    PyTuple_SET_ITEM( const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, 1, const_str_plain_isscalar ); Py_INCREF( const_str_plain_isscalar );
    PyTuple_SET_ITEM( const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, 2, const_str_plain_signbit ); Py_INCREF( const_str_plain_signbit );
    const_tuple_str_plain_mkdtemp_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_mkdtemp_tuple, 0, const_str_plain_mkdtemp ); Py_INCREF( const_str_plain_mkdtemp );
    const_str_digest_dc6af44bedb1bd2ed8631e928612f8de = UNSTREAM_STRING( &constant_bin[ 1800821 ], 53, 0 );
    const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 0, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 1, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 2, const_str_plain_rtol ); Py_INCREF( const_str_plain_rtol );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 3, const_str_plain_atol ); Py_INCREF( const_str_plain_atol );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 4, const_str_plain_equal_nan ); Py_INCREF( const_str_plain_equal_nan );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 5, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 6, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 7, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 8, const_str_plain_compare ); Py_INCREF( const_str_plain_compare );
    PyTuple_SET_ITEM( const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 9, const_str_plain_header ); Py_INCREF( const_str_plain_header );
    const_tuple_67cbd1c28cbabbc57077461585c71131_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, 0, const_str_plain_float32 ); Py_INCREF( const_str_plain_float32 );
    PyTuple_SET_ITEM( const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, 1, const_str_plain_empty ); Py_INCREF( const_str_plain_empty );
    PyTuple_SET_ITEM( const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, 2, const_str_plain_arange ); Py_INCREF( const_str_plain_arange );
    PyTuple_SET_ITEM( const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, 3, const_str_plain_array_repr ); Py_INCREF( const_str_plain_array_repr );
    PyTuple_SET_ITEM( const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, 4, const_str_plain_ndarray ); Py_INCREF( const_str_plain_ndarray );
    const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 0, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 1, const_str_plain_category ); Py_INCREF( const_str_plain_category );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 2, const_str_plain_filename ); Py_INCREF( const_str_plain_filename );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 3, const_str_plain_lineno ); Py_INCREF( const_str_plain_lineno );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 4, const_str_plain_file ); Py_INCREF( const_str_plain_file );
    PyTuple_SET_ITEM( const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple, 5, const_str_plain_line ); Py_INCREF( const_str_plain_line );
    const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple, 1, const_str_plain_isinf ); Py_INCREF( const_str_plain_isinf );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple, 2, const_str_plain_errstate ); Py_INCREF( const_str_plain_errstate );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple, 3, const_str_plain_st ); Py_INCREF( const_str_plain_st );
    const_str_plain_y_isnan = UNSTREAM_STRING( &constant_bin[ 1799842 ], 7, 1 );
    const_str_digest_bfe64da05de8ea9d3dc43fbc0c1219dc = UNSTREAM_STRING( &constant_bin[ 1800874 ], 232, 0 );
    const_tuple_int_pos_100_int_pos_100_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_int_pos_100_int_pos_100_tuple, 0, const_int_pos_100 ); Py_INCREF( const_int_pos_100 );
    PyTuple_SET_ITEM( const_tuple_int_pos_100_int_pos_100_tuple, 1, const_int_pos_100 ); Py_INCREF( const_int_pos_100 );
    const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple, 1, const_str_plain_vdt ); Py_INCREF( const_str_plain_vdt );
    const_str_plain_comp = UNSTREAM_STRING( &constant_bin[ 5631 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple, 2, const_str_plain_comp ); Py_INCREF( const_str_plain_comp );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple, 3, const_str_plain_rx ); Py_INCREF( const_str_plain_rx );
    const_str_plain_IgnoreException = UNSTREAM_STRING( &constant_bin[ 1796658 ], 15, 1 );
    const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 0, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 1, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 2, const_str_plain_significant ); Py_INCREF( const_str_plain_significant );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 3, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 4, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 5, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 6, const_str_plain_scale ); Py_INCREF( const_str_plain_scale );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 7, const_str_plain_sc_desired ); Py_INCREF( const_str_plain_sc_desired );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 8, const_str_plain_sc_actual ); Py_INCREF( const_str_plain_sc_actual );
    PyTuple_SET_ITEM( const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 9, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_digest_93bdfe3c415d4fa99cb2dd3e286cd6d4 = UNSTREAM_STRING( &constant_bin[ 1801106 ], 680, 0 );
    const_str_digest_456ba859d4899c52c81b368fddf2b93e = UNSTREAM_STRING( &constant_bin[ 1801786 ], 1877, 0 );
    const_tuple_str_plain_nan_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_nan_tuple, 0, const_str_plain_nan ); Py_INCREF( const_str_plain_nan );
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple, 1, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple, 2, const_str_plain_log ); Py_INCREF( const_str_plain_log );
    const_str_plain_gisinf = UNSTREAM_STRING( &constant_bin[ 1803663 ], 6, 1 );
    const_str_plain_measure = UNSTREAM_STRING( &constant_bin[ 444172 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple, 1, const_str_plain_log ); Py_INCREF( const_str_plain_log );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple, 2, const_str_plain_showwarning ); Py_INCREF( const_str_plain_showwarning );
    const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple, 0, const_str_digest_d240ce9b96be4e59a73232989ed6258b ); Py_INCREF( const_str_digest_d240ce9b96be4e59a73232989ed6258b );
    PyTuple_SET_ITEM( const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple, 1, Py_True ); Py_INCREF( Py_True );
    const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple = PyTuple_New( 2 );
    const_str_plain_ACTUAL = UNSTREAM_STRING( &constant_bin[ 1782213 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple, 0, const_str_plain_ACTUAL ); Py_INCREF( const_str_plain_ACTUAL );
    PyTuple_SET_ITEM( const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple, 1, const_str_plain_DESIRED ); Py_INCREF( const_str_plain_DESIRED );
    PyTuple_SET_ITEM( const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple, 2, const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple ); Py_INCREF( const_tuple_str_plain_ACTUAL_str_plain_DESIRED_tuple );
    PyTuple_SET_ITEM( const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple, 3, const_int_pos_8 ); Py_INCREF( const_int_pos_8 );
    const_tuple_5eda0b27f24d46759a2212549f83add5_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 0, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    PyTuple_SET_ITEM( const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 2, const_str_plain_kw ); Py_INCREF( const_str_plain_kw );
    PyTuple_SET_ITEM( const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 3, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 4, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_str_plain_test_string = UNSTREAM_STRING( &constant_bin[ 4483 ], 11, 1 );
    const_str_plain_assert_raises_regex_impl = UNSTREAM_STRING( &constant_bin[ 1803669 ], 24, 1 );
    const_str_digest_e730e08a5048288138d6a29cf19c1970 = UNSTREAM_STRING( &constant_bin[ 1803693 ], 20, 0 );
    const_str_digest_81dc02c5320ca87464caf6ab2dc34793 = UNSTREAM_STRING( &constant_bin[ 1803713 ], 2042, 0 );
    const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 0, const_str_plain_code_str ); Py_INCREF( const_str_plain_code_str );
    const_str_plain_times = UNSTREAM_STRING( &constant_bin[ 1139 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 1, const_str_plain_times ); Py_INCREF( const_str_plain_times );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 2, const_str_plain_label ); Py_INCREF( const_str_plain_label );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 3, const_str_plain_frame ); Py_INCREF( const_str_plain_frame );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 4, const_str_plain_locs ); Py_INCREF( const_str_plain_locs );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 5, const_str_plain_globs ); Py_INCREF( const_str_plain_globs );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 6, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_elapsed = UNSTREAM_STRING( &constant_bin[ 1789422 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 8, const_str_plain_elapsed ); Py_INCREF( const_str_plain_elapsed );
    const_str_digest_265f4d1ed58984854390f83322ffa237 = UNSTREAM_STRING( &constant_bin[ 1805755 ], 43, 0 );
    const_str_plain_GetFormattedCounterValue = UNSTREAM_STRING( &constant_bin[ 1805798 ], 24, 1 );
    const_str_digest_7ac790b77fb2e800593801101da6838e = UNSTREAM_STRING( &constant_bin[ 1805822 ], 14, 0 );
    const_str_plain_aliased = UNSTREAM_STRING( &constant_bin[ 1805836 ], 7, 1 );
    const_str_plain_getrefcount = UNSTREAM_STRING( &constant_bin[ 1805843 ], 11, 1 );
    const_str_digest_e4fd0081f7638fce2542d5bc15151444 = UNSTREAM_STRING( &constant_bin[ 1805854 ], 36, 0 );
    const_str_digest_4768c214d294535d1b934026c8fbb084 = UNSTREAM_STRING( &constant_bin[ 1805890 ], 25, 0 );
    const_str_plain_efmt = UNSTREAM_STRING( &constant_bin[ 1799940 ], 4, 1 );
    const_tuple_565527652c835353ad2b809796ba3ff4_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 2, const_str_plain_dtype ); Py_INCREF( const_str_plain_dtype );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 3, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 4, const_str_plain_t ); Py_INCREF( const_str_plain_t );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 5, const_str_plain__diff ); Py_INCREF( const_str_plain__diff );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 6, const_str_plain_rx ); Py_INCREF( const_str_plain_rx );
    PyTuple_SET_ITEM( const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 7, const_str_plain_ry ); Py_INCREF( const_str_plain_ry );
    const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 1, const_str_plain_random ); Py_INCREF( const_str_plain_random );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 2, const_str_plain_zeros ); Py_INCREF( const_str_plain_zeros );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 3, const_str_plain_float64 ); Py_INCREF( const_str_plain_float64 );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 4, const_str_plain_results ); Py_INCREF( const_str_plain_results );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 5, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 6, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain__filters = UNSTREAM_STRING( &constant_bin[ 1805915 ], 8, 1 );
    const_str_digest_1f4842fd9edf1f66aa4685a11b6b5629 = UNSTREAM_STRING( &constant_bin[ 1805923 ], 45, 0 );
    const_str_plain_exc_name = UNSTREAM_STRING( &constant_bin[ 1805968 ], 8, 1 );
    const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple, 1, const_str_plain_isnan ); Py_INCREF( const_str_plain_isnan );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple, 2, const_str_plain_st ); Py_INCREF( const_str_plain_st );
    const_str_digest_a4d91958b6481ca3e50f61fc19ae9d9b = UNSTREAM_STRING( &constant_bin[ 1805976 ], 931, 0 );
    const_str_digest_1b1287ebb1d4b1f4e8307f127391cdb6 = UNSTREAM_STRING( &constant_bin[ 1806907 ], 9, 0 );
    const_str_digest_9070b22dec0007c1ed173e33a0aa0267 = UNSTREAM_STRING( &constant_bin[ 1806916 ], 693, 0 );
    const_str_digest_26a84684c8f1d9eaff79f73dc42d465f = UNSTREAM_STRING( &constant_bin[ 1805755 ], 31, 0 );
    const_str_digest_f3aa1440a461949e616dcc68ee318c24 = UNSTREAM_STRING( &constant_bin[ 1807609 ], 1629, 0 );
    const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 1, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 2, const_str_plain_category ); Py_INCREF( const_str_plain_category );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 3, const_str_plain_filename ); Py_INCREF( const_str_plain_filename );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 4, const_str_plain_lineno ); Py_INCREF( const_str_plain_lineno );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 5, const_str_plain_file ); Py_INCREF( const_str_plain_file );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 6, const_str_plain_line ); Py_INCREF( const_str_plain_line );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 7, const_str_plain_local_values ); Py_INCREF( const_str_plain_local_values );
    PyTuple_SET_ITEM( const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 8, const_str_plain_attr ); Py_INCREF( const_str_plain_attr );
    const_tuple_str_plain_x_str_plain_np_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_np_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_np_tuple, 1, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 0, const_str_plain_array ); Py_INCREF( const_str_plain_array );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 1, const_str_plain_isnan ); Py_INCREF( const_str_plain_isnan );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 2, const_str_plain_isinf ); Py_INCREF( const_str_plain_isinf );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 3, const_str_plain_any ); Py_INCREF( const_str_plain_any );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 4, const_str_plain_all ); Py_INCREF( const_str_plain_all );
    PyTuple_SET_ITEM( const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, 5, const_str_plain_inf ); Py_INCREF( const_str_plain_inf );
    const_str_digest_c73eac2486e2c9ab7692c43bd0d41203 = UNSTREAM_STRING( &constant_bin[ 1809238 ], 385, 0 );
    const_str_digest_91ae8b8c54cb3ed81a3eec57351d8df9 = UNSTREAM_STRING( &constant_bin[ 1809623 ], 9, 0 );
    const_str_plain_decorator = UNSTREAM_STRING( &constant_bin[ 129385 ], 9, 1 );
    const_tuple_23579b8f33cf06464b97783a718253a4_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 2, const_str_plain_nulp ); Py_INCREF( const_str_plain_nulp );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 3, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 4, const_str_plain_ax ); Py_INCREF( const_str_plain_ax );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 5, const_str_plain_ay ); Py_INCREF( const_str_plain_ay );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 6, const_str_plain_ref ); Py_INCREF( const_str_plain_ref );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 7, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_plain_max_nulp = UNSTREAM_STRING( &constant_bin[ 1809632 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 8, const_str_plain_max_nulp ); Py_INCREF( const_str_plain_max_nulp );
    const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 0, const_str_plain_cls ); Py_INCREF( const_str_plain_cls );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 1, const_str_plain_decorator ); Py_INCREF( const_str_plain_decorator );
    const_str_plain_testmatch = UNSTREAM_STRING( &constant_bin[ 19706 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 2, const_str_plain_testmatch ); Py_INCREF( const_str_plain_testmatch );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 3, const_str_plain_cls_attr ); Py_INCREF( const_str_plain_cls_attr );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 4, const_str_plain_isfunction ); Py_INCREF( const_str_plain_isfunction );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 5, const_str_plain__m ); Py_INCREF( const_str_plain__m );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 6, const_str_plain_methods ); Py_INCREF( const_str_plain_methods );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 7, const_str_plain_function ); Py_INCREF( const_str_plain_function );
    PyTuple_SET_ITEM( const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 8, const_str_plain_funcname ); Py_INCREF( const_str_plain_funcname );
    const_tuple_false_tuple_empty_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_false_tuple_empty_tuple, 0, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_false_tuple_empty_tuple, 1, const_tuple_empty ); Py_INCREF( const_tuple_empty );
    const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple, 1, const_str_plain_expected ); Py_INCREF( const_str_plain_expected );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple, 2, const_str_plain_expected_regexp ); Py_INCREF( const_str_plain_expected_regexp );
    const_str_plain_assert_array_almost_equal = UNSTREAM_STRING( &constant_bin[ 1783345 ], 25, 1 );
    const_str_plain_assert_array_almost_equal_nulp = UNSTREAM_STRING( &constant_bin[ 1783345 ], 30, 1 );
    const_str_plain_assert_allclose = UNSTREAM_STRING( &constant_bin[ 1787110 ], 15, 1 );
    const_str_plain_assert_raises_regex = UNSTREAM_STRING( &constant_bin[ 1790256 ], 19, 1 );
    const_str_digest_33b666deea9552cec7dcfd3e4a99577a = UNSTREAM_STRING( &constant_bin[ 1809640 ], 780, 0 );
    const_str_digest_34e2f0683aaa71a2e4c98472a81cd441 = UNSTREAM_STRING( &constant_bin[ 1810420 ], 40, 0 );
    const_str_plain_contextmanager = UNSTREAM_STRING( &constant_bin[ 1810460 ], 14, 1 );
    const_tuple_ed821113c19ffc8f967f602208d037c4_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 2, const_str_plain_decimal ); Py_INCREF( const_str_plain_decimal );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 3, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 4, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 5, const_str_plain_around ); Py_INCREF( const_str_plain_around );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 6, const_str_plain_number ); Py_INCREF( const_str_plain_number );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 7, const_str_plain_float_ ); Py_INCREF( const_str_plain_float_ );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 8, const_str_plain_result_type ); Py_INCREF( const_str_plain_result_type );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 9, const_str_plain_array ); Py_INCREF( const_str_plain_array );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 10, const_str_plain_issubdtype ); Py_INCREF( const_str_plain_issubdtype );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 11, const_str_plain_npany ); Py_INCREF( const_str_plain_npany );
    PyTuple_SET_ITEM( const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 12, const_str_plain_compare ); Py_INCREF( const_str_plain_compare );
    const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 0, const_str_plain_x_id ); Py_INCREF( const_str_plain_x_id );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 1, const_str_plain_y_id ); Py_INCREF( const_str_plain_y_id );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 2, const_str_plain_hasval ); Py_INCREF( const_str_plain_hasval );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 3, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 4, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 5, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 6, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 7, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 8, const_str_plain_header ); Py_INCREF( const_str_plain_header );
    PyTuple_SET_ITEM( const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 9, const_str_plain_precision ); Py_INCREF( const_str_plain_precision );
    const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple = PyTuple_New( 12 );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 0, const_str_plain_object ); Py_INCREF( const_str_plain_object );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 1, const_str_plain_counter ); Py_INCREF( const_str_plain_counter );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 2, const_str_plain_instance ); Py_INCREF( const_str_plain_instance );
    const_str_plain_inum = UNSTREAM_STRING( &constant_bin[ 1810474 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 3, const_str_plain_inum ); Py_INCREF( const_str_plain_inum );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 4, const_str_plain_format ); Py_INCREF( const_str_plain_format );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 5, const_str_plain_machine ); Py_INCREF( const_str_plain_machine );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 6, const_str_plain_win32pdh ); Py_INCREF( const_str_plain_win32pdh );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 7, const_str_plain_path ); Py_INCREF( const_str_plain_path );
    const_str_plain_hq = UNSTREAM_STRING( &constant_bin[ 701780 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 8, const_str_plain_hq ); Py_INCREF( const_str_plain_hq );
    const_str_plain_hc = UNSTREAM_STRING( &constant_bin[ 141452 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 9, const_str_plain_hc ); Py_INCREF( const_str_plain_hc );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 10, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 11, const_str_plain_val ); Py_INCREF( const_str_plain_val );
    const_tuple_long_neg_2147483648_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_long_neg_2147483648_tuple, 0, const_long_neg_2147483648 ); Py_INCREF( const_long_neg_2147483648 );
    const_tuple_int_pos_6_str_empty_true_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_int_pos_6_str_empty_true_tuple, 0, const_int_pos_6 ); Py_INCREF( const_int_pos_6 );
    PyTuple_SET_ITEM( const_tuple_int_pos_6_str_empty_true_tuple, 1, const_str_empty ); Py_INCREF( const_str_empty );
    PyTuple_SET_ITEM( const_tuple_int_pos_6_str_empty_true_tuple, 2, Py_True ); Py_INCREF( Py_True );
    const_tuple_49c70cfa143642b7953372e431b26b96_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 0, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 1, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 2, const_str_plain_difflib ); Py_INCREF( const_str_plain_difflib );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 3, const_str_plain_diff ); Py_INCREF( const_str_plain_diff );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 4, const_str_plain_diff_list ); Py_INCREF( const_str_plain_diff_list );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 5, const_str_plain_d1 ); Py_INCREF( const_str_plain_d1 );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 6, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 7, const_str_plain_d2 ); Py_INCREF( const_str_plain_d2 );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 8, const_str_plain_d3 ); Py_INCREF( const_str_plain_d3 );
    PyTuple_SET_ITEM( const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 9, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_digest_927431f33ccd0218ef72e4d9f521f626 = UNSTREAM_STRING( &constant_bin[ 1810478 ], 39, 0 );
    const_str_plain_RemoveCounter = UNSTREAM_STRING( &constant_bin[ 1810517 ], 13, 1 );
    const_str_plain_inp2 = UNSTREAM_STRING( &constant_bin[ 1810530 ], 4, 1 );
    const_tuple_str_plain_isinf_str_plain_errstate_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_isinf_str_plain_errstate_tuple, 0, const_str_plain_isinf ); Py_INCREF( const_str_plain_isinf );
    PyTuple_SET_ITEM( const_tuple_str_plain_isinf_str_plain_errstate_tuple, 1, const_str_plain_errstate ); Py_INCREF( const_str_plain_errstate );
    const_str_plain_isdesnan = UNSTREAM_STRING( &constant_bin[ 1810534 ], 8, 1 );
    const_tuple_944de8a92e09905a5d1b64e02c8558ea_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 1810542 ], 235 );
    const_str_digest_f4e00ed389370710d6e3415961014f9a = UNSTREAM_STRING( &constant_bin[ 1810777 ], 75, 0 );
    const_dict_568ac7eccabc8d891d945f2840f427e7 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_568ac7eccabc8d891d945f2840f427e7, const_str_plain_hasval, const_str_plain_nan );
    assert( PyDict_Size( const_dict_568ac7eccabc8d891d945f2840f427e7 ) == 1 );
    const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple = PyTuple_New( 15 );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 0, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 1, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 2, const_str_plain_decimal ); Py_INCREF( const_str_plain_decimal );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 3, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 4, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 5, const_str_plain_ndarray ); Py_INCREF( const_str_plain_ndarray );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 6, const_str_plain_iscomplexobj ); Py_INCREF( const_str_plain_iscomplexobj );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 7, const_str_plain_real ); Py_INCREF( const_str_plain_real );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 8, const_str_plain_imag ); Py_INCREF( const_str_plain_imag );
    const_str_plain_usecomplex = UNSTREAM_STRING( &constant_bin[ 1810691 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 9, const_str_plain_usecomplex ); Py_INCREF( const_str_plain_usecomplex );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 10, const_str_plain__build_err_msg ); Py_INCREF( const_str_plain__build_err_msg );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 11, const_str_plain_actualr ); Py_INCREF( const_str_plain_actualr );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 12, const_str_plain_actuali ); Py_INCREF( const_str_plain_actuali );
    const_str_plain_desiredr = UNSTREAM_STRING( &constant_bin[ 1810730 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 13, const_str_plain_desiredr ); Py_INCREF( const_str_plain_desiredr );
    const_str_plain_desiredi = UNSTREAM_STRING( &constant_bin[ 1810743 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 14, const_str_plain_desiredi ); Py_INCREF( const_str_plain_desiredi );
    const_str_digest_9080e25adf8a6e98de54bc174ec4ddea = UNSTREAM_STRING( &constant_bin[ 21101 ], 8, 0 );
    const_str_digest_6880cd150b36fa901d13829084b91966 = UNSTREAM_STRING( &constant_bin[ 1810852 ], 144, 0 );
    const_tuple_long_neg_9223372036854775808_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_long_neg_9223372036854775808_tuple, 0, const_long_neg_9223372036854775808 ); Py_INCREF( const_long_neg_9223372036854775808 );
    const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 0, const_str_plain_a ); Py_INCREF( const_str_plain_a );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 1, const_str_plain_b ); Py_INCREF( const_str_plain_b );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 2, const_str_plain_maxulp ); Py_INCREF( const_str_plain_maxulp );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 3, const_str_plain_dtype ); Py_INCREF( const_str_plain_dtype );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 4, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 5, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    const_str_digest_70e70eb6e19e3ba7a8df4bc2c8ec15e1 = UNSTREAM_STRING( &constant_bin[ 1810996 ], 865, 0 );
    const_str_plain_y_isinf = UNSTREAM_STRING( &constant_bin[ 1799866 ], 7, 1 );
    const_tuple_str_plain_python_int_0_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_python_int_0_tuple, 0, const_str_plain_python ); Py_INCREF( const_str_plain_python );
    PyTuple_SET_ITEM( const_tuple_str_plain_python_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_assert_equal = UNSTREAM_STRING( &constant_bin[ 1787299 ], 12, 1 );
    const_str_plain_integer_repr = UNSTREAM_STRING( &constant_bin[ 1796111 ], 12, 1 );
    const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple, 0, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple, 1, const_str_plain_kwargs ); Py_INCREF( const_str_plain_kwargs );
    PyTuple_SET_ITEM( const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple, 2, const_str_plain_nose ); Py_INCREF( const_str_plain_nose );
    const_str_digest_1640eb8691b27b74c67f931efa0239c2 = UNSTREAM_STRING( &constant_bin[ 1811861 ], 25, 0 );
    const_str_digest_4dca8d1d7b81245cb563f97f4156f581 = UNSTREAM_STRING( &constant_bin[ 1811886 ], 33, 0 );
    const_str_digest_10bbed5c16f2cf6e80902c569bddb5f4 = UNSTREAM_STRING( &constant_bin[ 1811919 ], 24, 0 );
    const_tuple_str_digest_a3a2dd55b816c9490fff0582d282bf95_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_a3a2dd55b816c9490fff0582d282bf95_tuple, 0, const_str_digest_a3a2dd55b816c9490fff0582d282bf95 ); Py_INCREF( const_str_digest_a3a2dd55b816c9490fff0582d282bf95 );
    const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple, 0, const_str_plain_val ); Py_INCREF( const_str_plain_val );
    PyTuple_SET_ITEM( const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple, 1, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple, 2, const_str_plain_smsg ); Py_INCREF( const_str_plain_smsg );
    const_str_plain_MakeCounterPath = UNSTREAM_STRING( &constant_bin[ 1811943 ], 15, 1 );
    const_str_digest_65b92a364d9686732f28856d1578c69f = UNSTREAM_STRING( &constant_bin[ 1811958 ], 40, 0 );
    const_str_plain__category_name = UNSTREAM_STRING( &constant_bin[ 1811998 ], 14, 1 );
    const_str_digest_8159168790756c2f5fb8ca65599559de = UNSTREAM_STRING( &constant_bin[ 1812012 ], 9, 0 );
    const_tuple_501a23729e7545fd650e3d9d37994226_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 0, const_str_plain__proc_pid_stat ); Py_INCREF( const_str_plain__proc_pid_stat );
    PyTuple_SET_ITEM( const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 1, const_str_plain__load_time ); Py_INCREF( const_str_plain__load_time );
    PyTuple_SET_ITEM( const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 2, const_str_plain_time ); Py_INCREF( const_str_plain_time );
    PyTuple_SET_ITEM( const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 3, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 4, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain_filters = UNSTREAM_STRING( &constant_bin[ 1805916 ], 7, 1 );
    const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 1, const_str_plain_y ); Py_INCREF( const_str_plain_y );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 2, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 3, const_str_plain_rtol ); Py_INCREF( const_str_plain_rtol );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 4, const_str_plain_atol ); Py_INCREF( const_str_plain_atol );
    PyTuple_SET_ITEM( const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 5, const_str_plain_equal_nan ); Py_INCREF( const_str_plain_equal_nan );
    const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 1, const_str_plain_exc_type ); Py_INCREF( const_str_plain_exc_type );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 2, const_str_plain_exc_value ); Py_INCREF( const_str_plain_exc_value );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 3, const_str_plain_tb ); Py_INCREF( const_str_plain_tb );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 4, const_str_plain_exc_name ); Py_INCREF( const_str_plain_exc_name );
    PyTuple_SET_ITEM( const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 5, const_str_plain_expected_regexp ); Py_INCREF( const_str_plain_expected_regexp );
    const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 0, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 1, const_str_plain_dtype ); Py_INCREF( const_str_plain_dtype );
    PyTuple_SET_ITEM( const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 2, const_str_plain_o ); Py_INCREF( const_str_plain_o );
    const_str_plain_inp1 = UNSTREAM_STRING( &constant_bin[ 1812021 ], 4, 1 );
    const_str_plain_assert_array_less = UNSTREAM_STRING( &constant_bin[ 1791431 ], 17, 1 );
    const_tuple_09dcbffd359d480fc172eae968ca9191_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 0, const_str_plain_arrays ); Py_INCREF( const_str_plain_arrays );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 1, const_str_plain_err_msg ); Py_INCREF( const_str_plain_err_msg );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 2, const_str_plain_header ); Py_INCREF( const_str_plain_header );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 3, const_str_plain_verbose ); Py_INCREF( const_str_plain_verbose );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 4, const_str_plain_names ); Py_INCREF( const_str_plain_names );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 5, const_str_plain_precision ); Py_INCREF( const_str_plain_precision );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 6, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 8, const_str_plain_a ); Py_INCREF( const_str_plain_a );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 9, const_str_plain_r_func ); Py_INCREF( const_str_plain_r_func );
    PyTuple_SET_ITEM( const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 10, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    const_str_digest_01f1c58babb9e9d1a30d908b35924c3d = UNSTREAM_STRING( &constant_bin[ 1812025 ], 13, 0 );
    const_str_plain_AddCounter = UNSTREAM_STRING( &constant_bin[ 1812038 ], 10, 1 );
    const_str_digest_91d13b44af9a5a13a2155d933ca121b5 = UNSTREAM_STRING( &constant_bin[ 1812048 ], 13, 0 );
    const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple, 0, const_str_plain__proc_pid_stat ); Py_INCREF( const_str_plain__proc_pid_stat );
    PyTuple_SET_ITEM( const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple, 1, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_digest_8b83d5866bfb89b1d61fc7b4d1c462b2 = UNSTREAM_STRING( &constant_bin[ 1812061 ], 77, 0 );
    const_str_plain_contextlib = UNSTREAM_STRING( &constant_bin[ 1812138 ], 10, 1 );
    const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 0, const_str_plain_test_string ); Py_INCREF( const_str_plain_test_string );
    PyTuple_SET_ITEM( const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 1, const_str_plain_actual ); Py_INCREF( const_str_plain_actual );
    PyTuple_SET_ITEM( const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 2, const_str_plain_desired ); Py_INCREF( const_str_plain_desired );
    PyTuple_SET_ITEM( const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 3, const_str_plain_pprint ); Py_INCREF( const_str_plain_pprint );
    PyTuple_SET_ITEM( const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 4, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    const_str_digest_43e8d9e479afe33589f6c45c6a84edf4 = UNSTREAM_STRING( &constant_bin[ 1812148 ], 13, 0 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_numpy$testing$utils( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_89a43f46680c3f0d4ec63f81244a810a;
static PyCodeObject *codeobj_9906050be76d57fd965f5de66a14598d;
static PyCodeObject *codeobj_5232c97b289a40c836390c2babeee349;
static PyCodeObject *codeobj_7487d2f1e13229893d72b28b1203255b;
static PyCodeObject *codeobj_7b878763c93d266c7fcdc81b053a237f;
static PyCodeObject *codeobj_34b823b74bf81bac3faa20ccc6baf903;
static PyCodeObject *codeobj_129f616448917821adcf6ec6720fa727;
static PyCodeObject *codeobj_c8ab0713973ccc44e3ab70252cc07fb1;
static PyCodeObject *codeobj_22425dfac68b1934190c6706cc5558bf;
static PyCodeObject *codeobj_85689a2364b31f10b51f5a64448c6719;
static PyCodeObject *codeobj_98138bf4ed25d13866efd10b9cec44d9;
static PyCodeObject *codeobj_3575a0e9fbc395e93c9cd8a07c227ba5;
static PyCodeObject *codeobj_a6ccce2decf1b651db1c2fa11a115723;
static PyCodeObject *codeobj_9ecb26975b952a181c2d41916c1878f4;
static PyCodeObject *codeobj_affaaf4d719268a18c5a686b7dee4168;
static PyCodeObject *codeobj_5ba100fadd74ce880b2ab679d91f1887;
static PyCodeObject *codeobj_81e84cbbcb43fd608f0de5831954e2fb;
static PyCodeObject *codeobj_526b6bc1518281356090ffa6209cb91d;
static PyCodeObject *codeobj_f46d6f13257c231e287f664132352d97;
static PyCodeObject *codeobj_35df8855789420c66c74432cc8a8fca2;
static PyCodeObject *codeobj_7d0a5268db158ba066fa108948276239;
static PyCodeObject *codeobj_cd5bb3d79c37ce8371d5f35c9ec85905;
static PyCodeObject *codeobj_66e310b6382dcc8bee7ef8f0d5a806e1;
static PyCodeObject *codeobj_edae6eb33a8c360aab01cb7a8ffbe19e;
static PyCodeObject *codeobj_41969be122ed93b49137ea1ebeb38ab0;
static PyCodeObject *codeobj_9fc789f06cba154e0a2541c13da7f923;
static PyCodeObject *codeobj_874200c3ed7fb0f73a4df53e0e9b1954;
static PyCodeObject *codeobj_cf664cdcbe5f723bdc04dbe913ac524e;
static PyCodeObject *codeobj_cf7e4fb007c611d7dea94190d4a66a81;
static PyCodeObject *codeobj_09ef3af3431a4fa1129a67fa2c1de11e;
static PyCodeObject *codeobj_eed94b1bf413990886124f4252687f2e;
static PyCodeObject *codeobj_96500b0fb70eb99b7f6b07ae329a54d6;
static PyCodeObject *codeobj_8838e1559d7858c5c5fc0fb43fdca72b;
static PyCodeObject *codeobj_49a0f05b2207530323b591c3cb8e653e;
static PyCodeObject *codeobj_e4e8dd9562b52d56409fe506920e113b;
static PyCodeObject *codeobj_e67db4e37ff46531ff4ac7fd61eae93a;
static PyCodeObject *codeobj_42d4d08591aaf7b9488da449f1a61731;
static PyCodeObject *codeobj_e21fdf4eeb0bfc5a06db8cfc887f8959;
static PyCodeObject *codeobj_033604a5dde6d855150cecf0e266f33b;
static PyCodeObject *codeobj_e3989f5cbc0c9c5f85a84f34cdc23b4d;
static PyCodeObject *codeobj_1b5e769d1ab43c8483d069aae12da6cf;
static PyCodeObject *codeobj_a31fcecd29c0c1003e04b552a4f105ab;
static PyCodeObject *codeobj_a16362c40d4a926aa17d83f5f9b86aab;
static PyCodeObject *codeobj_983e6316f9929e0f980bcff6d97c595b;
static PyCodeObject *codeobj_b4615d1c987539c7be06569babf9195e;
static PyCodeObject *codeobj_bb2b89f10ff585abc6ba8f01c4c3a9d9;
static PyCodeObject *codeobj_1c0c8ae2b2973eef06c5a77f4c37c5c0;
static PyCodeObject *codeobj_c924695e3d917a7e69c51bff702e46aa;
static PyCodeObject *codeobj_b88dc4f1201a03e15379a75926b9b64d;
static PyCodeObject *codeobj_b8a8c9f2a0a9f64c3d7fa1de07f74944;
static PyCodeObject *codeobj_93f4b121ec830060d3ee45a03e212aaa;
static PyCodeObject *codeobj_3f2b26218a09d13378fbe840b5a42d0d;
static PyCodeObject *codeobj_d121f8f975ce6d236da5714368310521;
static PyCodeObject *codeobj_a0c8eabde612888da6da6c8216f40247;
static PyCodeObject *codeobj_05bc7f151fd8ff6105aec533bff08469;
static PyCodeObject *codeobj_ee2b3ab5579611fe12a028b5b350b0e2;
static PyCodeObject *codeobj_31e6dd57e5e17cef27fc808b38efcb43;
static PyCodeObject *codeobj_620b2341fdcebf2f55d1a9bce92c1454;
static PyCodeObject *codeobj_5cbcc38223452863a1215e2af673137c;
static PyCodeObject *codeobj_cd0d3ab68268b8b182327a55f30686c5;
static PyCodeObject *codeobj_b85bf12bd445c14057852582143d7759;
static PyCodeObject *codeobj_da65c2aed225a04117b73452ab716f1b;
static PyCodeObject *codeobj_4ed8d96b7c558a29e4001b857971058e;
static PyCodeObject *codeobj_12d12328d75fe88aa971be74bf134475;
static PyCodeObject *codeobj_753834d880feddf88ba10a2a5814f57b;
static PyCodeObject *codeobj_bedbec43eef32e147159ef476305f109;
static PyCodeObject *codeobj_85a710849982088049252d2a8b21a1e6;
static PyCodeObject *codeobj_8e85d29cfafad5e08d87eabd867e8ec0;
static PyCodeObject *codeobj_d59398517c300e4bb781b79213b13652;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_dc6af44bedb1bd2ed8631e928612f8de );
    codeobj_89a43f46680c3f0d4ec63f81244a810a = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 1070, const_tuple_str_plain_s_str_plain_msg_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9906050be76d57fd965f5de66a14598d = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 1719, const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5232c97b289a40c836390c2babeee349 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 1732, const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7487d2f1e13229893d72b28b1203255b = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 1733, const_tuple_str_plain_s_str_plain_dtype_str_plain_o_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7b878763c93d266c7fcdc81b053a237f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_GetPerformanceAttributes, 123, const_tuple_0dfa334fafa0cdd681c6614ff859d9a1_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_34b823b74bf81bac3faa20ccc6baf903 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 1141, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_129f616448917821adcf6ec6720fa727 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 1598, const_tuple_str_plain_self_str_plain_log_str_plain_showwarning_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c8ab0713973ccc44e3ab70252cc07fb1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___enter__, 1817, const_tuple_str_plain_self_str_plain_mod_str_plain_mod_reg_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_22425dfac68b1934190c6706cc5558bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 1144, const_tuple_26d6f6e52a91e31d2c254b0b2434156d_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_85689a2364b31f10b51f5a64448c6719 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 1615, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_98138bf4ed25d13866efd10b9cec44d9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___exit__, 1825, const_tuple_str_plain_self_str_plain_exc_info_str_plain_mod_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3575a0e9fbc395e93c9cd8a07c227ba5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1134, const_tuple_str_plain_self_str_plain_expected_str_plain_expected_regexp_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a6ccce2decf1b651db1c2fa11a115723 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1550, const_tuple_22025bc25a02798f8cb5fcbffa9efb3b_tuple, 7, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9ecb26975b952a181c2d41916c1878f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1590, const_tuple_str_plain_self_str_plain_record_str_plain_module_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_affaaf4d719268a18c5a686b7dee4168 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 1812, const_tuple_str_plain_self_str_plain_record_str_plain_modules_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5ba100fadd74ce880b2ab679d91f1887 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___str__, 1560, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_81e84cbbcb43fd608f0de5831954e2fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__assert_valid_refcount, 1275, const_tuple_6d6f1fccb1fef7c39d37f6cc35ce9d43_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_526b6bc1518281356090ffa6209cb91d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__build_err_msg, 468, const_tuple_22011052c50ffffeee9babd5969d09da_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_f46d6f13257c231e287f664132352d97 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__diff, 1498, const_tuple_faacf22dc31885222b083d7ea9c5ba72_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_35df8855789420c66c74432cc8a8fca2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gen_alignment_data, 1689, const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple, 3, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_7d0a5268db158ba066fa108948276239 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gen_alignment_data, 1689, const_tuple_str_plain_dtype_str_plain_type_str_plain_max_size_tuple, 3, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cd5bb3d79c37ce8371d5f35c9ec85905 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__integer_repr, 1506, const_tuple_str_plain_x_str_plain_vdt_str_plain_comp_str_plain_rx_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_66e310b6382dcc8bee7ef8f0d5a806e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_, 37, const_tuple_str_plain_val_str_plain_msg_str_plain_smsg_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_edae6eb33a8c360aab01cb7a8ffbe19e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_allclose, 1293, const_tuple_9f99d4f55ad1cdfc0dd183e2ddd2d2e0_tuple, 7, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_41969be122ed93b49137ea1ebeb38ab0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_almost_equal, 395, const_tuple_24497b7e2181237bc5c3dcf585c99fce_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_9fc789f06cba154e0a2541c13da7f923 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_approx_equal, 513, const_tuple_a0f3948b9b9c78cd8eedbd6f01b94ef1_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_874200c3ed7fb0f73a4df53e0e9b1954 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_almost_equal, 784, const_tuple_ed821113c19ffc8f967f602208d037c4_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cf664cdcbe5f723bdc04dbe913ac524e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_almost_equal_nulp, 1349, const_tuple_23579b8f33cf06464b97783a718253a4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cf7e4fb007c611d7dea94190d4a66a81 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_compare, 609, const_tuple_bb3e481db1dd6ff7a20e545b3e6ed040_tuple, 7, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_09ef3af3431a4fa1129a67fa2c1de11e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_equal, 718, const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_eed94b1bf413990886124f4252687f2e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_less, 889, const_tuple_str_plain_x_str_plain_y_str_plain_err_msg_str_plain_verbose_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_96500b0fb70eb99b7f6b07ae329a54d6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_array_max_ulp, 1410, const_tuple_f0d9b68b47a5d49cf65c29e25eae8b9f_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8838e1559d7858c5c5fc0fb43fdca72b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_equal, 243, const_tuple_944de8a92e09905a5d1b64e02c8558ea_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_49a0f05b2207530323b591c3cb8e653e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_no_warnings, 1660, const_tuple_5eda0b27f24d46759a2212549f83add5_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e4e8dd9562b52d56409fe506920e113b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_raises, 1086, const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e67db4e37ff46531ff4ac7fd61eae93a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_raises_regex, 1105, const_tuple_3a3e3794cdcbe1f8d66d038d185fa51e_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_42d4d08591aaf7b9488da449f1a61731 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_string_equal, 962, const_tuple_49c70cfa143642b7953372e431b26b96_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e21fdf4eeb0bfc5a06db8cfc887f8959 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_assert_warns, 1622, const_tuple_428ef0c7dcad024f447304283fd888c5_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_033604a5dde6d855150cecf0e266f33b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_build_err_msg, 216, const_tuple_09dcbffd359d480fc172eae968ca9191_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_e3989f5cbc0c9c5f85a84f34cdc23b4d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_chk_same_position, 641, const_tuple_256fcd39a52662019fa5bb78724a34d6_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1b5e769d1ab43c8483d069aae12da6cf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compare, 858, const_tuple_70550f20c86fc1a05fa2b26b3978c127_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a31fcecd29c0c1003e04b552a4f105ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_compare, 1340, const_tuple_4fa7ef6bdf10b3722ad2cbbcf50b0a6e_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a16362c40d4a926aa17d83f5f9b86aab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_decorate_methods, 1180, const_tuple_bc4870a37e43080125cbfc56c5c6d0a1_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_983e6316f9929e0f980bcff6d97c595b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_failureException, 1138, const_tuple_str_plain_self_str_plain_msg_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b4615d1c987539c7be06569babf9195e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gisfinite, 72, const_tuple_939737dafb6355bbbcdd58d53fa23ae8_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_bb2b89f10ff585abc6ba8f01c4c3a9d9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gisinf, 90, const_tuple_str_plain_x_str_plain_isinf_str_plain_errstate_str_plain_st_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_1c0c8ae2b2973eef06c5a77f4c37c5c0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_gisnan, 55, const_tuple_str_plain_x_str_plain_isnan_str_plain_st_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_c924695e3d917a7e69c51bff702e46aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_impl, 1168, const_tuple_e5ddf0348a34426aa807fa649bdbcfe1_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b88dc4f1201a03e15379a75926b9b64d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_integer_repr, 1520, const_tuple_str_plain_x_str_plain_np_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b8a8c9f2a0a9f64c3d7fa1de07f74944 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isnumber, 638, const_tuple_str_plain_x_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_93f4b121ec830060d3ee45a03e212aaa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_jiffies, 179, const_tuple_501a23729e7545fd650e3d9d37994226_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_3f2b26218a09d13378fbe840b5a42d0d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_jiffies, 202, const_tuple_str_plain__load_time_str_plain_time_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d121f8f975ce6d236da5714368310521 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_measure, 1227, const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 3, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_a0c8eabde612888da6da6c8216f40247 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_measure, 1227, const_tuple_e5ff69c5c981ae300c528c1b5d2fdef7_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_05bc7f151fd8ff6105aec533bff08469 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_memusage, 149, const_tuple_str_plain_processName_str_plain_instance_str_plain_win32pdh_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_ee2b3ab5579611fe12a028b5b350b0e2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_memusage, 157, const_tuple_str_plain__proc_pid_stat_str_plain_f_str_plain_l_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_31e6dd57e5e17cef27fc808b38efcb43 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_memusage, 170, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_620b2341fdcebf2f55d1a9bce92c1454 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_nulp_diff, 1453, const_tuple_565527652c835353ad2b809796ba3ff4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_5cbcc38223452863a1215e2af673137c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_print_assert_equal, 356, const_tuple_d9c647ca269ce7d9546b6525c8617d06_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_cd0d3ab68268b8b182327a55f30686c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_raises, 1081, const_tuple_str_plain_args_str_plain_kwargs_str_plain_nose_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_b85bf12bd445c14057852582143d7759 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_rand, 108, const_tuple_684cfe7337791d6bf1e3a2597e55be85_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_da65c2aed225a04117b73452ab716f1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_rundocs, 1030, const_tuple_ce0bf5453b1ad206f1366a4802f9fdce_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_4ed8d96b7c558a29e4001b857971058e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_runstring, 959, const_tuple_str_plain_astr_str_plain_dict_tuple, 2, CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_12d12328d75fe88aa971be74bf134475 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_runstring, 959, const_tuple_str_plain_astr_str_plain_dict_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_753834d880feddf88ba10a2a5814f57b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_safe_comparison, 615, const_tuple_str_plain_args_str_plain_kwargs_str_plain_comparison_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_bedbec43eef32e147159ef476305f109 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_showwarning, 1608, const_tuple_str_plain_args_str_plain_kwargs_str_plain_log_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_85a710849982088049252d2a8b21a1e6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_tempdir, 1759, const_tuple_str_plain_args_str_plain_kwargs_tuple, 0, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_8e85d29cfafad5e08d87eabd867e8ec0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_tempdir, 1759, const_tuple_str_plain_args_str_plain_kwargs_tuple, 0, CO_GENERATOR | CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
    codeobj_d59398517c300e4bb781b79213b13652 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_utils, 1, const_tuple_empty, 0, CO_NOFREE | CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | CO_FUTURE_PRINT_FUNCTION );
}

// The module function declarations.
NUITKA_LOCAL_MODULE PyObject *impl_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_class_1_WarningMessage_of_numpy$testing$utils( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_class_2_WarningManager_of_numpy$testing$utils( PyObject **python_pars );


static void genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils_context( Nuitka_GeneratorObject *generator );


NUITKA_LOCAL_MODULE PyObject *impl_class_3_IgnoreException_of_numpy$testing$utils( PyObject **python_pars );


static void genobj_1_tempdir_of_function_39_tempdir_of_numpy$testing$utils_context( Nuitka_GeneratorObject *generator );


NUITKA_LOCAL_MODULE PyObject *impl_class_4_clear_and_catch_warnings_of_numpy$testing$utils( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl_function_5_complex_call_helper_pos_star_list_star_dict_of___internal__( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl_function_6_complex_call_helper_star_list_of___internal__( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_function_10_jiffies_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_11_jiffies_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_12_build_err_msg_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_13_assert_equal_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_14_print_assert_equal_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_15_assert_almost_equal_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_16_assert_approx_equal_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_17_assert_array_compare_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_18_assert_array_equal_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_19_assert_array_almost_equal_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_2_WarningManager_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils( PyCellObject *closure_actual, PyCellObject *closure_decimal, PyCellObject *closure_desired, PyCellObject *closure_err_msg, PyCellObject *closure_verbose );


static PyObject *MAKE_FUNCTION_function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils( PyCellObject *closure_np );


static PyObject *MAKE_FUNCTION_function_1_assert__of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils( PyCellObject *closure_around, PyCellObject *closure_array, PyCellObject *closure_decimal, PyCellObject *closure_float_, PyCellObject *closure_issubdtype, PyCellObject *closure_npany, PyCellObject *closure_number, PyCellObject *closure_result_type );


static PyObject *MAKE_FUNCTION_function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils( PyCellObject *closure_atol, PyCellObject *closure_equal_nan, PyCellObject *closure_np, PyCellObject *closure_rtol );


static PyObject *MAKE_FUNCTION_function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyCellObject *closure__AssertRaisesContext );


static PyObject *MAKE_FUNCTION_function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils( PyCellObject *closure_msg );


static PyObject *MAKE_FUNCTION_function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s );


static PyObject *MAKE_FUNCTION_function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils( PyCellObject *closure_comparison );


static PyObject *MAKE_FUNCTION_function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils( PyCellObject *closure_log );


static PyObject *MAKE_FUNCTION_function_20_assert_array_less_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_21_runstring_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_22_assert_string_equal_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_23_rundocs_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_24_raises_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_25_assert_raises_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_27_decorate_methods_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_28_measure_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_29__assert_valid_refcount_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2_gisnan_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s );


static PyObject *MAKE_FUNCTION_function_30_assert_allclose_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_32_assert_array_max_ulp_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_33_nulp_diff_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_34__integer_repr_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_35_integer_repr_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_36_assert_warns_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_37_assert_no_warnings_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_38__gen_alignment_data_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_39_tempdir_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils( PyObject *defaults, PyCellObject *closure_err_msg, PyCellObject *closure_header, PyCellObject *closure_precision, PyCellObject *closure_verbose, PyCellObject *closure_x, PyCellObject *closure_y );


static PyObject *MAKE_FUNCTION_function_3_gisfinite_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s );


static PyObject *MAKE_FUNCTION_function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_4_gisinf_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_5_rand_of_numpy$testing$utils(  );


static PyObject *MAKE_FUNCTION_function_6_GetPerformanceAttributes_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_7_memusage_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_8_memusage_of_numpy$testing$utils( PyObject *defaults );


static PyObject *MAKE_FUNCTION_function_9_memusage_of_numpy$testing$utils(  );


// The module function definitions.
static PyObject *impl_function_1_assert__of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_val = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *var_smsg = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_66e310b6382dcc8bee7ef8f0d5a806e1, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_cond_value_1 = par_val;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 48;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_called_name_1 = par_msg;

    frame_function->f_lineno = 50;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 50;
        goto try_except_handler_2;
    }
    assert( var_smsg == NULL );
    var_smsg = tmp_assign_source_1;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_TypeError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_2 = par_msg;

    assert( var_smsg == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_smsg = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_assert__of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_make_exception_arg_1 = var_smsg;

    if ( tmp_make_exception_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "smsg" );
        exception_tb = NULL;

        exception_lineno = 53;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 53;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 53;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_val )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_val,
                    par_val
                );

                assert( res == 0 );
            }

            if ( par_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    par_msg
                );

                assert( res == 0 );
            }

            if ( var_smsg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_smsg,
                    var_smsg
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_assert__of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_val );
    Py_DECREF( par_val );
    par_val = NULL;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_val );
    Py_DECREF( par_val );
    par_val = NULL;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    Py_XDECREF( var_smsg );
    var_smsg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_assert__of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2_gisnan_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *var_isnan = NULL;
    PyObject *var_st = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1c0c8ae2b2973eef06c5a77f4c37c5c0, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_st )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_st,
            var_st
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 66;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_isnan_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 66;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_isnan );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 66;
        goto frame_exception_exit_1;
    }
    assert( var_isnan == NULL );
    var_isnan = tmp_assign_source_1;

    tmp_called_name_1 = var_isnan;

    tmp_args_element_name_1 = par_x;

    frame_function->f_lineno = 67;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;
        goto frame_exception_exit_1;
    }
    assert( var_st == NULL );
    var_st = tmp_assign_source_2;

    tmp_isinstance_inst_1 = var_st;

    tmp_isinstance_cls_1 = (PyObject *)Py_TYPE( Py_NotImplemented );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_619d3f0d2ce117f4f715069e9c27f3fb;
    frame_function->f_lineno = 69;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 69;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( var_isnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isnan,
                    var_isnan
                );

                assert( res == 0 );
            }

            if ( var_st )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_st,
                    var_st
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_st;

    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2_gisnan_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_isnan );
    Py_DECREF( var_isnan );
    var_isnan = NULL;

    CHECK_OBJECT( (PyObject *)var_st );
    Py_DECREF( var_st );
    var_st = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_isnan );
    var_isnan = NULL;

    Py_XDECREF( var_st );
    var_st = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2_gisnan_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3_gisfinite_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *var_isfinite = NULL;
    PyObject *var_errstate = NULL;
    PyObject *var_st = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b4615d1c987539c7be06569babf9195e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_isfinite )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isfinite,
            var_isfinite
        );

        assert( res == 0 );
    }

    if ( var_errstate )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_errstate,
            var_errstate
        );

        assert( res == 0 );
    }

    if ( var_st )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_st,
            var_st
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 83;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_isfinite_str_plain_errstate_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 83;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_isfinite );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 83;
        goto frame_exception_exit_1;
    }
    assert( var_isfinite == NULL );
    var_isfinite = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_isfinite )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isfinite,
            var_isfinite
        );

        assert( res == 0 );
    }

    if ( var_errstate )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_errstate,
            var_errstate
        );

        assert( res == 0 );
    }

    if ( var_st )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_st,
            var_st
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 83;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_str_plain_isfinite_str_plain_errstate_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 83;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_errstate );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 83;
        goto frame_exception_exit_1;
    }
    assert( var_errstate == NULL );
    var_errstate = tmp_assign_source_2;

    // Tried code:
    tmp_called_name_1 = var_errstate;

    tmp_kw_name_1 = PyDict_Copy( const_dict_d457aeaf5237c8e9bb82fdcc508844e3 );
    frame_function->f_lineno = 84;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_3;

    tmp_source_name_1 = tmp_with_1__source;

    tmp_assign_source_4 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___exit__ );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_4;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 84;
    tmp_assign_source_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_5;

    tmp_assign_source_6 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_6 );
    tmp_with_1__indicator = tmp_assign_source_6;

    // Tried code:
    // Tried code:
    tmp_called_name_3 = var_isfinite;

    tmp_args_element_name_1 = par_x;

    frame_function->f_lineno = 85;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;
        goto try_except_handler_4;
    }
    assert( var_st == NULL );
    var_st = tmp_assign_source_7;

    tmp_isinstance_inst_1 = var_st;

    tmp_isinstance_cls_1 = (PyObject *)Py_TYPE( Py_NotImplemented );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;
        goto try_except_handler_4;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_e4fd0081f7638fce2542d5bc15151444;
    frame_function->f_lineno = 87;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 87;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_8 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_8;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_4 = tmp_with_1__exit;

    tmp_args_element_name_2 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_3 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_4 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 87;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 87;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 87;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3_gisfinite_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_2 = tmp_with_1__indicator;

    tmp_compare_right_2 = Py_True;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 87;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 87;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_6 = tmp_with_1__exit;

    frame_function->f_lineno = 87;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 87;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = var_st;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "st" );
        exception_tb = NULL;

        exception_lineno = 88;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( var_isfinite )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isfinite,
                    var_isfinite
                );

                assert( res == 0 );
            }

            if ( var_errstate )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_errstate,
                    var_errstate
                );

                assert( res == 0 );
            }

            if ( var_st )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_st,
                    var_st
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3_gisfinite_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_isfinite );
    Py_DECREF( var_isfinite );
    var_isfinite = NULL;

    CHECK_OBJECT( (PyObject *)var_errstate );
    Py_DECREF( var_errstate );
    var_errstate = NULL;

    Py_XDECREF( var_st );
    var_st = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_isfinite );
    var_isfinite = NULL;

    Py_XDECREF( var_errstate );
    var_errstate = NULL;

    Py_XDECREF( var_st );
    var_st = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3_gisfinite_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_4_gisinf_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *var_isinf = NULL;
    PyObject *var_errstate = NULL;
    PyObject *var_st = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bb2b89f10ff585abc6ba8f01c4c3a9d9, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_errstate )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_errstate,
            var_errstate
        );

        assert( res == 0 );
    }

    if ( var_st )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_st,
            var_st
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 101;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_isinf_str_plain_errstate_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_isinf );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        goto frame_exception_exit_1;
    }
    assert( var_isinf == NULL );
    var_isinf = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_errstate )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_errstate,
            var_errstate
        );

        assert( res == 0 );
    }

    if ( var_st )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_st,
            var_st
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 101;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_str_plain_isinf_str_plain_errstate_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_errstate );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 101;
        goto frame_exception_exit_1;
    }
    assert( var_errstate == NULL );
    var_errstate = tmp_assign_source_2;

    // Tried code:
    tmp_called_name_1 = var_errstate;

    tmp_kw_name_1 = PyDict_Copy( const_dict_d457aeaf5237c8e9bb82fdcc508844e3 );
    frame_function->f_lineno = 102;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_3;

    tmp_source_name_1 = tmp_with_1__source;

    tmp_assign_source_4 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___exit__ );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_4;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 102;
    tmp_assign_source_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_5;

    tmp_assign_source_6 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_6 );
    tmp_with_1__indicator = tmp_assign_source_6;

    // Tried code:
    // Tried code:
    tmp_called_name_3 = var_isinf;

    tmp_args_element_name_1 = par_x;

    frame_function->f_lineno = 103;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 103;
        goto try_except_handler_4;
    }
    assert( var_st == NULL );
    var_st = tmp_assign_source_7;

    tmp_isinstance_inst_1 = var_st;

    tmp_isinstance_cls_1 = (PyObject *)Py_TYPE( Py_NotImplemented );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 104;
        goto try_except_handler_4;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_make_exception_arg_1 = const_str_digest_4dca8d1d7b81245cb563f97f4156f581;
    frame_function->f_lineno = 105;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_TypeError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 105;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_8 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_8;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_4 = tmp_with_1__exit;

    tmp_args_element_name_2 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_3 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_4 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 105;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 105;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 105;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_4_gisinf_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_2 = tmp_with_1__indicator;

    tmp_compare_right_2 = Py_True;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 105;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 105;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_6 = tmp_with_1__exit;

    frame_function->f_lineno = 105;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 105;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = var_st;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "st" );
        exception_tb = NULL;

        exception_lineno = 106;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( var_isinf )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isinf,
                    var_isinf
                );

                assert( res == 0 );
            }

            if ( var_errstate )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_errstate,
                    var_errstate
                );

                assert( res == 0 );
            }

            if ( var_st )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_st,
                    var_st
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_4_gisinf_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_isinf );
    Py_DECREF( var_isinf );
    var_isinf = NULL;

    CHECK_OBJECT( (PyObject *)var_errstate );
    Py_DECREF( var_errstate );
    var_errstate = NULL;

    Py_XDECREF( var_st );
    var_st = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_isinf );
    var_isinf = NULL;

    Py_XDECREF( var_errstate );
    var_errstate = NULL;

    Py_XDECREF( var_st );
    var_st = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_4_gisinf_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_5_rand_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *var_random = NULL;
    PyObject *var_zeros = NULL;
    PyObject *var_float64 = NULL;
    PyObject *var_results = NULL;
    PyObject *var_f = NULL;
    PyObject *var_i = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_locals_3;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b85bf12bd445c14057852582143d7759, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_args )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_args,
            par_args
        );

        assert( res == 0 );
    }

    if ( var_random )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_random,
            var_random
        );

        assert( res == 0 );
    }

    if ( var_zeros )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_zeros,
            var_zeros
        );

        assert( res == 0 );
    }

    if ( var_float64 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_float64,
            var_float64
        );

        assert( res == 0 );
    }

    if ( var_results )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_results,
            var_results
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 113;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_random, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 113;
        goto frame_exception_exit_1;
    }
    assert( var_random == NULL );
    var_random = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_args )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_args,
            par_args
        );

        assert( res == 0 );
    }

    if ( var_random )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_random,
            var_random
        );

        assert( res == 0 );
    }

    if ( var_zeros )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_zeros,
            var_zeros
        );

        assert( res == 0 );
    }

    if ( var_float64 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_float64,
            var_float64
        );

        assert( res == 0 );
    }

    if ( var_results )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_results,
            var_results
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 114;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_str_plain_zeros_str_plain_float64_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_zeros );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        goto frame_exception_exit_1;
    }
    assert( var_zeros == NULL );
    var_zeros = tmp_assign_source_2;

    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_3 = PyDict_New();
    if ( par_args )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_args,
            par_args
        );

        assert( res == 0 );
    }

    if ( var_random )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_random,
            var_random
        );

        assert( res == 0 );
    }

    if ( var_zeros )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_zeros,
            var_zeros
        );

        assert( res == 0 );
    }

    if ( var_float64 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_float64,
            var_float64
        );

        assert( res == 0 );
    }

    if ( var_results )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_results,
            var_results
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 114;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_3, tmp_import_locals_3, const_tuple_str_plain_zeros_str_plain_float64_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_3 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_float64 );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        goto frame_exception_exit_1;
    }
    assert( var_float64 == NULL );
    var_float64 = tmp_assign_source_3;

    tmp_called_name_1 = var_zeros;

    tmp_args_element_name_1 = par_args;

    tmp_args_element_name_2 = var_float64;

    frame_function->f_lineno = 115;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 115;
        goto frame_exception_exit_1;
    }
    assert( var_results == NULL );
    var_results = tmp_assign_source_4;

    tmp_source_name_1 = var_results;

    tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_flat );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 116;
        goto frame_exception_exit_1;
    }
    assert( var_f == NULL );
    var_f = tmp_assign_source_5;

    tmp_len_arg_1 = var_f;

    tmp_range_arg_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_6;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_7 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 117;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_assign_source_8 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_8;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_2 = var_random;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_random );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 118;
    tmp_ass_subvalue_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = var_f;

    tmp_ass_subscript_1 = var_i;

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( var_random )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_random,
                    var_random
                );

                assert( res == 0 );
            }

            if ( var_zeros )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_zeros,
                    var_zeros
                );

                assert( res == 0 );
            }

            if ( var_float64 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_float64,
                    var_float64
                );

                assert( res == 0 );
            }

            if ( var_results )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_results,
                    var_results
                );

                assert( res == 0 );
            }

            if ( var_f )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_f,
                    var_f
                );

                assert( res == 0 );
            }

            if ( var_i )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_i,
                    var_i
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_results;

    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_5_rand_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)var_random );
    Py_DECREF( var_random );
    var_random = NULL;

    CHECK_OBJECT( (PyObject *)var_zeros );
    Py_DECREF( var_zeros );
    var_zeros = NULL;

    CHECK_OBJECT( (PyObject *)var_float64 );
    Py_DECREF( var_float64 );
    var_float64 = NULL;

    CHECK_OBJECT( (PyObject *)var_results );
    Py_DECREF( var_results );
    var_results = NULL;

    CHECK_OBJECT( (PyObject *)var_f );
    Py_DECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    Py_XDECREF( var_random );
    var_random = NULL;

    Py_XDECREF( var_zeros );
    var_zeros = NULL;

    Py_XDECREF( var_float64 );
    var_float64 = NULL;

    Py_XDECREF( var_results );
    var_results = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_5_rand_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_6_GetPerformanceAttributes_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_object = python_pars[ 0 ];
    PyObject *par_counter = python_pars[ 1 ];
    PyObject *par_instance = python_pars[ 2 ];
    PyObject *par_inum = python_pars[ 3 ];
    PyObject *par_format = python_pars[ 4 ];
    PyObject *par_machine = python_pars[ 5 ];
    PyObject *var_win32pdh = NULL;
    PyObject *var_path = NULL;
    PyObject *var_hq = NULL;
    PyObject *var_hc = NULL;
    PyObject *var_type = NULL;
    PyObject *var_val = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7b878763c93d266c7fcdc81b053a237f, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_object )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_object,
            par_object
        );

        assert( res == 0 );
    }

    if ( par_counter )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_counter,
            par_counter
        );

        assert( res == 0 );
    }

    if ( par_instance )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_instance,
            par_instance
        );

        assert( res == 0 );
    }

    if ( par_inum )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_inum,
            par_inum
        );

        assert( res == 0 );
    }

    if ( par_format )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_format,
            par_format
        );

        assert( res == 0 );
    }

    if ( par_machine )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_machine,
            par_machine
        );

        assert( res == 0 );
    }

    if ( var_win32pdh )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_win32pdh,
            var_win32pdh
        );

        assert( res == 0 );
    }

    if ( var_path )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_path,
            var_path
        );

        assert( res == 0 );
    }

    if ( var_hq )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_hq,
            var_hq
        );

        assert( res == 0 );
    }

    if ( var_hc )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_hc,
            var_hc
        );

        assert( res == 0 );
    }

    if ( var_type )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_type,
            var_type
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 133;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_win32pdh, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;
        goto frame_exception_exit_1;
    }
    assert( var_win32pdh == NULL );
    var_win32pdh = tmp_assign_source_1;

    tmp_compare_left_1 = par_format;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = var_win32pdh;

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PDH_FMT_LONG );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_format;
        assert( old != NULL );
        par_format = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_source_name_2 = var_win32pdh;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_MakeCounterPath );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 136;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyTuple_New( 6 );
    tmp_tuple_element_1 = par_machine;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_object;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_instance;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 2, tmp_tuple_element_1 );
    tmp_tuple_element_1 = Py_None;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 3, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_inum;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 4, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_counter;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 5, tmp_tuple_element_1 );
    frame_function->f_lineno = 136;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 136;
        goto frame_exception_exit_1;
    }
    assert( var_path == NULL );
    var_path = tmp_assign_source_3;

    tmp_source_name_3 = var_win32pdh;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_OpenQuery );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 137;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 137;
    tmp_assign_source_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 137;
        goto frame_exception_exit_1;
    }
    assert( var_hq == NULL );
    var_hq = tmp_assign_source_4;

    // Tried code:
    tmp_source_name_4 = var_win32pdh;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_AddCounter );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 139;
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = var_hq;

    tmp_args_element_name_3 = var_path;

    frame_function->f_lineno = 139;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 139;
        goto try_except_handler_2;
    }
    assert( var_hc == NULL );
    var_hc = tmp_assign_source_5;

    // Tried code:
    tmp_source_name_5 = var_win32pdh;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_CollectQueryData );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 141;
        goto try_except_handler_3;
    }
    tmp_args_element_name_4 = var_hq;

    frame_function->f_lineno = 141;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 141;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    // Tried code:
    tmp_source_name_6 = var_win32pdh;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_GetFormattedCounterValue );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        goto try_except_handler_4;
    }
    tmp_args_element_name_5 = var_hc;

    tmp_args_element_name_6 = par_format;

    frame_function->f_lineno = 142;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        goto try_except_handler_4;
    }
    tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_6;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 142;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_7;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_8 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 142;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_8;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_4;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_4;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    tmp_assign_source_9 = tmp_tuple_unpack_1__element_1;

    assert( var_type == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_type = tmp_assign_source_9;

    tmp_assign_source_10 = tmp_tuple_unpack_1__element_2;

    assert( var_val == NULL );
    Py_INCREF( tmp_assign_source_10 );
    var_val = tmp_assign_source_10;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_return_value = var_val;

    Py_INCREF( tmp_return_value );
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_6_GetPerformanceAttributes_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    tmp_source_name_7 = var_win32pdh;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_RemoveCounter );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        goto try_except_handler_2;
    }
    tmp_args_element_name_7 = var_hc;

    frame_function->f_lineno = 145;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_source_name_8 = var_win32pdh;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_RemoveCounter );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 145;
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = var_hc;

    frame_function->f_lineno = 145;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 145;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_6_GetPerformanceAttributes_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    tmp_source_name_9 = var_win32pdh;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_CloseQuery );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_hq;

    frame_function->f_lineno = 147;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_source_name_10 = var_win32pdh;

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_CloseQuery );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_3 );
        Py_XDECREF( exception_keeper_value_3 );
        Py_XDECREF( exception_keeper_tb_3 );

        exception_lineno = 147;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_hq;

    frame_function->f_lineno = 147;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_3 );
        Py_XDECREF( exception_keeper_value_3 );
        Py_XDECREF( exception_keeper_tb_3 );

        exception_lineno = 147;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_object )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_object,
                    par_object
                );

                assert( res == 0 );
            }

            if ( par_counter )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_counter,
                    par_counter
                );

                assert( res == 0 );
            }

            if ( par_instance )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_instance,
                    par_instance
                );

                assert( res == 0 );
            }

            if ( par_inum )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_inum,
                    par_inum
                );

                assert( res == 0 );
            }

            if ( par_format )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_format,
                    par_format
                );

                assert( res == 0 );
            }

            if ( par_machine )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_machine,
                    par_machine
                );

                assert( res == 0 );
            }

            if ( var_win32pdh )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_win32pdh,
                    var_win32pdh
                );

                assert( res == 0 );
            }

            if ( var_path )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_path,
                    var_path
                );

                assert( res == 0 );
            }

            if ( var_hq )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_hq,
                    var_hq
                );

                assert( res == 0 );
            }

            if ( var_hc )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_hc,
                    var_hc
                );

                assert( res == 0 );
            }

            if ( var_type )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_type,
                    var_type
                );

                assert( res == 0 );
            }

            if ( var_val )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_val,
                    var_val
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_6_GetPerformanceAttributes_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_object );
    Py_DECREF( par_object );
    par_object = NULL;

    CHECK_OBJECT( (PyObject *)par_counter );
    Py_DECREF( par_counter );
    par_counter = NULL;

    CHECK_OBJECT( (PyObject *)par_instance );
    Py_DECREF( par_instance );
    par_instance = NULL;

    CHECK_OBJECT( (PyObject *)par_inum );
    Py_DECREF( par_inum );
    par_inum = NULL;

    CHECK_OBJECT( (PyObject *)par_format );
    Py_DECREF( par_format );
    par_format = NULL;

    CHECK_OBJECT( (PyObject *)par_machine );
    Py_DECREF( par_machine );
    par_machine = NULL;

    CHECK_OBJECT( (PyObject *)var_win32pdh );
    Py_DECREF( var_win32pdh );
    var_win32pdh = NULL;

    CHECK_OBJECT( (PyObject *)var_path );
    Py_DECREF( var_path );
    var_path = NULL;

    CHECK_OBJECT( (PyObject *)var_hq );
    Py_DECREF( var_hq );
    var_hq = NULL;

    CHECK_OBJECT( (PyObject *)var_hc );
    Py_DECREF( var_hc );
    var_hc = NULL;

    CHECK_OBJECT( (PyObject *)var_type );
    Py_DECREF( var_type );
    var_type = NULL;

    CHECK_OBJECT( (PyObject *)var_val );
    Py_DECREF( var_val );
    var_val = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_object );
    Py_DECREF( par_object );
    par_object = NULL;

    CHECK_OBJECT( (PyObject *)par_counter );
    Py_DECREF( par_counter );
    par_counter = NULL;

    CHECK_OBJECT( (PyObject *)par_instance );
    Py_DECREF( par_instance );
    par_instance = NULL;

    CHECK_OBJECT( (PyObject *)par_inum );
    Py_DECREF( par_inum );
    par_inum = NULL;

    Py_XDECREF( par_format );
    par_format = NULL;

    CHECK_OBJECT( (PyObject *)par_machine );
    Py_DECREF( par_machine );
    par_machine = NULL;

    Py_XDECREF( var_win32pdh );
    var_win32pdh = NULL;

    Py_XDECREF( var_path );
    var_path = NULL;

    Py_XDECREF( var_hq );
    var_hq = NULL;

    Py_XDECREF( var_hc );
    var_hc = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_val );
    var_val = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_6_GetPerformanceAttributes_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_7_memusage_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_processName = python_pars[ 0 ];
    PyObject *par_instance = python_pars[ 1 ];
    PyObject *var_win32pdh = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_05bc7f151fd8ff6105aec533bff08469, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_processName )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_processName,
            par_processName
        );

        assert( res == 0 );
    }

    if ( par_instance )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_instance,
            par_instance
        );

        assert( res == 0 );
    }

    if ( var_win32pdh )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_win32pdh,
            var_win32pdh
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 151;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_win32pdh, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 151;
        goto frame_exception_exit_1;
    }
    assert( var_win32pdh == NULL );
    var_win32pdh = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_GetPerformanceAttributes );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GetPerformanceAttributes );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GetPerformanceAttributes" );
        exception_tb = NULL;

        exception_lineno = 152;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_Process;
    tmp_args_element_name_2 = const_str_digest_01f1c58babb9e9d1a30d908b35924c3d;
    tmp_args_element_name_3 = par_processName;

    tmp_args_element_name_4 = par_instance;

    tmp_source_name_1 = var_win32pdh;

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_PDH_FMT_LONG );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 154;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = Py_None;
    frame_function->f_lineno = 154;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS6( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 154;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_processName )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_processName,
                    par_processName
                );

                assert( res == 0 );
            }

            if ( par_instance )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_instance,
                    par_instance
                );

                assert( res == 0 );
            }

            if ( var_win32pdh )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_win32pdh,
                    var_win32pdh
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_7_memusage_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_processName );
    Py_DECREF( par_processName );
    par_processName = NULL;

    CHECK_OBJECT( (PyObject *)par_instance );
    Py_DECREF( par_instance );
    par_instance = NULL;

    CHECK_OBJECT( (PyObject *)var_win32pdh );
    Py_DECREF( var_win32pdh );
    var_win32pdh = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_processName );
    Py_DECREF( par_processName );
    par_processName = NULL;

    CHECK_OBJECT( (PyObject *)par_instance );
    Py_DECREF( par_instance );
    par_instance = NULL;

    Py_XDECREF( var_win32pdh );
    var_win32pdh = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_7_memusage_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_8_memusage_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par__proc_pid_stat = python_pars[ 0 ];
    PyObject *var_f = NULL;
    PyObject *var_l = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_int_arg_1;
    PyObject *tmp_open_filename_1;
    PyObject *tmp_open_mode_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ee2b3ab5579611fe12a028b5b350b0e2, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_open_filename_1 = par__proc_pid_stat;

    tmp_open_mode_1 = const_str_plain_r;
    tmp_assign_source_1 = BUILTIN_OPEN( tmp_open_filename_1, tmp_open_mode_1, NULL );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 163;
        goto try_except_handler_2;
    }
    assert( var_f == NULL );
    var_f = tmp_assign_source_1;

    tmp_source_name_2 = var_f;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_readline );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 164;
    tmp_source_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        goto try_except_handler_2;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_split );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 164;
    tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_space_tuple, 0 ) );

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 164;
        goto try_except_handler_2;
    }
    assert( var_l == NULL );
    var_l = tmp_assign_source_2;

    tmp_source_name_3 = var_f;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_close );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 165;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 165;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_1 = var_l;

    tmp_subscript_name_1 = const_int_pos_22;
    tmp_int_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_int_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        goto try_except_handler_2;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
    Py_DECREF( tmp_int_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_8_memusage_of_numpy$testing$utils );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_8_memusage_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par__proc_pid_stat );
    Py_DECREF( par__proc_pid_stat );
    par__proc_pid_stat = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par__proc_pid_stat );
    Py_DECREF( par__proc_pid_stat );
    par__proc_pid_stat = NULL;

    CHECK_OBJECT( (PyObject *)var_f );
    Py_DECREF( var_f );
    var_f = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_8_memusage_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_9_memusage_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_raise_type_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;


    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_31e6dd57e5e17cef27fc808b38efcb43, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_raise_type_1 = PyExc_NotImplementedError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 175;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();


            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_9_memusage_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_function_10_jiffies_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par__proc_pid_stat = python_pars[ 0 ];
    PyObject *par__load_time = python_pars[ 1 ];
    PyObject *var_time = NULL;
    PyObject *var_f = NULL;
    PyObject *var_l = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_int_arg_1;
    PyObject *tmp_int_arg_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_open_filename_1;
    PyObject *tmp_open_mode_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_93f4b121ec830060d3ee45a03e212aaa, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par__proc_pid_stat )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__proc_pid_stat,
            par__proc_pid_stat
        );

        assert( res == 0 );
    }

    if ( par__load_time )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__load_time,
            par__load_time
        );

        assert( res == 0 );
    }

    if ( var_time )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_time,
            var_time
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_l )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_l,
            var_l
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 188;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_time, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 188;
        goto frame_exception_exit_1;
    }
    assert( var_time == NULL );
    var_time = tmp_assign_source_1;

    tmp_cond_value_1 = par__load_time;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 189;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par__load_time;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = var_time;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_time );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 190;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 190;
    tmp_args_element_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 190;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 190;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    // Tried code:
    tmp_open_filename_1 = par__proc_pid_stat;

    tmp_open_mode_1 = const_str_plain_r;
    tmp_assign_source_2 = BUILTIN_OPEN( tmp_open_filename_1, tmp_open_mode_1, NULL );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 192;
        goto try_except_handler_2;
    }
    assert( var_f == NULL );
    var_f = tmp_assign_source_2;

    tmp_source_name_4 = var_f;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_readline );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 193;
    tmp_source_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    Py_DECREF( tmp_called_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        goto try_except_handler_2;
    }
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_split );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 193;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_space_tuple, 0 ) );

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        goto try_except_handler_2;
    }
    assert( var_l == NULL );
    var_l = tmp_assign_source_3;

    tmp_source_name_5 = var_f;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_close );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 194;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
    Py_DECREF( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_1 = var_l;

    tmp_subscript_name_1 = const_int_pos_13;
    tmp_int_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_int_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        goto try_except_handler_2;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
    Py_DECREF( tmp_int_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_10_jiffies_of_numpy$testing$utils );
    return NULL;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_left_name_1 = const_int_pos_100;
    tmp_source_name_6 = var_time;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_time );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 197;
    tmp_left_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    Py_DECREF( tmp_called_name_6 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par__load_time;

    tmp_subscript_name_2 = const_int_0;
    tmp_right_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_2 );

        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    tmp_int_arg_2 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_int_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_2 );
    Py_DECREF( tmp_int_arg_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    // End of try:

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par__proc_pid_stat )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__proc_pid_stat,
                    par__proc_pid_stat
                );

                assert( res == 0 );
            }

            if ( par__load_time )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__load_time,
                    par__load_time
                );

                assert( res == 0 );
            }

            if ( var_time )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_time,
                    var_time
                );

                assert( res == 0 );
            }

            if ( var_f )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_f,
                    var_f
                );

                assert( res == 0 );
            }

            if ( var_l )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_l,
                    var_l
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_10_jiffies_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par__proc_pid_stat );
    Py_DECREF( par__proc_pid_stat );
    par__proc_pid_stat = NULL;

    CHECK_OBJECT( (PyObject *)par__load_time );
    Py_DECREF( par__load_time );
    par__load_time = NULL;

    CHECK_OBJECT( (PyObject *)var_time );
    Py_DECREF( var_time );
    var_time = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par__proc_pid_stat );
    Py_DECREF( par__proc_pid_stat );
    par__proc_pid_stat = NULL;

    CHECK_OBJECT( (PyObject *)par__load_time );
    Py_DECREF( par__load_time );
    par__load_time = NULL;

    Py_XDECREF( var_time );
    var_time = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_10_jiffies_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_11_jiffies_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par__load_time = python_pars[ 0 ];
    PyObject *var_time = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_int_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3f2b26218a09d13378fbe840b5a42d0d, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par__load_time )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__load_time,
            par__load_time
        );

        assert( res == 0 );
    }

    if ( var_time )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_time,
            var_time
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 210;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_time, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 210;
        goto frame_exception_exit_1;
    }
    assert( var_time == NULL );
    var_time = tmp_assign_source_1;

    tmp_cond_value_1 = par__load_time;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par__load_time;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 212;
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = var_time;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_time );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 212;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 212;
    tmp_args_element_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 212;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 212;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 212;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_left_name_1 = const_int_pos_100;
    tmp_source_name_3 = var_time;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_time );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 213;
    tmp_left_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par__load_time;

    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_2 );

        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    tmp_int_arg_1 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_int_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    tmp_return_value = PyNumber_Int( tmp_int_arg_1 );
    Py_DECREF( tmp_int_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par__load_time )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__load_time,
                    par__load_time
                );

                assert( res == 0 );
            }

            if ( var_time )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_time,
                    var_time
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_11_jiffies_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par__load_time );
    Py_DECREF( par__load_time );
    par__load_time = NULL;

    CHECK_OBJECT( (PyObject *)var_time );
    Py_DECREF( var_time );
    var_time = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par__load_time );
    Py_DECREF( par__load_time );
    par__load_time = NULL;

    Py_XDECREF( var_time );
    var_time = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_11_jiffies_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_12_build_err_msg_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arrays = python_pars[ 0 ];
    PyObject *par_err_msg = python_pars[ 1 ];
    PyObject *par_header = python_pars[ 2 ];
    PyObject *par_verbose = python_pars[ 3 ];
    PyObject *par_names = python_pars[ 4 ];
    PyObject *par_precision = python_pars[ 5 ];
    PyObject *var_msg = NULL;
    PyObject *var_i = NULL;
    PyObject *var_a = NULL;
    PyObject *var_r_func = NULL;
    PyObject *var_r = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_next_source_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_033604a5dde6d855150cecf0e266f33b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_assign_source_1 = PyList_New( 1 );
    tmp_left_name_1 = const_str_newline;
    tmp_right_name_1 = par_header;

    tmp_list_element_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 218;
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_1, 0, tmp_list_element_1 );
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_1;

    tmp_cond_value_1 = par_err_msg;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 219;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_err_msg;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_find );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 220;
    tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_neg_1;
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_len_arg_1 = par_err_msg;

    tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_int_pos_79;
    tmp_len_arg_2 = par_header;

    tmp_right_name_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_2 );

        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = RICH_COMPARE_LT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 220;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_2 = PyList_New( 1 );
    tmp_subscribed_name_1 = var_msg;

    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_2 );

        exception_lineno = 221;
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_space;
    tmp_left_name_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_left_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_2 );

        exception_lineno = 221;
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = par_err_msg;

    tmp_list_element_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_2 );

        exception_lineno = 221;
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_2, 0, tmp_list_element_2 );
    {
        PyObject *old = var_msg;
        assert( old != NULL );
        var_msg = tmp_assign_source_2;
        Py_DECREF( old );
    }

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_2 = var_msg;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_append );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_err_msg;

    frame_function->f_lineno = 223;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;
    branch_no_1:;
    tmp_cond_value_3 = par_verbose;

    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 224;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_enumerate );
    assert( tmp_called_name_3 != NULL );
    tmp_args_element_name_2 = par_arrays;

    frame_function->f_lineno = 225;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_3;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 225;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_iter_arg_2 = tmp_for_loop_1__iter_value;

    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 225;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_7 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 225;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_3;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;

    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_8;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;

    {
        PyObject *old = var_a;
        var_a = tmp_assign_source_9;
        Py_INCREF( var_a );
        Py_XDECREF( old );
    }

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_isinstance_inst_1 = var_a;

    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_ndarray );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ndarray );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ndarray" );
        exception_tb = NULL;

        exception_lineno = 227;
        goto try_except_handler_2;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 227;
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_partial );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "partial" );
        exception_tb = NULL;

        exception_lineno = 229;
        goto try_except_handler_2;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_array_repr );

    if (unlikely( tmp_tuple_element_1 == NULL ))
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_array_repr );
    }

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "array_repr" );
        exception_tb = NULL;

        exception_lineno = 229;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = par_precision;

    tmp_dict_key_1 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 229;
    tmp_assign_source_10 = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 229;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_r_func;
        var_r_func = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    goto branch_end_4;
    branch_no_4:;
    tmp_assign_source_11 = LOOKUP_BUILTIN( const_str_plain_repr );
    assert( tmp_assign_source_11 != NULL );
    {
        PyObject *old = var_r_func;
        var_r_func = tmp_assign_source_11;
        Py_INCREF( var_r_func );
        Py_XDECREF( old );
    }

    branch_end_4:;
    // Tried code:
    tmp_called_name_5 = var_r_func;

    tmp_args_element_name_3 = var_a;

    frame_function->f_lineno = 234;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 234;
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_r;
        var_r = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_assign_source_13 = const_str_digest_91d13b44af9a5a13a2155d933ca121b5;
    {
        PyObject *old = var_r;
        var_r = tmp_assign_source_13;
        Py_INCREF( var_r );
        Py_XDECREF( old );
    }

    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_12_build_err_msg_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_2:;
    tmp_source_name_3 = var_r;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_count );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 237;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 237;
    tmp_compare_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_str_newline_tuple, 0 ) );

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 237;
        goto try_except_handler_2;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 237;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_4 = const_str_newline;
    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_join );
    assert( tmp_called_name_7 != NULL );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = 3;
    tmp_source_name_5 = var_r;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_splitlines );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 238;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 238;
    tmp_slice_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    Py_DECREF( tmp_called_name_8 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 238;
        goto try_except_handler_2;
    }
    tmp_args_element_name_4 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 238;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 238;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_14 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 238;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_r;
        assert( old != NULL );
        var_r = tmp_assign_source_14;
        Py_DECREF( old );
    }

    tmp_left_name_5 = var_r;

    tmp_right_name_5 = const_str_digest_3501979af1b70861f5e9d6a0f04129bf;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_5, tmp_right_name_5 );
    tmp_assign_source_15 = tmp_left_name_5;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 239;
        goto try_except_handler_2;
    }
    var_r = tmp_assign_source_15;

    branch_no_5:;
    tmp_source_name_6 = var_msg;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "msg" );
        exception_tb = NULL;

        exception_lineno = 240;
        goto try_except_handler_2;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_append );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 240;
        goto try_except_handler_2;
    }
    tmp_left_name_6 = const_str_digest_d0bd227ac888e31c52f69b54a1abf325;
    tmp_right_name_6 = PyTuple_New( 2 );
    tmp_subscribed_name_2 = par_names;

    tmp_subscript_name_2 = var_i;

    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_right_name_6 );

        exception_lineno = 240;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_6, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = var_r;

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        Py_DECREF( tmp_right_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "r" );
        exception_tb = NULL;

        exception_lineno = 240;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_right_name_6, 1, tmp_tuple_element_2 );
    tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 240;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 240;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 240;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_3:;
    tmp_source_name_7 = const_str_newline;
    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_join );
    assert( tmp_called_name_10 != NULL );
    tmp_args_element_name_6 = var_msg;

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_10 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "msg" );
        exception_tb = NULL;

        exception_lineno = 241;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 241;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 241;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_arrays )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_arrays,
                    par_arrays
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_header )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_header,
                    par_header
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }

            if ( par_names )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_names,
                    par_names
                );

                assert( res == 0 );
            }

            if ( par_precision )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_precision,
                    par_precision
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }

            if ( var_i )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_i,
                    var_i
                );

                assert( res == 0 );
            }

            if ( var_a )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_a,
                    var_a
                );

                assert( res == 0 );
            }

            if ( var_r_func )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_r_func,
                    var_r_func
                );

                assert( res == 0 );
            }

            if ( var_r )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_r,
                    var_r
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_12_build_err_msg_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arrays );
    Py_DECREF( par_arrays );
    par_arrays = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_header );
    Py_DECREF( par_header );
    par_header = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)par_names );
    Py_DECREF( par_names );
    par_names = NULL;

    CHECK_OBJECT( (PyObject *)par_precision );
    Py_DECREF( par_precision );
    par_precision = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_a );
    var_a = NULL;

    Py_XDECREF( var_r_func );
    var_r_func = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arrays );
    Py_DECREF( par_arrays );
    par_arrays = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_header );
    Py_DECREF( par_header );
    par_header = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)par_names );
    Py_DECREF( par_names );
    par_names = NULL;

    CHECK_OBJECT( (PyObject *)par_precision );
    Py_DECREF( par_precision );
    par_precision = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_a );
    var_a = NULL;

    Py_XDECREF( var_r_func );
    var_r_func = NULL;

    Py_XDECREF( var_r );
    var_r = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_12_build_err_msg_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_13_assert_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_actual = python_pars[ 0 ];
    PyObject *par_desired = python_pars[ 1 ];
    PyObject *par_err_msg = python_pars[ 2 ];
    PyObject *par_verbose = python_pars[ 3 ];
    PyObject *var_k = NULL;
    PyObject *var_i = NULL;
    PyObject *var_ndarray = NULL;
    PyObject *var_isscalar = NULL;
    PyObject *var_signbit = NULL;
    PyObject *var_iscomplexobj = NULL;
    PyObject *var_real = NULL;
    PyObject *var_imag = NULL;
    PyObject *var_msg = NULL;
    PyObject *var_usecomplex = NULL;
    PyObject *var_actualr = NULL;
    PyObject *var_actuali = NULL;
    PyObject *var_desiredr = NULL;
    PyObject *var_desiredi = NULL;
    PyObject *var_isdesnan = NULL;
    PyObject *var_isactnan = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    int tmp_and_left_truth_3;
    int tmp_and_left_truth_4;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_left_value_3;
    PyObject *tmp_and_left_value_4;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_and_right_value_3;
    PyObject *tmp_and_right_value_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_NotEq_1;
    int tmp_cmp_NotIn_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    int tmp_exc_match_exception_match_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_globals_4;
    PyObject *tmp_import_globals_5;
    PyObject *tmp_import_globals_6;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_locals_3;
    PyObject *tmp_import_locals_4;
    PyObject *tmp_import_locals_5;
    PyObject *tmp_import_locals_6;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_cls_4;
    PyObject *tmp_isinstance_cls_5;
    PyObject *tmp_isinstance_cls_6;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    PyObject *tmp_isinstance_inst_4;
    PyObject *tmp_isinstance_inst_5;
    PyObject *tmp_isinstance_inst_6;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_len_arg_3;
    PyObject *tmp_len_arg_4;
    PyObject *tmp_len_arg_5;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_make_exception_arg_6;
    PyObject *tmp_make_exception_arg_7;
    PyObject *tmp_make_exception_arg_8;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    int tmp_or_left_truth_3;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_left_value_3;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_or_right_value_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    PyObject *tmp_raise_type_6;
    PyObject *tmp_raise_type_7;
    PyObject *tmp_raise_type_8;
    PyObject *tmp_range_arg_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8838e1559d7858c5c5fc0fb43fdca72b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_isinstance_inst_1 = par_desired;

    tmp_isinstance_cls_1 = LOOKUP_BUILTIN( const_str_plain_dict );
    assert( tmp_isinstance_cls_1 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 278;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_isinstance_inst_2 = par_actual;

    tmp_isinstance_cls_2 = LOOKUP_BUILTIN( const_str_plain_dict );
    assert( tmp_isinstance_cls_2 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 279;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_type_arg_1 = par_actual;

    tmp_operand_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_operand_name_1 != NULL );
    tmp_make_exception_arg_1 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 280;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 280;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 281;
        goto frame_exception_exit_1;
    }

    tmp_len_arg_1 = par_actual;

    tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 281;
        goto frame_exception_exit_1;
    }
    tmp_len_arg_2 = par_desired;

    tmp_args_element_name_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 281;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_err_msg;

    tmp_args_element_name_4 = par_verbose;

    frame_function->f_lineno = 281;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 281;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_desired;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_items );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 282;
    tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 282;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_iter_arg_2 = tmp_for_loop_1__iter_value;

    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 282;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 282;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_3;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_tuple_unpack_1__element_1;

    {
        PyObject *old = var_k;
        var_k = tmp_assign_source_6;
        Py_INCREF( var_k );
        Py_XDECREF( old );
    }

    tmp_assign_source_7 = tmp_tuple_unpack_1__element_2;

    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_7;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_1 = var_k;

    tmp_compare_right_1 = par_actual;

    tmp_cmp_NotIn_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_NotIn_1 == -1) );
    if ( tmp_cmp_NotIn_1 == 0 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_operand_name_2 = var_k;

    tmp_make_exception_arg_2 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_2 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 284;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 284;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_2;
    branch_no_3:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 285;
        goto try_except_handler_2;
    }

    tmp_subscribed_name_1 = par_actual;

    tmp_subscript_name_1 = var_k;

    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 285;
        goto try_except_handler_2;
    }
    tmp_subscribed_name_2 = par_desired;

    tmp_subscript_name_2 = var_k;

    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 285;
        goto try_except_handler_2;
    }
    tmp_left_name_1 = const_str_digest_8159168790756c2f5fb8ca65599559de;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_k;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_err_msg;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_args_element_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 285;
        goto try_except_handler_2;
    }
    tmp_args_element_name_8 = par_verbose;

    frame_function->f_lineno = 285;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 285;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 282;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_3 = par_desired;

    tmp_isinstance_cls_3 = PyTuple_New( 2 );
    tmp_tuple_element_2 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_tuple_element_2 != NULL );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_3, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = LOOKUP_BUILTIN( const_str_plain_tuple );
    assert( tmp_tuple_element_2 != NULL );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_3, 1, tmp_tuple_element_2 );
    tmp_and_left_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    Py_DECREF( tmp_isinstance_cls_3 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_isinstance_inst_4 = par_actual;

    tmp_isinstance_cls_4 = PyTuple_New( 2 );
    tmp_tuple_element_3 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_tuple_element_3 != NULL );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_4, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = LOOKUP_BUILTIN( const_str_plain_tuple );
    assert( tmp_tuple_element_3 != NULL );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_4, 1, tmp_tuple_element_3 );
    tmp_and_right_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_4, tmp_isinstance_cls_4 );
    Py_DECREF( tmp_isinstance_cls_4 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 288;
        goto frame_exception_exit_1;
    }

    tmp_len_arg_3 = par_actual;

    tmp_args_element_name_9 = BUILTIN_LEN( tmp_len_arg_3 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        goto frame_exception_exit_1;
    }
    tmp_len_arg_4 = par_desired;

    tmp_args_element_name_10 = BUILTIN_LEN( tmp_len_arg_4 );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_9 );

        exception_lineno = 288;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_11 = par_err_msg;

    tmp_args_element_name_12 = par_verbose;

    frame_function->f_lineno = 288;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_5 = par_desired;

    tmp_range_arg_1 = BUILTIN_LEN( tmp_len_arg_5 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 289;
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_3 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 289;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_3 );
    Py_DECREF( tmp_iter_arg_3 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 289;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_2__for_iterator == NULL );
    tmp_for_loop_2__for_iterator = tmp_assign_source_8;

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_9 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 289;
            goto try_except_handler_4;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_assign_source_10 = tmp_for_loop_2__iter_value;

    {
        PyObject *old = var_k;
        var_k = tmp_assign_source_10;
        Py_INCREF( var_k );
        Py_XDECREF( old );
    }

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 290;
        goto try_except_handler_4;
    }

    tmp_subscribed_name_3 = par_actual;

    tmp_subscript_name_3 = var_k;

    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        goto try_except_handler_4;
    }
    tmp_subscribed_name_4 = par_desired;

    tmp_subscript_name_4 = var_k;

    tmp_args_element_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 290;
        goto try_except_handler_4;
    }
    tmp_left_name_2 = const_str_digest_5d720dbb105833cafa470af4c6a246e5;
    tmp_right_name_2 = PyTuple_New( 2 );
    tmp_tuple_element_4 = var_k;

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_4 );
    tmp_tuple_element_4 = par_err_msg;

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_4 );
    tmp_args_element_name_15 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_args_element_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_13 );
        Py_DECREF( tmp_args_element_name_14 );

        exception_lineno = 290;
        goto try_except_handler_4;
    }
    tmp_args_element_name_16 = par_verbose;

    frame_function->f_lineno = 290;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14, tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_14 );
    Py_DECREF( tmp_args_element_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 289;
        goto try_except_handler_4;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_4:;
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 292;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_ndarray );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    assert( var_ndarray == NULL );
    var_ndarray = tmp_assign_source_11;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 292;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_isscalar );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    assert( var_isscalar == NULL );
    var_isscalar = tmp_assign_source_12;

    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_3 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 292;
    tmp_import_name_from_3 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_3, tmp_import_locals_3, const_tuple_str_plain_ndarray_str_plain_isscalar_str_plain_signbit_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_3 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_signbit );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        goto frame_exception_exit_1;
    }
    assert( var_signbit == NULL );
    var_signbit = tmp_assign_source_13;

    tmp_import_globals_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_4 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 293;
    tmp_import_name_from_4 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_4, tmp_import_locals_4, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_4 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_iscomplexobj );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    assert( var_iscomplexobj == NULL );
    var_iscomplexobj = tmp_assign_source_14;

    tmp_import_globals_5 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_5 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 293;
    tmp_import_name_from_5 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_5, tmp_import_locals_5, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_5 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_real );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    assert( var_real == NULL );
    var_real = tmp_assign_source_15;

    tmp_import_globals_6 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_6 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_k )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_k,
            var_k
        );

        assert( res == 0 );
    }

    if ( var_i )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_i,
            var_i
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_isscalar )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isscalar,
            var_isscalar
        );

        assert( res == 0 );
    }

    if ( var_signbit )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_signbit,
            var_signbit
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    if ( var_isdesnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isdesnan,
            var_isdesnan
        );

        assert( res == 0 );
    }

    if ( var_isactnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isactnan,
            var_isactnan
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 293;
    tmp_import_name_from_6 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_6, tmp_import_locals_6, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_6 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_imag );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        goto frame_exception_exit_1;
    }
    assert( var_imag == NULL );
    var_imag = tmp_assign_source_16;

    tmp_isinstance_inst_5 = par_actual;

    tmp_isinstance_cls_5 = var_ndarray;

    tmp_or_left_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_5, tmp_isinstance_cls_5 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_isinstance_inst_6 = par_desired;

    tmp_isinstance_cls_6 = var_ndarray;

    tmp_or_right_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_6, tmp_isinstance_cls_6 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_2 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_equal );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_equal );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_equal" );
        exception_tb = NULL;

        exception_lineno = 295;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_17 = par_actual;

    tmp_args_element_name_18 = par_desired;

    tmp_args_element_name_19 = par_err_msg;

    tmp_args_element_name_20 = par_verbose;

    frame_function->f_lineno = 295;
    {
        PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_6, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 295;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_5:;
    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 296;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_5 = PyList_New( 2 );
    tmp_list_element_1 = par_actual;

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_5, 0, tmp_list_element_1 );
    tmp_list_element_1 = par_desired;

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_5, 1, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_5 );
    tmp_tuple_element_5 = par_err_msg;

    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_5 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = par_verbose;

    tmp_dict_key_1 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 296;
    tmp_assign_source_17 = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_17;

    // Tried code:
    tmp_called_name_8 = var_iscomplexobj;

    tmp_args_element_name_21 = par_actual;

    frame_function->f_lineno = 302;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_or_left_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        goto try_except_handler_5;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_2 );

        exception_lineno = 302;
        goto try_except_handler_5;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    Py_DECREF( tmp_or_left_value_2 );
    tmp_called_name_9 = var_iscomplexobj;

    tmp_args_element_name_22 = par_desired;

    frame_function->f_lineno = 302;
    {
        PyObject *call_args[] = { tmp_args_element_name_22 };
        tmp_or_right_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        goto try_except_handler_5;
    }
    tmp_assign_source_18 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_assign_source_18 = tmp_or_left_value_2;
    or_end_2:;
    assert( var_usecomplex == NULL );
    var_usecomplex = tmp_assign_source_18;

    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_4 == NULL )
    {
        exception_keeper_tb_4 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_4 );
    }
    else if ( exception_keeper_lineno_4 != -1 )
    {
        exception_keeper_tb_4 = ADD_TRACEBACK( exception_keeper_tb_4, frame_function, exception_keeper_lineno_4 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    PUBLISH_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_ValueError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_assign_source_19 = Py_False;
    assert( var_usecomplex == NULL );
    Py_INCREF( tmp_assign_source_19 );
    var_usecomplex = tmp_assign_source_19;

    goto branch_end_6;
    branch_no_6:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_6:;
    goto try_end_4;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_13_assert_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_4:;
    tmp_cond_value_3 = var_usecomplex;

    if ( tmp_cond_value_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "usecomplex" );
        exception_tb = NULL;

        exception_lineno = 306;
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 306;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_name_10 = var_iscomplexobj;

    tmp_args_element_name_23 = par_actual;

    frame_function->f_lineno = 307;
    {
        PyObject *call_args[] = { tmp_args_element_name_23 };
        tmp_cond_value_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    if ( tmp_cond_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 307;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 307;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_called_name_11 = var_real;

    tmp_args_element_name_24 = par_actual;

    frame_function->f_lineno = 308;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_assign_source_20 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;
        goto frame_exception_exit_1;
    }
    assert( var_actualr == NULL );
    var_actualr = tmp_assign_source_20;

    tmp_called_name_12 = var_imag;

    tmp_args_element_name_25 = par_actual;

    frame_function->f_lineno = 309;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_assign_source_21 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 309;
        goto frame_exception_exit_1;
    }
    assert( var_actuali == NULL );
    var_actuali = tmp_assign_source_21;

    goto branch_end_8;
    branch_no_8:;
    tmp_assign_source_22 = par_actual;

    assert( var_actualr == NULL );
    Py_INCREF( tmp_assign_source_22 );
    var_actualr = tmp_assign_source_22;

    tmp_assign_source_23 = const_int_0;
    assert( var_actuali == NULL );
    Py_INCREF( tmp_assign_source_23 );
    var_actuali = tmp_assign_source_23;

    branch_end_8:;
    tmp_called_name_13 = var_iscomplexobj;

    tmp_args_element_name_26 = par_desired;

    frame_function->f_lineno = 313;
    {
        PyObject *call_args[] = { tmp_args_element_name_26 };
        tmp_cond_value_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 313;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_called_name_14 = var_real;

    tmp_args_element_name_27 = par_desired;

    frame_function->f_lineno = 314;
    {
        PyObject *call_args[] = { tmp_args_element_name_27 };
        tmp_assign_source_24 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    if ( tmp_assign_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        goto frame_exception_exit_1;
    }
    assert( var_desiredr == NULL );
    var_desiredr = tmp_assign_source_24;

    tmp_called_name_15 = var_imag;

    tmp_args_element_name_28 = par_desired;

    frame_function->f_lineno = 315;
    {
        PyObject *call_args[] = { tmp_args_element_name_28 };
        tmp_assign_source_25 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        goto frame_exception_exit_1;
    }
    assert( var_desiredi == NULL );
    var_desiredi = tmp_assign_source_25;

    goto branch_end_9;
    branch_no_9:;
    tmp_assign_source_26 = par_desired;

    assert( var_desiredr == NULL );
    Py_INCREF( tmp_assign_source_26 );
    var_desiredr = tmp_assign_source_26;

    tmp_assign_source_27 = const_int_0;
    assert( var_desiredi == NULL );
    Py_INCREF( tmp_assign_source_27 );
    var_desiredi = tmp_assign_source_27;

    branch_end_9:;
    // Tried code:
    tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_16 == NULL ))
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 320;
        goto try_except_handler_6;
    }

    tmp_args_element_name_29 = var_actualr;

    tmp_args_element_name_30 = var_desiredr;

    frame_function->f_lineno = 320;
    {
        PyObject *call_args[] = { tmp_args_element_name_29, tmp_args_element_name_30 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_16, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 320;
        goto try_except_handler_6;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_equal );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_equal" );
        exception_tb = NULL;

        exception_lineno = 321;
        goto try_except_handler_6;
    }

    tmp_args_element_name_31 = var_actuali;

    tmp_args_element_name_32 = var_desiredi;

    frame_function->f_lineno = 321;
    {
        PyObject *call_args[] = { tmp_args_element_name_31, tmp_args_element_name_32 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_17, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 321;
        goto try_except_handler_6;
    }
    Py_DECREF( tmp_unused );
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_5 == NULL )
    {
        exception_keeper_tb_5 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_5 );
    }
    else if ( exception_keeper_lineno_5 != -1 )
    {
        exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_function, exception_keeper_lineno_5 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_AssertionError;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_make_exception_arg_3 = var_msg;

    frame_function->f_lineno = 323;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 323;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    goto branch_end_10;
    branch_no_10:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_10:;
    // End of try:
    try_end_5:;
    branch_no_7:;
    // Tried code:
    tmp_called_name_18 = var_isscalar;

    tmp_args_element_name_33 = par_desired;

    frame_function->f_lineno = 328;
    {
        PyObject *call_args[] = { tmp_args_element_name_33 };
        tmp_compare_left_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    if ( tmp_compare_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 328;
        goto try_except_handler_7;
    }
    tmp_called_name_19 = var_isscalar;

    tmp_args_element_name_34 = par_actual;

    frame_function->f_lineno = 328;
    {
        PyObject *call_args[] = { tmp_args_element_name_34 };
        tmp_compare_right_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    if ( tmp_compare_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );

        exception_lineno = 328;
        goto try_except_handler_7;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );
        Py_DECREF( tmp_compare_right_4 );

        exception_lineno = 328;
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_compare_left_4 );
    Py_DECREF( tmp_compare_right_4 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_make_exception_arg_4 = var_msg;

    frame_function->f_lineno = 329;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 329;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_7;
    branch_no_11:;
    tmp_called_name_20 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_20 == NULL ))
    {
        tmp_called_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 334;
        goto try_except_handler_7;
    }

    tmp_args_element_name_35 = par_desired;

    frame_function->f_lineno = 334;
    {
        PyObject *call_args[] = { tmp_args_element_name_35 };
        tmp_and_left_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;
        goto try_except_handler_7;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 334;
        goto try_except_handler_7;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_called_name_21 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_21 == NULL ))
    {
        tmp_called_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 334;
        goto try_except_handler_7;
    }

    tmp_args_element_name_36 = par_actual;

    frame_function->f_lineno = 334;
    {
        PyObject *call_args[] = { tmp_args_element_name_36 };
        tmp_and_right_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
    }

    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;
        goto try_except_handler_7;
    }
    tmp_cond_value_6 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_6 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 334;
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_no_12;
    }
    else
    {
        goto branch_yes_12;
    }
    branch_yes_12:;
    tmp_called_name_22 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_22 == NULL ))
    {
        tmp_called_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 335;
        goto try_except_handler_7;
    }

    tmp_args_element_name_37 = par_desired;

    frame_function->f_lineno = 335;
    {
        PyObject *call_args[] = { tmp_args_element_name_37 };
        tmp_assign_source_28 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
    }

    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 335;
        goto try_except_handler_7;
    }
    assert( var_isdesnan == NULL );
    var_isdesnan = tmp_assign_source_28;

    tmp_called_name_23 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_23 == NULL ))
    {
        tmp_called_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 336;
        goto try_except_handler_7;
    }

    tmp_args_element_name_38 = par_actual;

    frame_function->f_lineno = 336;
    {
        PyObject *call_args[] = { tmp_args_element_name_38 };
        tmp_assign_source_29 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
    }

    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;
        goto try_except_handler_7;
    }
    assert( var_isactnan == NULL );
    var_isactnan = tmp_assign_source_29;

    tmp_or_left_value_3 = var_isdesnan;

    tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
    if ( tmp_or_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        goto try_except_handler_7;
    }
    if ( tmp_or_left_truth_3 == 1 )
    {
        goto or_left_3;
    }
    else
    {
        goto or_right_3;
    }
    or_right_3:;
    tmp_or_right_value_3 = var_isactnan;

    tmp_cond_value_7 = tmp_or_right_value_3;
    goto or_end_3;
    or_left_3:;
    tmp_cond_value_7 = tmp_or_left_value_3;
    or_end_3:;
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        goto try_except_handler_7;
    }
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_and_left_value_3 = var_isdesnan;

    tmp_and_left_truth_3 = CHECK_IF_TRUE( tmp_and_left_value_3 );
    if ( tmp_and_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 338;
        goto try_except_handler_7;
    }
    if ( tmp_and_left_truth_3 == 1 )
    {
        goto and_right_3;
    }
    else
    {
        goto and_left_3;
    }
    and_right_3:;
    tmp_and_right_value_3 = var_isactnan;

    tmp_cond_value_8 = tmp_and_right_value_3;
    goto and_end_3;
    and_left_3:;
    tmp_cond_value_8 = tmp_and_left_value_3;
    and_end_3:;
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 338;
        goto try_except_handler_7;
    }
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_no_14;
    }
    else
    {
        goto branch_yes_14;
    }
    branch_yes_14:;
    tmp_make_exception_arg_5 = var_msg;

    frame_function->f_lineno = 339;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 339;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_7;
    branch_no_14:;
    goto branch_end_13;
    branch_no_13:;
    tmp_compare_left_5 = par_desired;

    tmp_compare_right_5 = par_actual;

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 341;
        goto try_except_handler_7;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_15;
    }
    else
    {
        goto branch_yes_15;
    }
    branch_yes_15:;
    tmp_make_exception_arg_6 = var_msg;

    frame_function->f_lineno = 342;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_6 };
        tmp_raise_type_6 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_6 != NULL );
    exception_type = tmp_raise_type_6;
    exception_lineno = 342;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_7;
    branch_no_15:;
    branch_end_13:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_12;
    branch_no_12:;
    tmp_compexpr_left_1 = par_desired;

    tmp_compexpr_right_1 = const_int_0;
    tmp_and_left_value_4 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_and_left_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 344;
        goto try_except_handler_7;
    }
    tmp_and_left_truth_4 = CHECK_IF_TRUE( tmp_and_left_value_4 );
    if ( tmp_and_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_4 );

        exception_lineno = 344;
        goto try_except_handler_7;
    }
    if ( tmp_and_left_truth_4 == 1 )
    {
        goto and_right_4;
    }
    else
    {
        goto and_left_4;
    }
    and_right_4:;
    Py_DECREF( tmp_and_left_value_4 );
    tmp_compexpr_left_2 = par_actual;

    tmp_compexpr_right_2 = const_int_0;
    tmp_and_right_value_4 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_and_right_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 344;
        goto try_except_handler_7;
    }
    tmp_cond_value_9 = tmp_and_right_value_4;
    goto and_end_4;
    and_left_4:;
    tmp_cond_value_9 = tmp_and_left_value_4;
    and_end_4:;
    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_9 );

        exception_lineno = 344;
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_yes_16;
    }
    else
    {
        goto branch_no_16;
    }
    branch_yes_16:;
    tmp_called_name_24 = var_signbit;

    tmp_args_element_name_39 = par_desired;

    frame_function->f_lineno = 345;
    {
        PyObject *call_args[] = { tmp_args_element_name_39 };
        tmp_compare_left_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
    }

    if ( tmp_compare_left_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 345;
        goto try_except_handler_7;
    }
    tmp_called_name_25 = var_signbit;

    tmp_args_element_name_40 = par_actual;

    frame_function->f_lineno = 345;
    {
        PyObject *call_args[] = { tmp_args_element_name_40 };
        tmp_compare_right_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_25, call_args );
    }

    if ( tmp_compare_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_6 );

        exception_lineno = 345;
        goto try_except_handler_7;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_6 );
        Py_DECREF( tmp_compare_right_6 );

        exception_lineno = 345;
        goto try_except_handler_7;
    }
    Py_DECREF( tmp_compare_left_6 );
    Py_DECREF( tmp_compare_right_6 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_no_17;
    }
    else
    {
        goto branch_yes_17;
    }
    branch_yes_17:;
    tmp_make_exception_arg_7 = var_msg;

    frame_function->f_lineno = 346;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_7 };
        tmp_raise_type_7 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_7 != NULL );
    exception_type = tmp_raise_type_7;
    exception_lineno = 346;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_7;
    branch_no_17:;
    branch_no_16:;
    branch_end_12:;
    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_6 == NULL )
    {
        exception_keeper_tb_6 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_6 );
    }
    else if ( exception_keeper_lineno_6 != -1 )
    {
        exception_keeper_tb_6 = ADD_TRACEBACK( exception_keeper_tb_6, frame_function, exception_keeper_lineno_6 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    PUBLISH_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    tmp_compare_left_7 = PyThreadState_GET()->exc_type;
    tmp_compare_right_7 = PyTuple_New( 3 );
    tmp_tuple_element_6 = PyExc_TypeError;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_compare_right_7, 0, tmp_tuple_element_6 );
    tmp_tuple_element_6 = PyExc_ValueError;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_compare_right_7, 1, tmp_tuple_element_6 );
    tmp_tuple_element_6 = PyExc_NotImplementedError;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_compare_right_7, 2, tmp_tuple_element_6 );
    tmp_exc_match_exception_match_3 = EXCEPTION_MATCH_BOOL( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_exc_match_exception_match_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_7 );

        exception_lineno = 349;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_7 );
    if ( tmp_exc_match_exception_match_3 == 1 )
    {
        goto branch_no_18;
    }
    else
    {
        goto branch_yes_18;
    }
    branch_yes_18:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_no_18:;
    goto try_end_6;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_13_assert_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_6:;
    tmp_compare_left_8 = par_desired;

    tmp_compare_right_8 = par_actual;

    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 353;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_no_19;
    }
    else
    {
        goto branch_yes_19;
    }
    branch_yes_19:;
    tmp_make_exception_arg_8 = var_msg;

    frame_function->f_lineno = 354;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_8 };
        tmp_raise_type_8 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_8 != NULL );
    exception_type = tmp_raise_type_8;
    exception_lineno = 354;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_19:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual
                );

                assert( res == 0 );
            }

            if ( par_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }

            if ( var_k )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_k,
                    var_k
                );

                assert( res == 0 );
            }

            if ( var_i )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_i,
                    var_i
                );

                assert( res == 0 );
            }

            if ( var_ndarray )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ndarray,
                    var_ndarray
                );

                assert( res == 0 );
            }

            if ( var_isscalar )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isscalar,
                    var_isscalar
                );

                assert( res == 0 );
            }

            if ( var_signbit )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_signbit,
                    var_signbit
                );

                assert( res == 0 );
            }

            if ( var_iscomplexobj )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_iscomplexobj,
                    var_iscomplexobj
                );

                assert( res == 0 );
            }

            if ( var_real )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_real,
                    var_real
                );

                assert( res == 0 );
            }

            if ( var_imag )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_imag,
                    var_imag
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }

            if ( var_usecomplex )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_usecomplex,
                    var_usecomplex
                );

                assert( res == 0 );
            }

            if ( var_actualr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actualr,
                    var_actualr
                );

                assert( res == 0 );
            }

            if ( var_actuali )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actuali,
                    var_actuali
                );

                assert( res == 0 );
            }

            if ( var_desiredr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desiredr,
                    var_desiredr
                );

                assert( res == 0 );
            }

            if ( var_desiredi )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desiredi,
                    var_desiredi
                );

                assert( res == 0 );
            }

            if ( var_isdesnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isdesnan,
                    var_isdesnan
                );

                assert( res == 0 );
            }

            if ( var_isactnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isactnan,
                    var_isactnan
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_13_assert_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    Py_XDECREF( var_k );
    var_k = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_ndarray );
    var_ndarray = NULL;

    Py_XDECREF( var_isscalar );
    var_isscalar = NULL;

    Py_XDECREF( var_signbit );
    var_signbit = NULL;

    Py_XDECREF( var_iscomplexobj );
    var_iscomplexobj = NULL;

    Py_XDECREF( var_real );
    var_real = NULL;

    Py_XDECREF( var_imag );
    var_imag = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_usecomplex );
    var_usecomplex = NULL;

    Py_XDECREF( var_actualr );
    var_actualr = NULL;

    Py_XDECREF( var_actuali );
    var_actuali = NULL;

    Py_XDECREF( var_desiredr );
    var_desiredr = NULL;

    Py_XDECREF( var_desiredi );
    var_desiredi = NULL;

    Py_XDECREF( var_isdesnan );
    var_isdesnan = NULL;

    Py_XDECREF( var_isactnan );
    var_isactnan = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    Py_XDECREF( var_k );
    var_k = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_ndarray );
    var_ndarray = NULL;

    Py_XDECREF( var_isscalar );
    var_isscalar = NULL;

    Py_XDECREF( var_signbit );
    var_signbit = NULL;

    Py_XDECREF( var_iscomplexobj );
    var_iscomplexobj = NULL;

    Py_XDECREF( var_real );
    var_real = NULL;

    Py_XDECREF( var_imag );
    var_imag = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_usecomplex );
    var_usecomplex = NULL;

    Py_XDECREF( var_actualr );
    var_actualr = NULL;

    Py_XDECREF( var_actuali );
    var_actuali = NULL;

    Py_XDECREF( var_desiredr );
    var_desiredr = NULL;

    Py_XDECREF( var_desiredi );
    var_desiredi = NULL;

    Py_XDECREF( var_isdesnan );
    var_isdesnan = NULL;

    Py_XDECREF( var_isactnan );
    var_isactnan = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_13_assert_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_14_print_assert_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_test_string = python_pars[ 0 ];
    PyObject *par_actual = python_pars[ 1 ];
    PyObject *par_desired = python_pars[ 2 ];
    PyObject *var_pprint = NULL;
    PyObject *var_msg = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_5cbcc38223452863a1215e2af673137c, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_test_string )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_test_string,
            par_test_string
        );

        assert( res == 0 );
    }

    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( var_pprint )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_pprint,
            var_pprint
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 384;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_pprint, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 384;
        goto frame_exception_exit_1;
    }
    assert( var_pprint == NULL );
    var_pprint = tmp_assign_source_1;

    tmp_compare_left_1 = par_actual;

    tmp_compare_right_1 = par_desired;

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 386;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_StringIO );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_StringIO );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "StringIO" );
        exception_tb = NULL;

        exception_lineno = 387;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 387;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 387;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_2;

    tmp_source_name_1 = var_msg;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_write );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_test_string;

    frame_function->f_lineno = 388;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = var_msg;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_write );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 389;
    tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_digest_fa4a27b1c2f76b6436c669fe84f9aec1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = var_pprint;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pprint );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 390;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_actual;

    tmp_args_element_name_3 = var_msg;

    frame_function->f_lineno = 390;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 390;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = var_msg;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_write );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 391;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 391;
    tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_str_digest_f68e5190fae8b666170c0081d799be3d_tuple, 0 ) );

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 391;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = var_pprint;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_pprint );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 392;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_desired;

    tmp_args_element_name_5 = var_msg;

    frame_function->f_lineno = 392;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 392;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = var_msg;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_getvalue );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 393;
    tmp_make_exception_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
    Py_DECREF( tmp_called_name_7 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 393;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 393;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_test_string )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_test_string,
                    par_test_string
                );

                assert( res == 0 );
            }

            if ( par_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual
                );

                assert( res == 0 );
            }

            if ( par_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired
                );

                assert( res == 0 );
            }

            if ( var_pprint )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_pprint,
                    var_pprint
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_14_print_assert_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_test_string );
    Py_DECREF( par_test_string );
    par_test_string = NULL;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)var_pprint );
    Py_DECREF( var_pprint );
    var_pprint = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_test_string );
    Py_DECREF( par_test_string );
    par_test_string = NULL;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    Py_XDECREF( var_pprint );
    var_pprint = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_14_print_assert_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_15_assert_almost_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyCellObject *par_actual = PyCell_NEW1( python_pars[ 0 ] );
    PyCellObject *par_desired = PyCell_NEW1( python_pars[ 1 ] );
    PyCellObject *par_decimal = PyCell_NEW1( python_pars[ 2 ] );
    PyCellObject *par_err_msg = PyCell_NEW1( python_pars[ 3 ] );
    PyCellObject *par_verbose = PyCell_NEW1( python_pars[ 4 ] );
    PyObject *var_ndarray = NULL;
    PyObject *var_iscomplexobj = NULL;
    PyObject *var_real = NULL;
    PyObject *var_imag = NULL;
    PyObject *var_usecomplex = NULL;
    PyObject *var__build_err_msg = NULL;
    PyObject *var_actualr = NULL;
    PyObject *var_actuali = NULL;
    PyObject *var_desiredr = NULL;
    PyObject *var_desiredi = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    int tmp_exc_match_exception_match_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_globals_4;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_locals_3;
    PyObject *tmp_import_locals_4;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    int tmp_or_left_truth_3;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_left_value_3;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_or_right_value_3;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_41969be122ed93b49137ea1ebeb38ab0, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_actual->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_desired->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var__build_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__build_err_msg,
            var__build_err_msg
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 457;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_ndarray_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 457;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_ndarray );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 457;
        goto frame_exception_exit_1;
    }
    assert( var_ndarray == NULL );
    var_ndarray = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_actual->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actual,
            par_actual->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_desired->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desired,
            par_desired->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var__build_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain__build_err_msg,
            var__build_err_msg
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 458;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_2, tmp_import_locals_2, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_iscomplexobj );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    assert( var_iscomplexobj == NULL );
    var_iscomplexobj = tmp_assign_source_2;

    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_3 = PyDict_New();
    if ( par_actual->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actual,
            par_actual->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_desired->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desired,
            par_desired->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var__build_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain__build_err_msg,
            var__build_err_msg
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 458;
    tmp_import_name_from_3 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_3, tmp_import_locals_3, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_3 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_real );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    assert( var_real == NULL );
    var_real = tmp_assign_source_3;

    tmp_import_globals_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_4 = PyDict_New();
    if ( par_actual->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actual,
            par_actual->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_desired->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desired,
            par_desired->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_ndarray )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_ndarray,
            var_ndarray
        );

        assert( res == 0 );
    }

    if ( var_iscomplexobj )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_iscomplexobj,
            var_iscomplexobj
        );

        assert( res == 0 );
    }

    if ( var_real )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_real,
            var_real
        );

        assert( res == 0 );
    }

    if ( var_imag )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_imag,
            var_imag
        );

        assert( res == 0 );
    }

    if ( var_usecomplex )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_usecomplex,
            var_usecomplex
        );

        assert( res == 0 );
    }

    if ( var__build_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain__build_err_msg,
            var__build_err_msg
        );

        assert( res == 0 );
    }

    if ( var_actualr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actualr,
            var_actualr
        );

        assert( res == 0 );
    }

    if ( var_actuali )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_actuali,
            var_actuali
        );

        assert( res == 0 );
    }

    if ( var_desiredr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desiredr,
            var_desiredr
        );

        assert( res == 0 );
    }

    if ( var_desiredi )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_desiredi,
            var_desiredi
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 458;
    tmp_import_name_from_4 = IMPORT_MODULE( const_str_digest_739e8d1fc8adb0b153f875abf35bf9c8, tmp_import_globals_4, tmp_import_locals_4, const_tuple_str_plain_iscomplexobj_str_plain_real_str_plain_imag_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_4 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_imag );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        goto frame_exception_exit_1;
    }
    assert( var_imag == NULL );
    var_imag = tmp_assign_source_4;

    // Tried code:
    tmp_called_name_1 = var_iscomplexobj;

    tmp_args_element_name_1 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 464;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 464;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        goto try_except_handler_2;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 464;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_name_2 = var_iscomplexobj;

    tmp_args_element_name_2 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 464;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 464;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_assign_source_5 = tmp_or_left_value_1;
    or_end_1:;
    assert( var_usecomplex == NULL );
    var_usecomplex = tmp_assign_source_5;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_ValueError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_6 = Py_False;
    assert( var_usecomplex == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_usecomplex = tmp_assign_source_6;

    goto branch_end_1;
    branch_no_1:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_1:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_assign_source_7 = MAKE_FUNCTION_function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils( par_actual, par_decimal, par_desired, par_err_msg, par_verbose );
    assert( var__build_err_msg == NULL );
    var__build_err_msg = tmp_assign_source_7;

    tmp_cond_value_1 = var_usecomplex;

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "usecomplex" );
        exception_tb = NULL;

        exception_lineno = 473;
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 473;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_3 = var_iscomplexobj;

    tmp_args_element_name_3 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 474;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 474;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 474;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_4 = var_real;

    tmp_args_element_name_4 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 475;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 475;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 475;
        goto frame_exception_exit_1;
    }
    assert( var_actualr == NULL );
    var_actualr = tmp_assign_source_8;

    tmp_called_name_5 = var_imag;

    tmp_args_element_name_5 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 476;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 476;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 476;
        goto frame_exception_exit_1;
    }
    assert( var_actuali == NULL );
    var_actuali = tmp_assign_source_9;

    goto branch_end_3;
    branch_no_3:;
    tmp_assign_source_10 = PyCell_GET( par_actual );

    if ( tmp_assign_source_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 478;
        goto frame_exception_exit_1;
    }

    assert( var_actualr == NULL );
    Py_INCREF( tmp_assign_source_10 );
    var_actualr = tmp_assign_source_10;

    tmp_assign_source_11 = const_int_0;
    assert( var_actuali == NULL );
    Py_INCREF( tmp_assign_source_11 );
    var_actuali = tmp_assign_source_11;

    branch_end_3:;
    tmp_called_name_6 = var_iscomplexobj;

    tmp_args_element_name_6 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 480;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 480;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_cond_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 480;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 480;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_7 = var_real;

    tmp_args_element_name_7 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 481;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 481;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 481;
        goto frame_exception_exit_1;
    }
    assert( var_desiredr == NULL );
    var_desiredr = tmp_assign_source_12;

    tmp_called_name_8 = var_imag;

    tmp_args_element_name_8 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 482;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 482;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_13 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;
        goto frame_exception_exit_1;
    }
    assert( var_desiredi == NULL );
    var_desiredi = tmp_assign_source_13;

    goto branch_end_4;
    branch_no_4:;
    tmp_assign_source_14 = PyCell_GET( par_desired );

    if ( tmp_assign_source_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 484;
        goto frame_exception_exit_1;
    }

    assert( var_desiredr == NULL );
    Py_INCREF( tmp_assign_source_14 );
    var_desiredr = tmp_assign_source_14;

    tmp_assign_source_15 = const_int_0;
    assert( var_desiredi == NULL );
    Py_INCREF( tmp_assign_source_15 );
    var_desiredi = tmp_assign_source_15;

    branch_end_4:;
    // Tried code:
    tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_almost_equal );

    if (unlikely( tmp_called_name_9 == NULL ))
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_almost_equal );
    }

    if ( tmp_called_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_almost_equal" );
        exception_tb = NULL;

        exception_lineno = 487;
        goto try_except_handler_3;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_actualr;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_desiredr;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = PyCell_GET( par_decimal );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 487;
        goto try_except_handler_3;
    }

    tmp_dict_key_1 = const_str_plain_decimal;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 487;
    tmp_unused = CALL_FUNCTION( tmp_called_name_9, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 487;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_almost_equal );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_almost_equal );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_almost_equal" );
        exception_tb = NULL;

        exception_lineno = 488;
        goto try_except_handler_3;
    }

    tmp_args_name_2 = PyTuple_New( 2 );
    tmp_tuple_element_2 = var_actuali;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = var_desiredi;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_2 );
    tmp_kw_name_2 = _PyDict_NewPresized( 1 );
    tmp_dict_value_2 = PyCell_GET( par_decimal );

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 488;
        goto try_except_handler_3;
    }

    tmp_dict_key_2 = const_str_plain_decimal;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    frame_function->f_lineno = 488;
    tmp_unused = CALL_FUNCTION( tmp_called_name_10, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 488;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_AssertionError;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 489;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_11 = var__build_err_msg;

    frame_function->f_lineno = 490;
    tmp_make_exception_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_11 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 490;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 490;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 490;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    goto branch_end_5;
    branch_no_5:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_5:;
    // End of try:
    try_end_2:;
    branch_no_2:;
    tmp_isinstance_inst_1 = PyCell_GET( par_actual );

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 492;
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = PyTuple_New( 3 );
    tmp_tuple_element_3 = var_ndarray;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = LOOKUP_BUILTIN( const_str_plain_tuple );
    assert( tmp_tuple_element_3 != NULL );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_3 );
    tmp_tuple_element_3 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_tuple_element_3 != NULL );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 2, tmp_tuple_element_3 );
    tmp_or_left_value_2 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    tmp_isinstance_inst_2 = PyCell_GET( par_desired );

    if ( tmp_isinstance_inst_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 493;
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = PyTuple_New( 3 );
    tmp_tuple_element_4 = var_ndarray;

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 0, tmp_tuple_element_4 );
    tmp_tuple_element_4 = LOOKUP_BUILTIN( const_str_plain_tuple );
    assert( tmp_tuple_element_4 != NULL );
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 1, tmp_tuple_element_4 );
    tmp_tuple_element_4 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_tuple_element_4 != NULL );
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_isinstance_cls_2, 2, tmp_tuple_element_4 );
    tmp_or_right_value_2 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_4 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_cond_value_4 = tmp_or_left_value_2;
    or_end_2:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_almost_equal );

    if (unlikely( tmp_called_name_12 == NULL ))
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_almost_equal );
    }

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_almost_equal" );
        exception_tb = NULL;

        exception_lineno = 494;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 494;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 494;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = PyCell_GET( par_decimal );

    if ( tmp_args_element_name_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 494;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = PyCell_GET( par_err_msg );

    if ( tmp_args_element_name_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 494;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 494;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_12, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 494;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_6:;
    // Tried code:
    tmp_called_name_13 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_13 == NULL ))
    {
        tmp_called_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 499;
        goto try_except_handler_4;
    }

    tmp_args_element_name_13 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 499;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 499;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_and_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;
        goto try_except_handler_4;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 499;
        goto try_except_handler_4;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_14 == NULL ))
    {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 499;
        goto try_except_handler_4;
    }

    tmp_args_element_name_14 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 499;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 499;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_and_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;
        goto try_except_handler_4;
    }
    tmp_cond_value_5 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_5 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 499;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_called_name_15 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_15 == NULL ))
    {
        tmp_called_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 500;
        goto try_except_handler_4;
    }

    tmp_args_element_name_15 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_15 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 500;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 500;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_or_left_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    if ( tmp_or_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        goto try_except_handler_4;
    }
    tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
    if ( tmp_or_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_3 );

        exception_lineno = 500;
        goto try_except_handler_4;
    }
    if ( tmp_or_left_truth_3 == 1 )
    {
        goto or_left_3;
    }
    else
    {
        goto or_right_3;
    }
    or_right_3:;
    Py_DECREF( tmp_or_left_value_3 );
    tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_16 == NULL ))
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 500;
        goto try_except_handler_4;
    }

    tmp_args_element_name_16 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_16 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 500;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 500;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_or_right_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
    }

    if ( tmp_or_right_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        goto try_except_handler_4;
    }
    tmp_cond_value_6 = tmp_or_right_value_3;
    goto or_end_3;
    or_left_3:;
    tmp_cond_value_6 = tmp_or_left_value_3;
    or_end_3:;
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 500;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 501;
        goto try_except_handler_4;
    }

    tmp_args_element_name_17 = PyCell_GET( par_desired );

    if ( tmp_args_element_name_17 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 501;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 501;
    {
        PyObject *call_args[] = { tmp_args_element_name_17 };
        tmp_and_left_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 501;
        goto try_except_handler_4;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 501;
        goto try_except_handler_4;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_called_name_18 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_18 == NULL ))
    {
        tmp_called_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 501;
        goto try_except_handler_4;
    }

    tmp_args_element_name_18 = PyCell_GET( par_actual );

    if ( tmp_args_element_name_18 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 501;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 501;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_and_right_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 501;
        goto try_except_handler_4;
    }
    tmp_cond_value_7 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_7 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 501;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_no_9;
    }
    else
    {
        goto branch_yes_9;
    }
    branch_yes_9:;
    tmp_called_name_19 = var__build_err_msg;

    frame_function->f_lineno = 502;
    tmp_make_exception_arg_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_19 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 502;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 502;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 502;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_9:;
    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_3 = PyCell_GET( par_desired );

    if ( tmp_compare_left_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 504;
        goto try_except_handler_4;
    }

    tmp_compare_right_3 = PyCell_GET( par_actual );

    if ( tmp_compare_right_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 504;
        goto try_except_handler_4;
    }

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 504;
        goto try_except_handler_4;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_10;
    }
    else
    {
        goto branch_yes_10;
    }
    branch_yes_10:;
    tmp_called_name_20 = var__build_err_msg;

    frame_function->f_lineno = 505;
    tmp_make_exception_arg_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_20 );
    if ( tmp_make_exception_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 505;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 505;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_3 );
    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 505;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_10:;
    branch_end_8:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_7:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != -1 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_function, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_compare_left_4 = PyThreadState_GET()->exc_type;
    tmp_compare_right_4 = PyTuple_New( 2 );
    tmp_tuple_element_5 = PyExc_NotImplementedError;
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_compare_right_4, 0, tmp_tuple_element_5 );
    tmp_tuple_element_5 = PyExc_TypeError;
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_compare_right_4, 1, tmp_tuple_element_5 );
    tmp_exc_match_exception_match_3 = EXCEPTION_MATCH_BOOL( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_exc_match_exception_match_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_4 );

        exception_lineno = 507;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_4 );
    if ( tmp_exc_match_exception_match_3 == 1 )
    {
        goto branch_no_11;
    }
    else
    {
        goto branch_yes_11;
    }
    branch_yes_11:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_no_11:;
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_3:;
    tmp_called_name_21 = LOOKUP_BUILTIN( const_str_plain_round );
    assert( tmp_called_name_21 != NULL );
    tmp_called_name_22 = LOOKUP_BUILTIN( const_str_plain_abs );
    assert( tmp_called_name_22 != NULL );
    tmp_left_name_1 = PyCell_GET( par_desired );

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "desired" );
        exception_tb = NULL;

        exception_lineno = 509;
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = PyCell_GET( par_actual );

    if ( tmp_right_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "actual" );
        exception_tb = NULL;

        exception_lineno = 509;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_20 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 509;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_args_element_name_19 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
    }

    Py_DECREF( tmp_args_element_name_20 );
    if ( tmp_args_element_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_21 = PyCell_GET( par_decimal );

    if ( tmp_args_element_name_21 == NULL )
    {
        Py_DECREF( tmp_args_element_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 509;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 509;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_21 };
        tmp_compare_left_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_21, call_args );
    }

    Py_DECREF( tmp_args_element_name_19 );
    if ( tmp_compare_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_5 = const_int_0;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_5 );

        exception_lineno = 509;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_5 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_called_name_23 = var__build_err_msg;

    frame_function->f_lineno = 510;
    tmp_make_exception_arg_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_23 );
    if ( tmp_make_exception_arg_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 510;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 510;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_4 );
    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 510;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_12:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_actual->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_desired->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_decimal->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_decimal,
                    par_decimal->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_err_msg->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_verbose->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_ndarray )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ndarray,
                    var_ndarray
                );

                assert( res == 0 );
            }

            if ( var_iscomplexobj )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_iscomplexobj,
                    var_iscomplexobj
                );

                assert( res == 0 );
            }

            if ( var_real )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_real,
                    var_real
                );

                assert( res == 0 );
            }

            if ( var_imag )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_imag,
                    var_imag
                );

                assert( res == 0 );
            }

            if ( var_usecomplex )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_usecomplex,
                    var_usecomplex
                );

                assert( res == 0 );
            }

            if ( var__build_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__build_err_msg,
                    var__build_err_msg
                );

                assert( res == 0 );
            }

            if ( var_actualr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actualr,
                    var_actualr
                );

                assert( res == 0 );
            }

            if ( var_actuali )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actuali,
                    var_actuali
                );

                assert( res == 0 );
            }

            if ( var_desiredr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desiredr,
                    var_desiredr
                );

                assert( res == 0 );
            }

            if ( var_desiredi )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desiredi,
                    var_desiredi
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_decimal );
    Py_DECREF( par_decimal );
    par_decimal = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_ndarray );
    Py_DECREF( var_ndarray );
    var_ndarray = NULL;

    CHECK_OBJECT( (PyObject *)var_iscomplexobj );
    Py_DECREF( var_iscomplexobj );
    var_iscomplexobj = NULL;

    CHECK_OBJECT( (PyObject *)var_real );
    Py_DECREF( var_real );
    var_real = NULL;

    CHECK_OBJECT( (PyObject *)var_imag );
    Py_DECREF( var_imag );
    var_imag = NULL;

    Py_XDECREF( var_usecomplex );
    var_usecomplex = NULL;

    CHECK_OBJECT( (PyObject *)var__build_err_msg );
    Py_DECREF( var__build_err_msg );
    var__build_err_msg = NULL;

    Py_XDECREF( var_actualr );
    var_actualr = NULL;

    Py_XDECREF( var_actuali );
    var_actuali = NULL;

    Py_XDECREF( var_desiredr );
    var_desiredr = NULL;

    Py_XDECREF( var_desiredi );
    var_desiredi = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_decimal );
    Py_DECREF( par_decimal );
    par_decimal = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    Py_XDECREF( var_ndarray );
    var_ndarray = NULL;

    Py_XDECREF( var_iscomplexobj );
    var_iscomplexobj = NULL;

    Py_XDECREF( var_real );
    var_real = NULL;

    Py_XDECREF( var_imag );
    var_imag = NULL;

    Py_XDECREF( var_usecomplex );
    var_usecomplex = NULL;

    Py_XDECREF( var__build_err_msg );
    var__build_err_msg = NULL;

    Py_XDECREF( var_actualr );
    var_actualr = NULL;

    Py_XDECREF( var_actuali );
    var_actuali = NULL;

    Py_XDECREF( var_desiredr );
    var_desiredr = NULL;

    Py_XDECREF( var_desiredi );
    var_desiredi = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_header = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_526b6bc1518281356090ffa6209cb91d, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_left_name_1 = const_str_digest_d6b3345eef013f973e768c3ac758531f;
    tmp_right_name_1 = PyCell_GET( self->m_closure[1] );

    if ( tmp_right_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "decimal" );
        exception_tb = NULL;

        exception_lineno = 469;
        goto frame_exception_exit_1;
    }

    tmp_assign_source_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        goto frame_exception_exit_1;
    }
    assert( var_header == NULL );
    var_header = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 470;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = PyList_New( 2 );
    tmp_list_element_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "actual" );
        exception_tb = NULL;

        exception_lineno = 470;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_1, 0, tmp_list_element_1 );
    tmp_list_element_1 = PyCell_GET( self->m_closure[2] );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "desired" );
        exception_tb = NULL;

        exception_lineno = 470;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_1, 1, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = PyCell_GET( self->m_closure[3] );

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 470;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[4] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "verbose" );
        exception_tb = NULL;

        exception_lineno = 470;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = var_header;

    tmp_dict_key_2 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    frame_function->f_lineno = 471;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 471;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( var_header )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_header,
                    var_header
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_decimal,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[3]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    self->m_closure[3]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[4]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    self->m_closure[4]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_header );
    Py_DECREF( var_header );
    var_header = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( var_header );
    var_header = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_16_assert_approx_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_actual = python_pars[ 0 ];
    PyObject *par_desired = python_pars[ 1 ];
    PyObject *par_significant = python_pars[ 2 ];
    PyObject *par_err_msg = python_pars[ 3 ];
    PyObject *par_verbose = python_pars[ 4 ];
    PyObject *var_np = NULL;
    PyObject *var_scale = NULL;
    PyObject *var_sc_desired = NULL;
    PyObject *var_sc_actual = NULL;
    PyObject *var_msg = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_GtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    int tmp_exc_match_exception_match_3;
    int tmp_exc_match_exception_match_4;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_operand_name_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9fc789f06cba154e0a2541c13da7f923, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_significant )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_significant,
            par_significant
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_np )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np
        );

        assert( res == 0 );
    }

    if ( var_scale )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_scale,
            var_scale
        );

        assert( res == 0 );
    }

    if ( var_sc_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_sc_desired,
            var_sc_desired
        );

        assert( res == 0 );
    }

    if ( var_sc_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_sc_actual,
            var_sc_actual
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 570;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 570;
        goto frame_exception_exit_1;
    }
    assert( var_np == NULL );
    var_np = tmp_assign_source_1;

    // Tried code:
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_map );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_1 = LOOKUP_BUILTIN( const_str_plain_float );
    assert( tmp_args_element_name_1 != NULL );
    tmp_args_element_name_2 = PyTuple_New( 2 );
    tmp_tuple_element_1 = par_actual;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_2, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_desired;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_2, 1, tmp_tuple_element_1 );
    frame_function->f_lineno = 572;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 572;
        goto try_except_handler_2;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 572;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 572;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 572;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_2;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_5 = tmp_tuple_unpack_1__element_1;

    {
        PyObject *old = par_actual;
        assert( old != NULL );
        par_actual = tmp_assign_source_5;
        Py_INCREF( par_actual );
        Py_DECREF( old );
    }

    tmp_assign_source_6 = tmp_tuple_unpack_1__element_2;

    {
        PyObject *old = par_desired;
        assert( old != NULL );
        par_desired = tmp_assign_source_6;
        Py_INCREF( par_desired );
        Py_DECREF( old );
    }

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compare_left_1 = par_desired;

    tmp_compare_right_1 = par_actual;

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 573;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    // Tried code:
    tmp_source_name_1 = var_np;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_errstate );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_3;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_d457aeaf5237c8e9bb82fdcc508844e3 );
    frame_function->f_lineno = 577;
    tmp_assign_source_7 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_3;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_7;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_assign_source_8 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_3;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_8;

    tmp_source_name_3 = tmp_with_1__source;

    tmp_called_name_3 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_3;
    }
    frame_function->f_lineno = 577;
    tmp_assign_source_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_3;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_9;

    tmp_assign_source_10 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_10 );
    tmp_with_1__indicator = tmp_assign_source_10;

    // Tried code:
    // Tried code:
    tmp_left_name_1 = const_float_0_5;
    tmp_source_name_4 = var_np;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_abs );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        goto try_except_handler_5;
    }
    tmp_args_element_name_3 = par_desired;

    frame_function->f_lineno = 578;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_left_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        goto try_except_handler_5;
    }
    tmp_source_name_5 = var_np;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_abs );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_2 );

        exception_lineno = 578;
        goto try_except_handler_5;
    }
    tmp_args_element_name_4 = par_actual;

    frame_function->f_lineno = 578;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_right_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_2 );

        exception_lineno = 578;
        goto try_except_handler_5;
    }
    tmp_right_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        goto try_except_handler_5;
    }
    tmp_assign_source_11 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        goto try_except_handler_5;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_11;

    tmp_source_name_6 = var_np;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_power );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        goto try_except_handler_5;
    }
    tmp_args_element_name_5 = const_int_pos_10;
    tmp_source_name_7 = var_np;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_floor );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 579;
        goto try_except_handler_5;
    }
    tmp_source_name_8 = var_np;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_log10 );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 579;
        goto try_except_handler_5;
    }
    tmp_args_element_name_8 = var_scale;

    frame_function->f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_args_element_name_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 579;
        goto try_except_handler_5;
    }
    frame_function->f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 579;
        goto try_except_handler_5;
    }
    frame_function->f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        goto try_except_handler_5;
    }
    {
        PyObject *old = var_scale;
        assert( old != NULL );
        var_scale = tmp_assign_source_12;
        Py_DECREF( old );
    }

    goto try_end_2;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        goto try_except_handler_4;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_13 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_13;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_9 = tmp_with_1__exit;

    tmp_args_element_name_9 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_10 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_11 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_9, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        goto try_except_handler_4;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 579;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_4;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_4;
    branch_end_2:;
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_1 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_10 = tmp_with_1__exit;

    frame_function->f_lineno = 579;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_3 );
        Py_XDECREF( exception_keeper_value_3 );
        Py_XDECREF( exception_keeper_tb_3 );

        exception_lineno = 579;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_3;
    // End of try:
    try_end_3:;
    tmp_compare_left_4 = tmp_with_1__indicator;

    tmp_compare_right_4 = Py_True;
    tmp_is_2 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_11 = tmp_with_1__exit;

    frame_function->f_lineno = 579;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_11, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Tried code:
    tmp_left_name_3 = par_desired;

    tmp_right_name_3 = var_scale;

    if ( tmp_right_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "scale" );
        exception_tb = NULL;

        exception_lineno = 581;
        goto try_except_handler_6;
    }

    tmp_assign_source_14 = BINARY_OPERATION( PyNumber_TrueDivide, tmp_left_name_3, tmp_right_name_3 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 581;
        goto try_except_handler_6;
    }
    assert( var_sc_desired == NULL );
    var_sc_desired = tmp_assign_source_14;

    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_5 == NULL )
    {
        exception_keeper_tb_5 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_5 );
    }
    else if ( exception_keeper_lineno_5 != -1 )
    {
        exception_keeper_tb_5 = ADD_TRACEBACK( exception_keeper_tb_5, frame_function, exception_keeper_lineno_5 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    PUBLISH_EXCEPTION( &exception_keeper_type_5, &exception_keeper_value_5, &exception_keeper_tb_5 );
    tmp_compare_left_5 = PyThreadState_GET()->exc_type;
    tmp_compare_right_5 = PyExc_ZeroDivisionError;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 582;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_assign_source_15 = const_float_0_0;
    assert( var_sc_desired == NULL );
    Py_INCREF( tmp_assign_source_15 );
    var_sc_desired = tmp_assign_source_15;

    goto branch_end_6;
    branch_no_6:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_6:;
    goto try_end_5;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_5:;
    // Tried code:
    tmp_left_name_4 = par_actual;

    tmp_right_name_4 = var_scale;

    if ( tmp_right_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "scale" );
        exception_tb = NULL;

        exception_lineno = 585;
        goto try_except_handler_7;
    }

    tmp_assign_source_16 = BINARY_OPERATION( PyNumber_TrueDivide, tmp_left_name_4, tmp_right_name_4 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 585;
        goto try_except_handler_7;
    }
    assert( var_sc_actual == NULL );
    var_sc_actual = tmp_assign_source_16;

    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_6 == NULL )
    {
        exception_keeper_tb_6 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_6 );
    }
    else if ( exception_keeper_lineno_6 != -1 )
    {
        exception_keeper_tb_6 = ADD_TRACEBACK( exception_keeper_tb_6, frame_function, exception_keeper_lineno_6 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    PUBLISH_EXCEPTION( &exception_keeper_type_6, &exception_keeper_value_6, &exception_keeper_tb_6 );
    tmp_compare_left_6 = PyThreadState_GET()->exc_type;
    tmp_compare_right_6 = PyExc_ZeroDivisionError;
    tmp_exc_match_exception_match_3 = EXCEPTION_MATCH_BOOL( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_exc_match_exception_match_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 586;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_3 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_assign_source_17 = const_float_0_0;
    assert( var_sc_actual == NULL );
    Py_INCREF( tmp_assign_source_17 );
    var_sc_actual = tmp_assign_source_17;

    goto branch_end_7;
    branch_no_7:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_7:;
    goto try_end_6;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_6:;
    tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_12 == NULL ))
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 588;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_2 = PyList_New( 2 );
    tmp_list_element_1 = par_actual;

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_2, 0, tmp_list_element_1 );
    tmp_list_element_1 = par_desired;

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_2, 1, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = par_err_msg;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_left_name_5 = const_str_digest_1f4842fd9edf1f66aa4685a11b6b5629;
    tmp_right_name_5 = par_significant;

    tmp_dict_value_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 589;
        goto frame_exception_exit_1;
    }
    tmp_dict_key_1 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    tmp_dict_value_2 = par_verbose;

    tmp_dict_key_2 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    frame_function->f_lineno = 591;
    tmp_assign_source_18 = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_1, tmp_kw_name_2 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_18;

    // Tried code:
    tmp_called_name_13 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_13 == NULL ))
    {
        tmp_called_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 596;
        goto try_except_handler_8;
    }

    tmp_args_element_name_12 = par_desired;

    frame_function->f_lineno = 596;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_and_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 596;
        goto try_except_handler_8;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 596;
        goto try_except_handler_8;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite );

    if (unlikely( tmp_called_name_14 == NULL ))
    {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisfinite );
    }

    if ( tmp_called_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisfinite" );
        exception_tb = NULL;

        exception_lineno = 596;
        goto try_except_handler_8;
    }

    tmp_args_element_name_13 = par_actual;

    frame_function->f_lineno = 596;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_and_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 596;
        goto try_except_handler_8;
    }
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 596;
        goto try_except_handler_8;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_called_name_15 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_15 == NULL ))
    {
        tmp_called_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 597;
        goto try_except_handler_8;
    }

    tmp_args_element_name_14 = par_desired;

    frame_function->f_lineno = 597;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 597;
        goto try_except_handler_8;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 597;
        goto try_except_handler_8;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_16 == NULL ))
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 597;
        goto try_except_handler_8;
    }

    tmp_args_element_name_15 = par_actual;

    frame_function->f_lineno = 597;
    {
        PyObject *call_args[] = { tmp_args_element_name_15 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
    }

    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 597;
        goto try_except_handler_8;
    }
    tmp_cond_value_3 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_3 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 597;
        goto try_except_handler_8;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 598;
        goto try_except_handler_8;
    }

    tmp_args_element_name_16 = par_desired;

    frame_function->f_lineno = 598;
    {
        PyObject *call_args[] = { tmp_args_element_name_16 };
        tmp_and_left_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 598;
        goto try_except_handler_8;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 598;
        goto try_except_handler_8;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_called_name_18 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan );

    if (unlikely( tmp_called_name_18 == NULL ))
    {
        tmp_called_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisnan );
    }

    if ( tmp_called_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisnan" );
        exception_tb = NULL;

        exception_lineno = 598;
        goto try_except_handler_8;
    }

    tmp_args_element_name_17 = par_actual;

    frame_function->f_lineno = 598;
    {
        PyObject *call_args[] = { tmp_args_element_name_17 };
        tmp_and_right_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 598;
        goto try_except_handler_8;
    }
    tmp_cond_value_4 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_cond_value_4 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 598;
        goto try_except_handler_8;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_no_10;
    }
    else
    {
        goto branch_yes_10;
    }
    branch_yes_10:;
    tmp_make_exception_arg_1 = var_msg;

    frame_function->f_lineno = 599;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 599;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_8;
    branch_no_10:;
    goto branch_end_9;
    branch_no_9:;
    tmp_compare_left_7 = par_desired;

    tmp_compare_right_7 = par_actual;

    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;
        goto try_except_handler_8;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_no_11;
    }
    else
    {
        goto branch_yes_11;
    }
    branch_yes_11:;
    tmp_make_exception_arg_2 = var_msg;

    frame_function->f_lineno = 602;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 602;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_8;
    branch_no_11:;
    branch_end_9:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_8:;
    goto try_end_7;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_7 == NULL )
    {
        exception_keeper_tb_7 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_7 );
    }
    else if ( exception_keeper_lineno_7 != -1 )
    {
        exception_keeper_tb_7 = ADD_TRACEBACK( exception_keeper_tb_7, frame_function, exception_keeper_lineno_7 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    PUBLISH_EXCEPTION( &exception_keeper_type_7, &exception_keeper_value_7, &exception_keeper_tb_7 );
    tmp_compare_left_8 = PyThreadState_GET()->exc_type;
    tmp_compare_right_8 = PyTuple_New( 2 );
    tmp_tuple_element_3 = PyExc_TypeError;
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_compare_right_8, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = PyExc_NotImplementedError;
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_compare_right_8, 1, tmp_tuple_element_3 );
    tmp_exc_match_exception_match_4 = EXCEPTION_MATCH_BOOL( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_exc_match_exception_match_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_8 );

        exception_lineno = 604;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_8 );
    if ( tmp_exc_match_exception_match_4 == 1 )
    {
        goto branch_no_12;
    }
    else
    {
        goto branch_yes_12;
    }
    branch_yes_12:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_no_12:;
    goto try_end_7;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_7:;
    tmp_source_name_9 = var_np;

    tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_abs );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    tmp_left_name_6 = var_sc_desired;

    if ( tmp_left_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "sc_desired" );
        exception_tb = NULL;

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }

    tmp_right_name_6 = var_sc_actual;

    if ( tmp_right_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "sc_actual" );
        exception_tb = NULL;

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = BINARY_OPERATION_SUB( tmp_left_name_6, tmp_right_name_6 );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 606;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_compare_left_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_called_name_19 );
    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_compare_left_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    tmp_source_name_10 = var_np;

    tmp_called_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_power );
    if ( tmp_called_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_19 = const_float_10_0;
    tmp_left_name_7 = par_significant;

    tmp_right_name_7 = const_int_pos_1;
    tmp_operand_name_1 = BINARY_OPERATION_SUB( tmp_left_name_7, tmp_right_name_7 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );
        Py_DECREF( tmp_called_name_20 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_20 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_args_element_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );
        Py_DECREF( tmp_called_name_20 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 606;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_compare_right_9 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_called_name_20 );
    Py_DECREF( tmp_args_element_name_20 );
    if ( tmp_compare_right_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    tmp_cmp_GtE_1 = RICH_COMPARE_BOOL_GE( tmp_compare_left_9, tmp_compare_right_9 );
    if ( tmp_cmp_GtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );
        Py_DECREF( tmp_compare_right_9 );

        exception_lineno = 606;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_9 );
    Py_DECREF( tmp_compare_right_9 );
    if ( tmp_cmp_GtE_1 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_make_exception_arg_3 = var_msg;

    frame_function->f_lineno = 607;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 607;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_13:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual
                );

                assert( res == 0 );
            }

            if ( par_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired
                );

                assert( res == 0 );
            }

            if ( par_significant )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_significant,
                    par_significant
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }

            if ( var_np )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np
                );

                assert( res == 0 );
            }

            if ( var_scale )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_scale,
                    var_scale
                );

                assert( res == 0 );
            }

            if ( var_sc_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_sc_desired,
                    var_sc_desired
                );

                assert( res == 0 );
            }

            if ( var_sc_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_sc_actual,
                    var_sc_actual
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_significant );
    Py_DECREF( par_significant );
    par_significant = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_sc_desired );
    var_sc_desired = NULL;

    Py_XDECREF( var_sc_actual );
    var_sc_actual = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_significant );
    Py_DECREF( par_significant );
    par_significant = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_sc_desired );
    var_sc_desired = NULL;

    Py_XDECREF( var_sc_actual );
    var_sc_actual = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_16_assert_approx_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_17_assert_array_compare_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyCellObject *par_comparison = PyCell_NEW1( python_pars[ 0 ] );
    PyCellObject *par_x = PyCell_NEW1( python_pars[ 1 ] );
    PyCellObject *par_y = PyCell_NEW1( python_pars[ 2 ] );
    PyCellObject *par_err_msg = PyCell_NEW1( python_pars[ 3 ] );
    PyCellObject *par_verbose = PyCell_NEW1( python_pars[ 4 ] );
    PyCellObject *par_header = PyCell_NEW1( python_pars[ 5 ] );
    PyCellObject *par_precision = PyCell_NEW1( python_pars[ 6 ] );
    PyObject *var_array = NULL;
    PyObject *var_isnan = NULL;
    PyObject *var_isinf = NULL;
    PyObject *var_any = NULL;
    PyObject *var_all = NULL;
    PyObject *var_inf = NULL;
    PyObject *var_safe_comparison = NULL;
    PyObject *var_isnumber = NULL;
    PyObject *var_chk_same_position = NULL;
    PyObject *var_cond = NULL;
    PyObject *var_msg = NULL;
    PyObject *var_x_isnan = NULL;
    PyObject *var_y_isnan = NULL;
    PyObject *var_x_isinf = NULL;
    PyObject *var_y_isinf = NULL;
    PyObject *var_x_id = NULL;
    PyObject *var_y_id = NULL;
    PyObject *var_val = NULL;
    PyObject *var_reduced = NULL;
    PyObject *var_match = NULL;
    PyObject *var_traceback = NULL;
    PyObject *var_efmt = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *tmp_tuple_unpack_3__source_iter = NULL;
    PyObject *tmp_tuple_unpack_3__element_1 = NULL;
    PyObject *tmp_tuple_unpack_3__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_args_name_3;
    PyObject *tmp_args_name_4;
    PyObject *tmp_args_name_5;
    PyObject *tmp_args_name_6;
    PyObject *tmp_args_name_7;
    PyObject *tmp_args_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_left_7;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    PyObject *tmp_compexpr_right_7;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_defaults_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_key_10;
    PyObject *tmp_dict_key_11;
    PyObject *tmp_dict_key_12;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_dict_value_10;
    PyObject *tmp_dict_value_11;
    PyObject *tmp_dict_value_12;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_globals_4;
    PyObject *tmp_import_globals_5;
    PyObject *tmp_import_globals_6;
    PyObject *tmp_import_globals_7;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_locals_3;
    PyObject *tmp_import_locals_4;
    PyObject *tmp_import_locals_5;
    PyObject *tmp_import_locals_6;
    PyObject *tmp_import_locals_7;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_iterator_name_2;
    PyObject *tmp_iterator_name_3;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_kw_name_4;
    PyObject *tmp_kw_name_5;
    PyObject *tmp_kw_name_6;
    PyObject *tmp_kw_name_7;
    PyObject *tmp_kw_name_8;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_list_element_3;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    PyObject *tmp_operand_name_3;
    PyObject *tmp_operand_name_4;
    PyObject *tmp_operand_name_5;
    PyObject *tmp_operand_name_6;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    int tmp_or_left_truth_3;
    int tmp_or_left_truth_4;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_left_value_3;
    PyObject *tmp_or_left_value_4;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_or_right_value_3;
    PyObject *tmp_or_right_value_4;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyObject *tmp_tuple_element_9;
    PyObject *tmp_tuple_element_10;
    PyObject *tmp_tuple_element_11;
    PyObject *tmp_tuple_element_12;
    PyObject *tmp_tuple_element_13;
    PyObject *tmp_tuple_element_14;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_unpack_3;
    PyObject *tmp_unpack_4;
    PyObject *tmp_unpack_5;
    PyObject *tmp_unpack_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cf7e4fb007c611d7dea94190d4a66a81, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_array );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_array == NULL );
    var_array = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_isnan );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_isnan == NULL );
    var_isnan = tmp_assign_source_2;

    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_3 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_3 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_3, tmp_import_locals_3, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_3 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_isinf );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_isinf == NULL );
    var_isinf = tmp_assign_source_3;

    tmp_import_globals_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_4 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_4 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_4, tmp_import_locals_4, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_4 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_any );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_any == NULL );
    var_any = tmp_assign_source_4;

    tmp_import_globals_5 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_5 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_5 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_5, tmp_import_locals_5, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_5 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_all );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_all == NULL );
    var_all = tmp_assign_source_5;

    tmp_import_globals_6 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_6 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 611;
    tmp_import_name_from_6 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_6, tmp_import_locals_6, const_tuple_194a86e43e0cb7c7c00eac0bfd665f10_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_6 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_inf );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        goto frame_exception_exit_1;
    }
    assert( var_inf == NULL );
    var_inf = tmp_assign_source_6;

    tmp_called_name_1 = var_array;

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyCell_GET( par_x );

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 612;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_a00acf95180a0925f15877b623331589 );
    frame_function->f_lineno = 612;
    tmp_assign_source_7 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( par_x );
        PyCell_SET( par_x, tmp_assign_source_7 );
        Py_XDECREF( old );
    }

    tmp_called_name_2 = var_array;

    tmp_args_name_2 = PyTuple_New( 1 );
    tmp_tuple_element_2 = PyCell_GET( par_y );

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_args_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 613;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_2 );
    tmp_kw_name_2 = PyDict_Copy( const_dict_a00acf95180a0925f15877b623331589 );
    frame_function->f_lineno = 613;
    tmp_assign_source_8 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 613;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( par_y );
        PyCell_SET( par_y, tmp_assign_source_8 );
        Py_XDECREF( old );
    }

    tmp_assign_source_9 = MAKE_FUNCTION_function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils( par_comparison );
    assert( var_safe_comparison == NULL );
    var_safe_comparison = tmp_assign_source_9;

    tmp_assign_source_10 = MAKE_FUNCTION_function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils(  );
    assert( var_isnumber == NULL );
    var_isnumber = tmp_assign_source_10;

    tmp_defaults_1 = const_tuple_str_plain_nan_tuple;
    tmp_assign_source_11 = MAKE_FUNCTION_function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ), par_err_msg, par_header, par_precision, par_verbose, par_x, par_y );
    assert( var_chk_same_position == NULL );
    var_chk_same_position = tmp_assign_source_11;

    // Tried code:
    tmp_source_name_1 = PyCell_GET( par_x );

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 654;
        goto try_except_handler_2;
    }

    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_shape );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_compexpr_right_1 = const_tuple_empty;
    tmp_or_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_2 );

        exception_lineno = 654;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    Py_DECREF( tmp_or_left_value_2 );
    tmp_source_name_2 = PyCell_GET( par_y );

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 654;
        goto try_except_handler_2;
    }

    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_shape );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_compexpr_right_2 = const_tuple_empty;
    tmp_or_right_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_or_left_value_1 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_or_left_value_1 = tmp_or_left_value_2;
    or_end_2:;
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 654;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_3 = PyCell_GET( par_x );

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 654;
        goto try_except_handler_2;
    }

    tmp_compexpr_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_shape );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_source_name_4 = PyCell_GET( par_y );

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 654;
        goto try_except_handler_2;
    }

    tmp_compexpr_right_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_shape );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_3 );

        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_or_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        goto try_except_handler_2;
    }
    tmp_assign_source_12 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_assign_source_12 = tmp_or_left_value_1;
    or_end_1:;
    assert( var_cond == NULL );
    var_cond = tmp_assign_source_12;

    tmp_cond_value_1 = var_cond;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 656;
        goto try_except_handler_2;
    }

    tmp_args_name_3 = PyTuple_New( 2 );
    tmp_tuple_element_3 = PyList_New( 2 );
    tmp_list_element_1 = PyCell_GET( par_x );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_tuple_element_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 656;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_3, 0, tmp_list_element_1 );
    tmp_list_element_1 = PyCell_GET( par_y );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_tuple_element_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 656;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_3, 1, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_3, 0, tmp_tuple_element_3 );
    tmp_left_name_1 = PyCell_GET( par_err_msg );

    if ( tmp_left_name_1 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 657;
        goto try_except_handler_2;
    }

    tmp_left_name_2 = const_str_digest_1640eb8691b27b74c67f931efa0239c2;
    tmp_right_name_2 = PyTuple_New( 2 );
    tmp_source_name_5 = PyCell_GET( par_x );

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_right_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 658;
        goto try_except_handler_2;
    }

    tmp_tuple_element_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_shape );
    if ( tmp_tuple_element_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_right_name_2 );

        exception_lineno = 658;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_4 );
    tmp_source_name_6 = PyCell_GET( par_y );

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_right_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 659;
        goto try_except_handler_2;
    }

    tmp_tuple_element_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_shape );
    if ( tmp_tuple_element_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_right_name_2 );

        exception_lineno = 659;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_4 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_3 );

        exception_lineno = 658;
        goto try_except_handler_2;
    }
    tmp_tuple_element_3 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_tuple_element_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_3 );

        exception_lineno = 657;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_3, 1, tmp_tuple_element_3 );
    tmp_kw_name_3 = _PyDict_NewPresized( 4 );
    tmp_dict_value_1 = PyCell_GET( par_verbose );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "verbose" );
        exception_tb = NULL;

        exception_lineno = 660;
        goto try_except_handler_2;
    }

    tmp_dict_key_1 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = PyCell_GET( par_header );

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "header" );
        exception_tb = NULL;

        exception_lineno = 660;
        goto try_except_handler_2;
    }

    tmp_dict_key_2 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = const_tuple_str_plain_x_str_plain_y_tuple;
    tmp_dict_key_3 = const_str_plain_names;
    PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_3, tmp_dict_value_3 );
    tmp_dict_value_4 = PyCell_GET( par_precision );

    if ( tmp_dict_value_4 == NULL )
    {
        Py_DECREF( tmp_args_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "precision" );
        exception_tb = NULL;

        exception_lineno = 661;
        goto try_except_handler_2;
    }

    tmp_dict_key_4 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_4, tmp_dict_value_4 );
    frame_function->f_lineno = 661;
    tmp_assign_source_13 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_3, tmp_kw_name_3 );
    Py_DECREF( tmp_args_name_3 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 661;
        goto try_except_handler_2;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_13;

    tmp_cond_value_2 = var_cond;

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 662;
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = var_msg;

    frame_function->f_lineno = 663;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 663;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_2;
    branch_no_2:;
    branch_no_1:;
    tmp_called_name_4 = var_isnumber;

    tmp_args_element_name_1 = PyCell_GET( par_x );

    if ( tmp_args_element_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 665;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 665;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_and_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;
        goto try_except_handler_2;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 665;
        goto try_except_handler_2;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_called_name_5 = var_isnumber;

    tmp_args_element_name_2 = PyCell_GET( par_y );

    if ( tmp_args_element_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 665;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 665;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_and_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;
        goto try_except_handler_2;
    }
    tmp_cond_value_3 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_3 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 665;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    // Tried code:
    tmp_iter_arg_1 = PyTuple_New( 2 );
    tmp_called_name_6 = var_isnan;

    tmp_args_element_name_3 = PyCell_GET( par_x );

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_iter_arg_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 666;
        goto try_except_handler_3;
    }

    frame_function->f_lineno = 666;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_tuple_element_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 666;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 0, tmp_tuple_element_5 );
    tmp_called_name_7 = var_isnan;

    tmp_args_element_name_4 = PyCell_GET( par_y );

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_iter_arg_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 666;
        goto try_except_handler_3;
    }

    frame_function->f_lineno = 666;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_tuple_element_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 666;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 1, tmp_tuple_element_5 );
    tmp_assign_source_14 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 666;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_14;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_15 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_15 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 666;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_15;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_16 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_16 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 666;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_16;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_3;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    tmp_assign_source_17 = tmp_tuple_unpack_1__element_1;

    assert( var_x_isnan == NULL );
    Py_INCREF( tmp_assign_source_17 );
    var_x_isnan = tmp_assign_source_17;

    tmp_assign_source_18 = tmp_tuple_unpack_1__element_2;

    assert( var_y_isnan == NULL );
    Py_INCREF( tmp_assign_source_18 );
    var_y_isnan = tmp_assign_source_18;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Tried code:
    tmp_iter_arg_2 = PyTuple_New( 2 );
    tmp_called_name_8 = var_isinf;

    tmp_args_element_name_5 = PyCell_GET( par_x );

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_iter_arg_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 667;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 667;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_tuple_element_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    if ( tmp_tuple_element_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_2 );

        exception_lineno = 667;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_2, 0, tmp_tuple_element_6 );
    tmp_called_name_9 = var_isinf;

    tmp_args_element_name_6 = PyCell_GET( par_y );

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_iter_arg_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 667;
        goto try_except_handler_4;
    }

    frame_function->f_lineno = 667;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_tuple_element_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    if ( tmp_tuple_element_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_2 );

        exception_lineno = 667;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_2, 1, tmp_tuple_element_6 );
    tmp_assign_source_19 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 667;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_2__source_iter == NULL );
    tmp_tuple_unpack_2__source_iter = tmp_assign_source_19;

    tmp_unpack_3 = tmp_tuple_unpack_2__source_iter;

    tmp_assign_source_20 = UNPACK_NEXT( tmp_unpack_3, 0 );
    if ( tmp_assign_source_20 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 667;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_2__element_1 == NULL );
    tmp_tuple_unpack_2__element_1 = tmp_assign_source_20;

    tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;

    tmp_assign_source_21 = UNPACK_NEXT( tmp_unpack_4, 1 );
    if ( tmp_assign_source_21 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 667;
        goto try_except_handler_4;
    }
    assert( tmp_tuple_unpack_2__element_2 == NULL );
    tmp_tuple_unpack_2__element_2 = tmp_assign_source_21;

    tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_4;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_4;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_assign_source_22 = tmp_tuple_unpack_2__element_1;

    assert( var_x_isinf == NULL );
    Py_INCREF( tmp_assign_source_22 );
    var_x_isinf = tmp_assign_source_22;

    tmp_assign_source_23 = tmp_tuple_unpack_2__element_2;

    assert( var_y_isinf == NULL );
    Py_INCREF( tmp_assign_source_23 );
    var_y_isinf = tmp_assign_source_23;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__element_1 );
    Py_DECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__element_2 );
    Py_DECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    tmp_called_name_10 = var_any;

    tmp_args_element_name_7 = var_x_isnan;

    frame_function->f_lineno = 670;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_or_left_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    if ( tmp_or_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        goto try_except_handler_2;
    }
    tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
    if ( tmp_or_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_3 );

        exception_lineno = 670;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_3 == 1 )
    {
        goto or_left_3;
    }
    else
    {
        goto or_right_3;
    }
    or_right_3:;
    Py_DECREF( tmp_or_left_value_3 );
    tmp_called_name_11 = var_any;

    tmp_args_element_name_8 = var_y_isnan;

    frame_function->f_lineno = 670;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_or_right_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    if ( tmp_or_right_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        goto try_except_handler_2;
    }
    tmp_cond_value_4 = tmp_or_right_value_3;
    goto or_end_3;
    or_left_3:;
    tmp_cond_value_4 = tmp_or_left_value_3;
    or_end_3:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 670;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_12 = var_chk_same_position;

    tmp_args_name_4 = PyTuple_New( 2 );
    tmp_tuple_element_7 = var_x_isnan;

    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_7 );
    tmp_tuple_element_7 = var_y_isnan;

    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_4, 1, tmp_tuple_element_7 );
    tmp_kw_name_4 = PyDict_Copy( const_dict_568ac7eccabc8d891d945f2840f427e7 );
    frame_function->f_lineno = 671;
    tmp_unused = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_4, tmp_kw_name_4 );
    Py_DECREF( tmp_args_name_4 );
    Py_DECREF( tmp_kw_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_called_name_13 = var_any;

    tmp_args_element_name_9 = var_x_isinf;

    frame_function->f_lineno = 672;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_or_left_value_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    if ( tmp_or_left_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 672;
        goto try_except_handler_2;
    }
    tmp_or_left_truth_4 = CHECK_IF_TRUE( tmp_or_left_value_4 );
    if ( tmp_or_left_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_4 );

        exception_lineno = 672;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_4 == 1 )
    {
        goto or_left_4;
    }
    else
    {
        goto or_right_4;
    }
    or_right_4:;
    Py_DECREF( tmp_or_left_value_4 );
    tmp_called_name_14 = var_any;

    tmp_args_element_name_10 = var_y_isinf;

    frame_function->f_lineno = 672;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_or_right_value_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    if ( tmp_or_right_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 672;
        goto try_except_handler_2;
    }
    tmp_cond_value_5 = tmp_or_right_value_4;
    goto or_end_4;
    or_left_4:;
    tmp_cond_value_5 = tmp_or_left_value_4;
    or_end_4:;
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 672;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_15 = var_chk_same_position;

    tmp_args_name_5 = PyTuple_New( 2 );
    tmp_compexpr_left_4 = PyCell_GET( par_x );

    if ( tmp_compexpr_left_4 == NULL )
    {
        Py_DECREF( tmp_args_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 674;
        goto try_except_handler_2;
    }

    tmp_operand_name_1 = var_inf;

    tmp_compexpr_right_4 = UNARY_OPERATION( PyNumber_Positive, tmp_operand_name_1 );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_5 );

        exception_lineno = 674;
        goto try_except_handler_2;
    }
    tmp_tuple_element_8 = RICH_COMPARE_EQ( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_tuple_element_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_5 );

        exception_lineno = 674;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_5, 0, tmp_tuple_element_8 );
    tmp_compexpr_left_5 = PyCell_GET( par_y );

    if ( tmp_compexpr_left_5 == NULL )
    {
        Py_DECREF( tmp_args_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 674;
        goto try_except_handler_2;
    }

    tmp_operand_name_2 = var_inf;

    tmp_compexpr_right_5 = UNARY_OPERATION( PyNumber_Positive, tmp_operand_name_2 );
    if ( tmp_compexpr_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_5 );

        exception_lineno = 674;
        goto try_except_handler_2;
    }
    tmp_tuple_element_8 = RICH_COMPARE_EQ( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    Py_DECREF( tmp_compexpr_right_5 );
    if ( tmp_tuple_element_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_5 );

        exception_lineno = 674;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_5, 1, tmp_tuple_element_8 );
    tmp_kw_name_5 = PyDict_Copy( const_dict_ff8ef3bf3e81fbdb8830624987bd4652 );
    frame_function->f_lineno = 674;
    tmp_unused = CALL_FUNCTION( tmp_called_name_15, tmp_args_name_5, tmp_kw_name_5 );
    Py_DECREF( tmp_args_name_5 );
    Py_DECREF( tmp_kw_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_16 = var_chk_same_position;

    tmp_args_name_6 = PyTuple_New( 2 );
    tmp_compexpr_left_6 = PyCell_GET( par_x );

    if ( tmp_compexpr_left_6 == NULL )
    {
        Py_DECREF( tmp_args_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 675;
        goto try_except_handler_2;
    }

    tmp_operand_name_3 = var_inf;

    tmp_compexpr_right_6 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_3 );
    if ( tmp_compexpr_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_6 );

        exception_lineno = 675;
        goto try_except_handler_2;
    }
    tmp_tuple_element_9 = RICH_COMPARE_EQ( tmp_compexpr_left_6, tmp_compexpr_right_6 );
    Py_DECREF( tmp_compexpr_right_6 );
    if ( tmp_tuple_element_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_6 );

        exception_lineno = 675;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_6, 0, tmp_tuple_element_9 );
    tmp_compexpr_left_7 = PyCell_GET( par_y );

    if ( tmp_compexpr_left_7 == NULL )
    {
        Py_DECREF( tmp_args_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 675;
        goto try_except_handler_2;
    }

    tmp_operand_name_4 = var_inf;

    tmp_compexpr_right_7 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_4 );
    if ( tmp_compexpr_right_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_6 );

        exception_lineno = 675;
        goto try_except_handler_2;
    }
    tmp_tuple_element_9 = RICH_COMPARE_EQ( tmp_compexpr_left_7, tmp_compexpr_right_7 );
    Py_DECREF( tmp_compexpr_right_7 );
    if ( tmp_tuple_element_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_6 );

        exception_lineno = 675;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_6, 1, tmp_tuple_element_9 );
    tmp_kw_name_6 = PyDict_Copy( const_dict_117eec822878c8a1e3d3fe65ec8106fd );
    frame_function->f_lineno = 675;
    tmp_unused = CALL_FUNCTION( tmp_called_name_16, tmp_args_name_6, tmp_kw_name_6 );
    Py_DECREF( tmp_args_name_6 );
    Py_DECREF( tmp_kw_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 675;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    tmp_iter_arg_3 = PyTuple_New( 2 );
    tmp_tuple_element_10 = var_x_isnan;

    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_iter_arg_3, 0, tmp_tuple_element_10 );
    tmp_tuple_element_10 = var_y_isnan;

    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_iter_arg_3, 1, tmp_tuple_element_10 );
    tmp_assign_source_24 = MAKE_ITERATOR( tmp_iter_arg_3 );
    Py_DECREF( tmp_iter_arg_3 );
    assert( tmp_assign_source_24 != NULL );
    assert( tmp_tuple_unpack_3__source_iter == NULL );
    tmp_tuple_unpack_3__source_iter = tmp_assign_source_24;

    // Tried code:
    tmp_unpack_5 = tmp_tuple_unpack_3__source_iter;

    tmp_assign_source_25 = UNPACK_NEXT( tmp_unpack_5, 0 );
    if ( tmp_assign_source_25 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 678;
        goto try_except_handler_5;
    }
    assert( tmp_tuple_unpack_3__element_1 == NULL );
    tmp_tuple_unpack_3__element_1 = tmp_assign_source_25;

    tmp_unpack_6 = tmp_tuple_unpack_3__source_iter;

    tmp_assign_source_26 = UNPACK_NEXT( tmp_unpack_6, 1 );
    if ( tmp_assign_source_26 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 678;
        goto try_except_handler_5;
    }
    assert( tmp_tuple_unpack_3__element_2 == NULL );
    tmp_tuple_unpack_3__element_2 = tmp_assign_source_26;

    tmp_iterator_name_3 = tmp_tuple_unpack_3__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_3 ); assert( HAS_ITERNEXT( tmp_iterator_name_3 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_3 )->tp_iternext)( tmp_iterator_name_3 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_5;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_2;
    // End of try:
    try_end_3:;
    tmp_assign_source_27 = tmp_tuple_unpack_3__element_1;

    assert( var_x_id == NULL );
    Py_INCREF( tmp_assign_source_27 );
    var_x_id = tmp_assign_source_27;

    tmp_assign_source_28 = tmp_tuple_unpack_3__element_2;

    assert( var_y_id == NULL );
    Py_INCREF( tmp_assign_source_28 );
    var_y_id = tmp_assign_source_28;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__source_iter );
    Py_DECREF( tmp_tuple_unpack_3__source_iter );
    tmp_tuple_unpack_3__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__element_1 );
    Py_DECREF( tmp_tuple_unpack_3__element_1 );
    tmp_tuple_unpack_3__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_3__element_2 );
    Py_DECREF( tmp_tuple_unpack_3__element_2 );
    tmp_tuple_unpack_3__element_2 = NULL;

    tmp_left_name_3 = var_x_id;

    tmp_right_name_3 = var_x_isinf;

    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceOr, &tmp_left_name_3, tmp_right_name_3 );
    tmp_assign_source_29 = tmp_left_name_3;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 679;
        goto try_except_handler_2;
    }
    var_x_id = tmp_assign_source_29;

    tmp_left_name_4 = var_y_id;

    tmp_right_name_4 = var_y_isinf;

    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceOr, &tmp_left_name_4, tmp_right_name_4 );
    tmp_assign_source_30 = tmp_left_name_4;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 680;
        goto try_except_handler_2;
    }
    var_y_id = tmp_assign_source_30;

    tmp_called_name_17 = var_all;

    tmp_args_element_name_11 = var_x_id;

    frame_function->f_lineno = 683;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_cond_value_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    if ( tmp_cond_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 683;
        goto try_except_handler_2;
    }
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 683;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_6:;
    tmp_called_name_18 = var_any;

    tmp_args_element_name_12 = var_x_id;

    frame_function->f_lineno = 686;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_cond_value_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    if ( tmp_cond_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        goto try_except_handler_2;
    }
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 686;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_name_19 = var_safe_comparison;

    tmp_subscribed_name_1 = PyCell_GET( par_x );

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 687;
        goto try_except_handler_2;
    }

    tmp_operand_name_5 = var_x_id;

    tmp_subscript_name_1 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_5 );
    if ( tmp_subscript_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        goto try_except_handler_2;
    }
    tmp_args_element_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscript_name_1 );
    if ( tmp_args_element_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        goto try_except_handler_2;
    }
    tmp_subscribed_name_2 = PyCell_GET( par_y );

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_args_element_name_13 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 687;
        goto try_except_handler_2;
    }

    tmp_operand_name_6 = var_y_id;

    tmp_subscript_name_2 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_6 );
    if ( tmp_subscript_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 687;
        goto try_except_handler_2;
    }
    tmp_args_element_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscript_name_2 );
    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_13 );

        exception_lineno = 687;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 687;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_assign_source_31 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_args_element_name_13 );
    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        goto try_except_handler_2;
    }
    assert( var_val == NULL );
    var_val = tmp_assign_source_31;

    goto branch_end_7;
    branch_no_7:;
    tmp_called_name_20 = var_safe_comparison;

    tmp_args_element_name_15 = PyCell_GET( par_x );

    if ( tmp_args_element_name_15 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 689;
        goto try_except_handler_2;
    }

    tmp_args_element_name_16 = PyCell_GET( par_y );

    if ( tmp_args_element_name_16 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 689;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 689;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_assign_source_32 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_20, call_args );
    }

    if ( tmp_assign_source_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        goto try_except_handler_2;
    }
    assert( var_val == NULL );
    var_val = tmp_assign_source_32;

    branch_end_7:;
    goto branch_end_3;
    branch_no_3:;
    tmp_called_name_21 = var_safe_comparison;

    tmp_args_element_name_17 = PyCell_GET( par_x );

    if ( tmp_args_element_name_17 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 691;
        goto try_except_handler_2;
    }

    tmp_args_element_name_18 = PyCell_GET( par_y );

    if ( tmp_args_element_name_18 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 691;
        goto try_except_handler_2;
    }

    frame_function->f_lineno = 691;
    {
        PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_33 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_21, call_args );
    }

    if ( tmp_assign_source_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        goto try_except_handler_2;
    }
    assert( var_val == NULL );
    var_val = tmp_assign_source_33;

    branch_end_3:;
    tmp_isinstance_inst_1 = var_val;

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "val" );
        exception_tb = NULL;

        exception_lineno = 693;
        goto try_except_handler_2;
    }

    tmp_isinstance_cls_1 = LOOKUP_BUILTIN( const_str_plain_bool );
    assert( tmp_isinstance_cls_1 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_assign_source_34 = var_val;

    if ( tmp_assign_source_34 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "val" );
        exception_tb = NULL;

        exception_lineno = 694;
        goto try_except_handler_2;
    }

    {
        PyObject *old = var_cond;
        assert( old != NULL );
        var_cond = tmp_assign_source_34;
        Py_INCREF( var_cond );
        Py_DECREF( old );
    }

    tmp_assign_source_35 = LIST_COPY( const_list_int_0_list );
    assert( var_reduced == NULL );
    var_reduced = tmp_assign_source_35;

    goto branch_end_8;
    branch_no_8:;
    tmp_source_name_7 = var_val;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "val" );
        exception_tb = NULL;

        exception_lineno = 697;
        goto try_except_handler_2;
    }

    tmp_called_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_ravel );
    if ( tmp_called_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 697;
    tmp_assign_source_36 = CALL_FUNCTION_NO_ARGS( tmp_called_name_22 );
    Py_DECREF( tmp_called_name_22 );
    if ( tmp_assign_source_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        goto try_except_handler_2;
    }
    assert( var_reduced == NULL );
    var_reduced = tmp_assign_source_36;

    tmp_source_name_8 = var_reduced;

    tmp_called_name_23 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_all );
    if ( tmp_called_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 698;
    tmp_assign_source_37 = CALL_FUNCTION_NO_ARGS( tmp_called_name_23 );
    Py_DECREF( tmp_called_name_23 );
    if ( tmp_assign_source_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_cond;
        assert( old != NULL );
        var_cond = tmp_assign_source_37;
        Py_DECREF( old );
    }

    tmp_source_name_9 = var_reduced;

    tmp_called_name_24 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_tolist );
    if ( tmp_called_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 699;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 699;
    tmp_assign_source_38 = CALL_FUNCTION_NO_ARGS( tmp_called_name_24 );
    Py_DECREF( tmp_called_name_24 );
    if ( tmp_assign_source_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 699;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_reduced;
        assert( old != NULL );
        var_reduced = tmp_assign_source_38;
        Py_DECREF( old );
    }

    branch_end_8:;
    tmp_cond_value_8 = var_cond;

    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 700;
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_no_9;
    }
    else
    {
        goto branch_yes_9;
    }
    branch_yes_9:;
    tmp_left_name_5 = const_int_pos_100;
    tmp_left_name_7 = const_float_100_0;
    tmp_source_name_10 = var_reduced;

    tmp_called_name_25 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_count );
    if ( tmp_called_name_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 701;
    tmp_right_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_25, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_25 );
    if ( tmp_right_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        goto try_except_handler_2;
    }
    tmp_left_name_6 = BINARY_OPERATION_MUL( tmp_left_name_7, tmp_right_name_6 );
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        goto try_except_handler_2;
    }
    tmp_len_arg_1 = var_reduced;

    tmp_right_name_7 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 701;
        goto try_except_handler_2;
    }
    tmp_right_name_5 = BINARY_OPERATION( PyNumber_TrueDivide, tmp_left_name_6, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        goto try_except_handler_2;
    }
    tmp_assign_source_39 = BINARY_OPERATION_SUB( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        goto try_except_handler_2;
    }
    assert( var_match == NULL );
    var_match = tmp_assign_source_39;

    tmp_called_name_26 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_26 == NULL ))
    {
        tmp_called_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 702;
        goto try_except_handler_2;
    }

    tmp_args_name_7 = PyTuple_New( 2 );
    tmp_tuple_element_11 = PyList_New( 2 );
    tmp_list_element_2 = PyCell_GET( par_x );

    if ( tmp_list_element_2 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        Py_DECREF( tmp_tuple_element_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 702;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_tuple_element_11, 0, tmp_list_element_2 );
    tmp_list_element_2 = PyCell_GET( par_y );

    if ( tmp_list_element_2 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        Py_DECREF( tmp_tuple_element_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 702;
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_list_element_2 );
    PyList_SET_ITEM( tmp_tuple_element_11, 1, tmp_list_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_7, 0, tmp_tuple_element_11 );
    tmp_left_name_8 = PyCell_GET( par_err_msg );

    if ( tmp_left_name_8 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 703;
        goto try_except_handler_2;
    }

    tmp_left_name_9 = const_str_digest_ef2d5d7b0c9e4f3b1e50776d5d0fa6e5;
    tmp_right_name_9 = PyTuple_New( 1 );
    tmp_tuple_element_12 = var_match;

    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_right_name_9, 0, tmp_tuple_element_12 );
    tmp_right_name_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_9 );
    Py_DECREF( tmp_right_name_9 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_7 );

        exception_lineno = 704;
        goto try_except_handler_2;
    }
    tmp_tuple_element_11 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_tuple_element_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_7 );

        exception_lineno = 703;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_args_name_7, 1, tmp_tuple_element_11 );
    tmp_kw_name_7 = _PyDict_NewPresized( 4 );
    tmp_dict_value_5 = PyCell_GET( par_verbose );

    if ( tmp_dict_value_5 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        Py_DECREF( tmp_kw_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "verbose" );
        exception_tb = NULL;

        exception_lineno = 705;
        goto try_except_handler_2;
    }

    tmp_dict_key_5 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_7, tmp_dict_key_5, tmp_dict_value_5 );
    tmp_dict_value_6 = PyCell_GET( par_header );

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        Py_DECREF( tmp_kw_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "header" );
        exception_tb = NULL;

        exception_lineno = 705;
        goto try_except_handler_2;
    }

    tmp_dict_key_6 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_7, tmp_dict_key_6, tmp_dict_value_6 );
    tmp_dict_value_7 = const_tuple_str_plain_x_str_plain_y_tuple;
    tmp_dict_key_7 = const_str_plain_names;
    PyDict_SetItem( tmp_kw_name_7, tmp_dict_key_7, tmp_dict_value_7 );
    tmp_dict_value_8 = PyCell_GET( par_precision );

    if ( tmp_dict_value_8 == NULL )
    {
        Py_DECREF( tmp_args_name_7 );
        Py_DECREF( tmp_kw_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "precision" );
        exception_tb = NULL;

        exception_lineno = 706;
        goto try_except_handler_2;
    }

    tmp_dict_key_8 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_7, tmp_dict_key_8, tmp_dict_value_8 );
    frame_function->f_lineno = 706;
    tmp_assign_source_40 = CALL_FUNCTION( tmp_called_name_26, tmp_args_name_7, tmp_kw_name_7 );
    Py_DECREF( tmp_args_name_7 );
    Py_DECREF( tmp_kw_name_7 );
    if ( tmp_assign_source_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 706;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_msg;
        var_msg = tmp_assign_source_40;
        Py_XDECREF( old );
    }

    tmp_cond_value_9 = var_cond;

    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 707;
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_no_10;
    }
    else
    {
        goto branch_yes_10;
    }
    branch_yes_10:;
    tmp_make_exception_arg_2 = var_msg;

    frame_function->f_lineno = 708;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 708;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_2;
    branch_no_10:;
    branch_no_9:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_4 == NULL )
    {
        exception_keeper_tb_4 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_4 );
    }
    else if ( exception_keeper_lineno_4 != -1 )
    {
        exception_keeper_tb_4 = ADD_TRACEBACK( exception_keeper_tb_4, frame_function, exception_keeper_lineno_4 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    PUBLISH_EXCEPTION( &exception_keeper_type_4, &exception_keeper_value_4, &exception_keeper_tb_4 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_ValueError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 709;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_import_globals_7 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_7 = PyDict_New();
    if ( par_comparison->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_comparison,
            par_comparison->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_x->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_x,
            par_x->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_y->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_y,
            par_y->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_err_msg,
            par_err_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_verbose->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_verbose,
            par_verbose->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_header->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_header,
            par_header->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_precision->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_precision,
            par_precision->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_array,
            var_array
        );

        assert( res == 0 );
    }

    if ( var_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_isnan,
            var_isnan
        );

        assert( res == 0 );
    }

    if ( var_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_isinf,
            var_isinf
        );

        assert( res == 0 );
    }

    if ( var_any )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_any,
            var_any
        );

        assert( res == 0 );
    }

    if ( var_all )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_all,
            var_all
        );

        assert( res == 0 );
    }

    if ( var_inf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_inf,
            var_inf
        );

        assert( res == 0 );
    }

    if ( var_safe_comparison )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_safe_comparison,
            var_safe_comparison
        );

        assert( res == 0 );
    }

    if ( var_isnumber )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_isnumber,
            var_isnumber
        );

        assert( res == 0 );
    }

    if ( var_chk_same_position )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_chk_same_position,
            var_chk_same_position
        );

        assert( res == 0 );
    }

    if ( var_cond )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_cond,
            var_cond
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_x_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_x_isnan,
            var_x_isnan
        );

        assert( res == 0 );
    }

    if ( var_y_isnan )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_y_isnan,
            var_y_isnan
        );

        assert( res == 0 );
    }

    if ( var_x_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_x_isinf,
            var_x_isinf
        );

        assert( res == 0 );
    }

    if ( var_y_isinf )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_y_isinf,
            var_y_isinf
        );

        assert( res == 0 );
    }

    if ( var_x_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_x_id,
            var_x_id
        );

        assert( res == 0 );
    }

    if ( var_y_id )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_y_id,
            var_y_id
        );

        assert( res == 0 );
    }

    if ( var_val )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_val,
            var_val
        );

        assert( res == 0 );
    }

    if ( var_reduced )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_reduced,
            var_reduced
        );

        assert( res == 0 );
    }

    if ( var_match )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_match,
            var_match
        );

        assert( res == 0 );
    }

    if ( var_traceback )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_traceback,
            var_traceback
        );

        assert( res == 0 );
    }

    if ( var_efmt )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_efmt,
            var_efmt
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 710;
    tmp_assign_source_41 = IMPORT_MODULE( const_str_plain_traceback, tmp_import_globals_7, tmp_import_locals_7, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_7 );
    if ( tmp_assign_source_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 710;
        goto frame_exception_exit_1;
    }
    assert( var_traceback == NULL );
    var_traceback = tmp_assign_source_41;

    tmp_source_name_11 = var_traceback;

    tmp_called_name_27 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_format_exc );
    if ( tmp_called_name_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 711;
    tmp_assign_source_42 = CALL_FUNCTION_NO_ARGS( tmp_called_name_27 );
    Py_DECREF( tmp_called_name_27 );
    if ( tmp_assign_source_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;
        goto frame_exception_exit_1;
    }
    assert( var_efmt == NULL );
    var_efmt = tmp_assign_source_42;

    tmp_left_name_10 = const_str_digest_3f5c98e5e86d39b731c4b8112a088b23;
    tmp_right_name_10 = PyTuple_New( 2 );
    tmp_tuple_element_13 = var_efmt;

    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_right_name_10, 0, tmp_tuple_element_13 );
    tmp_tuple_element_13 = PyCell_GET( par_header );

    if ( tmp_tuple_element_13 == NULL )
    {
        Py_DECREF( tmp_right_name_10 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "header" );
        exception_tb = NULL;

        exception_lineno = 712;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_right_name_10, 1, tmp_tuple_element_13 );
    tmp_assign_source_43 = BINARY_OPERATION_REMAINDER( tmp_left_name_10, tmp_right_name_10 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_assign_source_43 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( par_header );
        PyCell_SET( par_header, tmp_assign_source_43 );
        Py_XDECREF( old );
    }

    tmp_called_name_28 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_28 == NULL ))
    {
        tmp_called_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    tmp_args_name_8 = PyTuple_New( 2 );
    tmp_tuple_element_14 = PyList_New( 2 );
    tmp_list_element_3 = PyCell_GET( par_x );

    if ( tmp_list_element_3 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        Py_DECREF( tmp_tuple_element_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_3 );
    PyList_SET_ITEM( tmp_tuple_element_14, 0, tmp_list_element_3 );
    tmp_list_element_3 = PyCell_GET( par_y );

    if ( tmp_list_element_3 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        Py_DECREF( tmp_tuple_element_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_3 );
    PyList_SET_ITEM( tmp_tuple_element_14, 1, tmp_list_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_8, 0, tmp_tuple_element_14 );
    tmp_tuple_element_14 = PyCell_GET( par_err_msg );

    if ( tmp_tuple_element_14 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_8, 1, tmp_tuple_element_14 );
    tmp_kw_name_8 = _PyDict_NewPresized( 4 );
    tmp_dict_value_9 = PyCell_GET( par_verbose );

    if ( tmp_dict_value_9 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        Py_DECREF( tmp_kw_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "verbose" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_9 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_8, tmp_dict_key_9, tmp_dict_value_9 );
    tmp_dict_value_10 = PyCell_GET( par_header );

    if ( tmp_dict_value_10 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        Py_DECREF( tmp_kw_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "header" );
        exception_tb = NULL;

        exception_lineno = 714;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_10 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_8, tmp_dict_key_10, tmp_dict_value_10 );
    tmp_dict_value_11 = const_tuple_str_plain_x_str_plain_y_tuple;
    tmp_dict_key_11 = const_str_plain_names;
    PyDict_SetItem( tmp_kw_name_8, tmp_dict_key_11, tmp_dict_value_11 );
    tmp_dict_value_12 = PyCell_GET( par_precision );

    if ( tmp_dict_value_12 == NULL )
    {
        Py_DECREF( tmp_args_name_8 );
        Py_DECREF( tmp_kw_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "precision" );
        exception_tb = NULL;

        exception_lineno = 715;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_12 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_8, tmp_dict_key_12, tmp_dict_value_12 );
    frame_function->f_lineno = 715;
    tmp_assign_source_44 = CALL_FUNCTION( tmp_called_name_28, tmp_args_name_8, tmp_kw_name_8 );
    Py_DECREF( tmp_args_name_8 );
    Py_DECREF( tmp_kw_name_8 );
    if ( tmp_assign_source_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_msg;
        var_msg = tmp_assign_source_44;
        Py_XDECREF( old );
    }

    tmp_make_exception_arg_3 = var_msg;

    frame_function->f_lineno = 716;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 716;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    goto branch_end_11;
    branch_no_11:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_11:;
    // End of try:
    try_end_4:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_comparison->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_comparison,
                    par_comparison->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_x->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_y->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_err_msg->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_verbose->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_header->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_header,
                    par_header->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_precision->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_precision,
                    par_precision->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_array )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_array,
                    var_array
                );

                assert( res == 0 );
            }

            if ( var_isnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isnan,
                    var_isnan
                );

                assert( res == 0 );
            }

            if ( var_isinf )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isinf,
                    var_isinf
                );

                assert( res == 0 );
            }

            if ( var_any )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_any,
                    var_any
                );

                assert( res == 0 );
            }

            if ( var_all )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_all,
                    var_all
                );

                assert( res == 0 );
            }

            if ( var_inf )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_inf,
                    var_inf
                );

                assert( res == 0 );
            }

            if ( var_safe_comparison )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_safe_comparison,
                    var_safe_comparison
                );

                assert( res == 0 );
            }

            if ( var_isnumber )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isnumber,
                    var_isnumber
                );

                assert( res == 0 );
            }

            if ( var_chk_same_position )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_chk_same_position,
                    var_chk_same_position
                );

                assert( res == 0 );
            }

            if ( var_cond )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_cond,
                    var_cond
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }

            if ( var_x_isnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x_isnan,
                    var_x_isnan
                );

                assert( res == 0 );
            }

            if ( var_y_isnan )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y_isnan,
                    var_y_isnan
                );

                assert( res == 0 );
            }

            if ( var_x_isinf )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x_isinf,
                    var_x_isinf
                );

                assert( res == 0 );
            }

            if ( var_y_isinf )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y_isinf,
                    var_y_isinf
                );

                assert( res == 0 );
            }

            if ( var_x_id )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x_id,
                    var_x_id
                );

                assert( res == 0 );
            }

            if ( var_y_id )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y_id,
                    var_y_id
                );

                assert( res == 0 );
            }

            if ( var_val )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_val,
                    var_val
                );

                assert( res == 0 );
            }

            if ( var_reduced )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_reduced,
                    var_reduced
                );

                assert( res == 0 );
            }

            if ( var_match )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_match,
                    var_match
                );

                assert( res == 0 );
            }

            if ( var_traceback )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_traceback,
                    var_traceback
                );

                assert( res == 0 );
            }

            if ( var_efmt )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_efmt,
                    var_efmt
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_comparison );
    Py_DECREF( par_comparison );
    par_comparison = NULL;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)par_header );
    Py_DECREF( par_header );
    par_header = NULL;

    CHECK_OBJECT( (PyObject *)par_precision );
    Py_DECREF( par_precision );
    par_precision = NULL;

    CHECK_OBJECT( (PyObject *)var_array );
    Py_DECREF( var_array );
    var_array = NULL;

    CHECK_OBJECT( (PyObject *)var_isnan );
    Py_DECREF( var_isnan );
    var_isnan = NULL;

    CHECK_OBJECT( (PyObject *)var_isinf );
    Py_DECREF( var_isinf );
    var_isinf = NULL;

    CHECK_OBJECT( (PyObject *)var_any );
    Py_DECREF( var_any );
    var_any = NULL;

    CHECK_OBJECT( (PyObject *)var_all );
    Py_DECREF( var_all );
    var_all = NULL;

    CHECK_OBJECT( (PyObject *)var_inf );
    Py_DECREF( var_inf );
    var_inf = NULL;

    CHECK_OBJECT( (PyObject *)var_safe_comparison );
    Py_DECREF( var_safe_comparison );
    var_safe_comparison = NULL;

    CHECK_OBJECT( (PyObject *)var_isnumber );
    Py_DECREF( var_isnumber );
    var_isnumber = NULL;

    CHECK_OBJECT( (PyObject *)var_chk_same_position );
    Py_DECREF( var_chk_same_position );
    var_chk_same_position = NULL;

    Py_XDECREF( var_cond );
    var_cond = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_x_isnan );
    var_x_isnan = NULL;

    Py_XDECREF( var_y_isnan );
    var_y_isnan = NULL;

    Py_XDECREF( var_x_isinf );
    var_x_isinf = NULL;

    Py_XDECREF( var_y_isinf );
    var_y_isinf = NULL;

    Py_XDECREF( var_x_id );
    var_x_id = NULL;

    Py_XDECREF( var_y_id );
    var_y_id = NULL;

    Py_XDECREF( var_val );
    var_val = NULL;

    Py_XDECREF( var_reduced );
    var_reduced = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_comparison );
    Py_DECREF( par_comparison );
    par_comparison = NULL;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)par_header );
    Py_DECREF( par_header );
    par_header = NULL;

    CHECK_OBJECT( (PyObject *)par_precision );
    Py_DECREF( par_precision );
    par_precision = NULL;

    Py_XDECREF( var_array );
    var_array = NULL;

    Py_XDECREF( var_isnan );
    var_isnan = NULL;

    Py_XDECREF( var_isinf );
    var_isinf = NULL;

    Py_XDECREF( var_any );
    var_any = NULL;

    Py_XDECREF( var_all );
    var_all = NULL;

    Py_XDECREF( var_inf );
    var_inf = NULL;

    Py_XDECREF( var_safe_comparison );
    var_safe_comparison = NULL;

    Py_XDECREF( var_isnumber );
    var_isnumber = NULL;

    Py_XDECREF( var_chk_same_position );
    var_chk_same_position = NULL;

    Py_XDECREF( var_cond );
    var_cond = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_x_isnan );
    var_x_isnan = NULL;

    Py_XDECREF( var_y_isnan );
    var_y_isnan = NULL;

    Py_XDECREF( var_x_isinf );
    var_x_isinf = NULL;

    Py_XDECREF( var_y_isinf );
    var_y_isinf = NULL;

    Py_XDECREF( var_x_id );
    var_x_id = NULL;

    Py_XDECREF( var_y_id );
    var_y_id = NULL;

    Py_XDECREF( var_val );
    var_val = NULL;

    Py_XDECREF( var_reduced );
    var_reduced = NULL;

    Py_XDECREF( var_match );
    var_match = NULL;

    Py_XDECREF( var_traceback );
    var_traceback = NULL;

    Py_XDECREF( var_efmt );
    var_efmt = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_753834d880feddf88ba10a2a5814f57b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 634;
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_catch_warnings );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 634;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_1;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_assign_source_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_2;

    tmp_source_name_3 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 634;
    tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_3;

    tmp_assign_source_4 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_4 );
    tmp_with_1__indicator = tmp_assign_source_4;

    // Tried code:
    // Tried code:
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 635;
        goto try_except_handler_4;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_filterwarnings );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;
        goto try_except_handler_4;
    }
    tmp_args_name_1 = const_tuple_str_plain_ignore_tuple;
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );

    if (unlikely( tmp_dict_value_1 == NULL ))
    {
        tmp_dict_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning );
    }

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "DeprecationWarning" );
        exception_tb = NULL;

        exception_lineno = 635;
        goto try_except_handler_4;
    }

    tmp_dict_key_1 = const_str_plain_category;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 635;
    tmp_unused = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_dircall_arg1_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_dircall_arg1_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "comparison" );
        exception_tb = NULL;

        exception_lineno = 636;
        goto try_except_handler_4;
    }

    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kwargs;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_return_value = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        goto try_except_handler_4;
    }
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 634;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_5 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_5;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_4 = tmp_with_1__exit;

    tmp_args_element_name_1 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_2 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_3 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 636;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 636;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_2:;
    goto branch_end_1;
    branch_no_1:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_1:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Return handler code:
    try_return_handler_3:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 636;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_return_handler_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_2 = tmp_with_1__indicator;

    tmp_compare_right_2 = Py_True;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_name_6 = tmp_with_1__exit;

    frame_function->f_lineno = 636;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 636;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_7 = tmp_with_1__exit;

    frame_function->f_lineno = 636;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__indicator );
    Py_DECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kwargs )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    par_kwargs
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_comparison,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b8a8c9f2a0a9f64c3d7fa1de07f74944, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_2 = par_x;

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_dtype );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_char );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_str_digest_50e4cc95dfbb393fb8a962e3fe72cc12;
    tmp_return_value = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x_id = python_pars[ 0 ];
    PyObject *par_y_id = python_pars[ 1 ];
    PyObject *par_hasval = python_pars[ 2 ];
    PyObject *var_msg = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e3989f5cbc0c9c5f85a84f34cdc23b4d, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_equal );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_equal );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_equal" );
        exception_tb = NULL;

        exception_lineno = 645;
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = par_x_id;

    tmp_args_element_name_2 = par_y_id;

    frame_function->f_lineno = 645;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_1 = PyThreadState_GET()->exc_type;
    tmp_compare_right_1 = PyExc_AssertionError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 646;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_build_err_msg );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "build_err_msg" );
        exception_tb = NULL;

        exception_lineno = 647;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = PyList_New( 2 );
    tmp_list_element_1 = PyCell_GET( self->m_closure[4] );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "x" );
        exception_tb = NULL;

        exception_lineno = 647;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_1, 0, tmp_list_element_1 );
    tmp_list_element_1 = PyCell_GET( self->m_closure[5] );

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "y" );
        exception_tb = NULL;

        exception_lineno = 647;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_tuple_element_1, 1, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_left_name_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_left_name_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "err_msg" );
        exception_tb = NULL;

        exception_lineno = 648;
        goto frame_exception_exit_1;
    }

    tmp_left_name_2 = const_str_digest_e6a3e69014088c1412fde6a02c7b5f18;
    tmp_right_name_2 = par_hasval;

    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 648;
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 648;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[3] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "verbose" );
        exception_tb = NULL;

        exception_lineno = 649;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = PyCell_GET( self->m_closure[1] );

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "header" );
        exception_tb = NULL;

        exception_lineno = 649;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_2 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = const_tuple_str_plain_x_str_plain_y_tuple;
    tmp_dict_key_3 = const_str_plain_names;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    tmp_dict_value_4 = PyCell_GET( self->m_closure[2] );

    if ( tmp_dict_value_4 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "precision" );
        exception_tb = NULL;

        exception_lineno = 650;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_4 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    frame_function->f_lineno = 650;
    tmp_assign_source_1 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_1;

    tmp_make_exception_arg_1 = var_msg;

    frame_function->f_lineno = 651;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 651;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    goto branch_end_1;
    branch_no_1:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_1:;
    // End of try:
    try_end_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x_id )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x_id,
                    par_x_id
                );

                assert( res == 0 );
            }

            if ( par_y_id )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y_id,
                    par_y_id
                );

                assert( res == 0 );
            }

            if ( par_hasval )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_hasval,
                    par_hasval
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }

            if ( self->m_closure[4]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    self->m_closure[4]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[5]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    self->m_closure[5]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[3]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    self->m_closure[3]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_header,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_precision,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x_id );
    Py_DECREF( par_x_id );
    par_x_id = NULL;

    CHECK_OBJECT( (PyObject *)par_y_id );
    Py_DECREF( par_y_id );
    par_y_id = NULL;

    CHECK_OBJECT( (PyObject *)par_hasval );
    Py_DECREF( par_hasval );
    par_hasval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x_id );
    Py_DECREF( par_x_id );
    par_x_id = NULL;

    CHECK_OBJECT( (PyObject *)par_y_id );
    Py_DECREF( par_y_id );
    par_y_id = NULL;

    CHECK_OBJECT( (PyObject *)par_hasval );
    Py_DECREF( par_hasval );
    par_hasval = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_18_assert_array_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *par_err_msg = python_pars[ 2 ];
    PyObject *par_verbose = python_pars[ 3 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_09ef3af3431a4fa1129a67fa2c1de11e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_compare );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_compare );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_compare" );
        exception_tb = NULL;

        exception_lineno = 781;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_operator );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_operator );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "operator" );
        exception_tb = NULL;

        exception_lineno = 781;
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___eq__ );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 781;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_x;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_y;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = par_err_msg;

    tmp_dict_key_1 = const_str_plain_err_msg;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = par_verbose;

    tmp_dict_key_2 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = const_str_digest_4d26dfd9260b3b477170dd03ec01459a;
    tmp_dict_key_3 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 782;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 782;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_18_assert_array_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_18_assert_array_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_19_assert_array_almost_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyCellObject *par_decimal = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *par_err_msg = python_pars[ 3 ];
    PyObject *par_verbose = python_pars[ 4 ];
    PyCellObject *var_around = PyCell_EMPTY();
    PyCellObject *var_number = PyCell_EMPTY();
    PyCellObject *var_float_ = PyCell_EMPTY();
    PyCellObject *var_result_type = PyCell_EMPTY();
    PyCellObject *var_array = PyCell_EMPTY();
    PyCellObject *var_issubdtype = PyCell_EMPTY();
    PyCellObject *var_npany = PyCell_EMPTY();
    PyObject *var_compare = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_globals_4;
    PyObject *tmp_import_globals_5;
    PyObject *tmp_import_globals_6;
    PyObject *tmp_import_globals_7;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    PyObject *tmp_import_locals_3;
    PyObject *tmp_import_locals_4;
    PyObject *tmp_import_locals_5;
    PyObject *tmp_import_locals_6;
    PyObject *tmp_import_locals_7;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_874200c3ed7fb0f73a4df53e0e9b1954, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 854;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_1, tmp_import_locals_1, const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_around );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_around );
        PyCell_SET( var_around, tmp_assign_source_1 );
        Py_XDECREF( old );
    }

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 854;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_2, tmp_import_locals_2, const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_number );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_number );
        PyCell_SET( var_number, tmp_assign_source_2 );
        Py_XDECREF( old );
    }

    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_3 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_3,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 854;
    tmp_import_name_from_3 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_3, tmp_import_locals_3, const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_3 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_float_ );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_float_ );
        PyCell_SET( var_float_, tmp_assign_source_3 );
        Py_XDECREF( old );
    }

    tmp_import_globals_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_4 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_4,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 854;
    tmp_import_name_from_4 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_4, tmp_import_locals_4, const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_4 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_result_type );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_result_type );
        PyCell_SET( var_result_type, tmp_assign_source_4 );
        Py_XDECREF( old );
    }

    tmp_import_globals_5 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_5 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_5,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 854;
    tmp_import_name_from_5 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_5, tmp_import_locals_5, const_tuple_755ce85ccedffceaf59d88edc2b2280a_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_5 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_array );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_array );
        PyCell_SET( var_array, tmp_assign_source_5 );
        Py_XDECREF( old );
    }

    tmp_import_globals_6 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_6 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_6,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 855;
    tmp_import_name_from_6 = IMPORT_MODULE( const_str_digest_67205772204d1e33862eb50e826ab1cb, tmp_import_globals_6, tmp_import_locals_6, const_tuple_str_plain_issubdtype_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_6 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 855;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_issubdtype );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 855;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_issubdtype );
        PyCell_SET( var_issubdtype, tmp_assign_source_6 );
        Py_XDECREF( old );
    }

    tmp_import_globals_7 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_7 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_decimal->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_decimal,
            par_decimal->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_around->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_around,
            var_around->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_number->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_number,
            var_number->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_float_->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_float_,
            var_float_->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_result_type->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_result_type,
            var_result_type->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_array->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_array,
            var_array->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_issubdtype->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_issubdtype,
            var_issubdtype->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_npany->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_npany,
            var_npany->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_7,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 856;
    tmp_import_name_from_7 = IMPORT_MODULE( const_str_digest_fef7e379d8b29f70158a022afa317baa, tmp_import_globals_7, tmp_import_locals_7, const_tuple_str_plain_any_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_7 );
    if ( tmp_import_name_from_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_any );
    Py_DECREF( tmp_import_name_from_7 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_npany );
        PyCell_SET( var_npany, tmp_assign_source_7 );
        Py_XDECREF( old );
    }

    tmp_assign_source_8 = MAKE_FUNCTION_function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils( var_around, var_array, par_decimal, var_float_, var_issubdtype, var_npany, var_number, var_result_type );
    assert( var_compare == NULL );
    var_compare = tmp_assign_source_8;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_compare );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_compare );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_compare" );
        exception_tb = NULL;

        exception_lineno = 884;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_1 = var_compare;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_x;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_y;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_value_1 = par_err_msg;

    tmp_dict_key_1 = const_str_plain_err_msg;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = par_verbose;

    tmp_dict_key_2 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_left_name_1 = const_str_digest_d6b3345eef013f973e768c3ac758531f;
    tmp_right_name_1 = PyCell_GET( par_decimal );

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 885;
        goto frame_exception_exit_1;
    }

    tmp_dict_value_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 885;
        goto frame_exception_exit_1;
    }
    tmp_dict_key_3 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    tmp_dict_value_4 = PyCell_GET( par_decimal );

    if ( tmp_dict_value_4 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "decimal" );
        exception_tb = NULL;

        exception_lineno = 886;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_4 = const_str_plain_precision;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    frame_function->f_lineno = 886;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( par_decimal->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_decimal,
                    par_decimal->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }

            if ( var_around->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_around,
                    var_around->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_number->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_number,
                    var_number->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_float_->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_float_,
                    var_float_->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_result_type->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_result_type,
                    var_result_type->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_array->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_array,
                    var_array->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_issubdtype->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_issubdtype,
                    var_issubdtype->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_npany->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_npany,
                    var_npany->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_compare )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_compare,
                    var_compare
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_decimal );
    Py_DECREF( par_decimal );
    par_decimal = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_around );
    Py_DECREF( var_around );
    var_around = NULL;

    CHECK_OBJECT( (PyObject *)var_number );
    Py_DECREF( var_number );
    var_number = NULL;

    CHECK_OBJECT( (PyObject *)var_float_ );
    Py_DECREF( var_float_ );
    var_float_ = NULL;

    CHECK_OBJECT( (PyObject *)var_result_type );
    Py_DECREF( var_result_type );
    var_result_type = NULL;

    CHECK_OBJECT( (PyObject *)var_array );
    Py_DECREF( var_array );
    var_array = NULL;

    CHECK_OBJECT( (PyObject *)var_issubdtype );
    Py_DECREF( var_issubdtype );
    var_issubdtype = NULL;

    CHECK_OBJECT( (PyObject *)var_npany );
    Py_DECREF( var_npany );
    var_npany = NULL;

    CHECK_OBJECT( (PyObject *)var_compare );
    Py_DECREF( var_compare );
    var_compare = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_decimal );
    Py_DECREF( par_decimal );
    par_decimal = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_around );
    Py_DECREF( var_around );
    var_around = NULL;

    CHECK_OBJECT( (PyObject *)var_number );
    Py_DECREF( var_number );
    var_number = NULL;

    CHECK_OBJECT( (PyObject *)var_float_ );
    Py_DECREF( var_float_ );
    var_float_ = NULL;

    CHECK_OBJECT( (PyObject *)var_result_type );
    Py_DECREF( var_result_type );
    var_result_type = NULL;

    CHECK_OBJECT( (PyObject *)var_array );
    Py_DECREF( var_array );
    var_array = NULL;

    CHECK_OBJECT( (PyObject *)var_issubdtype );
    Py_DECREF( var_issubdtype );
    var_issubdtype = NULL;

    CHECK_OBJECT( (PyObject *)var_npany );
    Py_DECREF( var_npany );
    var_npany = NULL;

    Py_XDECREF( var_compare );
    var_compare = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *var_xinfid = NULL;
    PyObject *var_yinfid = NULL;
    PyObject *var_dtype = NULL;
    PyObject *var_z = NULL;
    PyObject *tmp_comparison_chain_1__operand_2 = NULL;
    PyObject *tmp_comparison_chain_1__comparison_result = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    PyObject *tmp_operand_name_3;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_outline_return_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1b5e769d1ab43c8483d069aae12da6cf, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_called_name_1 = PyCell_GET( self->m_closure[5] );

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "npany" );
        exception_tb = NULL;

        exception_lineno = 860;
        goto try_except_handler_2;
    }

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisinf );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisinf );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisinf" );
        exception_tb = NULL;

        exception_lineno = 860;
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = par_x;

    frame_function->f_lineno = 860;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 860;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        goto try_except_handler_2;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 860;
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_name_3 = PyCell_GET( self->m_closure[5] );

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "npany" );
        exception_tb = NULL;

        exception_lineno = 860;
        goto try_except_handler_2;
    }

    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisinf );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisinf );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisinf" );
        exception_tb = NULL;

        exception_lineno = 860;
        goto try_except_handler_2;
    }

    tmp_args_element_name_4 = par_y;

    frame_function->f_lineno = 860;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 860;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 860;
        goto try_except_handler_2;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 860;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisinf );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisinf );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisinf" );
        exception_tb = NULL;

        exception_lineno = 861;
        goto try_except_handler_2;
    }

    tmp_args_element_name_5 = par_x;

    frame_function->f_lineno = 861;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 861;
        goto try_except_handler_2;
    }
    assert( var_xinfid == NULL );
    var_xinfid = tmp_assign_source_1;

    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisinf );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gisinf );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "gisinf" );
        exception_tb = NULL;

        exception_lineno = 862;
        goto try_except_handler_2;
    }

    tmp_args_element_name_6 = par_y;

    frame_function->f_lineno = 862;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 862;
        goto try_except_handler_2;
    }
    assert( var_yinfid == NULL );
    var_yinfid = tmp_assign_source_2;

    tmp_compare_left_1 = var_xinfid;

    tmp_compare_right_1 = var_yinfid;

    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 863;
        goto try_except_handler_2;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_2:;
    // Tried code:
    tmp_source_name_1 = par_y;

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_size );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        goto try_except_handler_3;
    }
    assert( tmp_comparison_chain_1__operand_2 == NULL );
    tmp_comparison_chain_1__operand_2 = tmp_assign_source_3;

    tmp_source_name_2 = par_x;

    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_size );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        goto try_except_handler_3;
    }
    tmp_compexpr_right_1 = tmp_comparison_chain_1__operand_2;

    tmp_assign_source_4 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        goto try_except_handler_3;
    }
    assert( tmp_comparison_chain_1__comparison_result == NULL );
    tmp_comparison_chain_1__comparison_result = tmp_assign_source_4;

    tmp_cond_value_3 = tmp_comparison_chain_1__comparison_result;

    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_outline_return_value_1 = tmp_comparison_chain_1__comparison_result;

    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_3;
    branch_no_4:;
    tmp_compexpr_left_2 = tmp_comparison_chain_1__operand_2;

    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_outline_return_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_outline_return_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        goto try_except_handler_3;
    }
    goto try_return_handler_3;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_3:;
    CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__operand_2 );
    Py_DECREF( tmp_comparison_chain_1__operand_2 );
    tmp_comparison_chain_1__operand_2 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_comparison_chain_1__comparison_result );
    Py_DECREF( tmp_comparison_chain_1__comparison_result );
    tmp_comparison_chain_1__comparison_result = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_comparison_chain_1__operand_2 );
    tmp_comparison_chain_1__operand_2 = NULL;

    Py_XDECREF( tmp_comparison_chain_1__comparison_result );
    tmp_comparison_chain_1__comparison_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;
    outline_result_1:;
    tmp_cond_value_2 = tmp_outline_return_value_1;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 866;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_compexpr_left_3 = par_x;

    tmp_compexpr_right_3 = par_y;

    tmp_return_value = RICH_COMPARE_EQ( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;
        goto try_except_handler_2;
    }
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_subscribed_name_1 = par_x;

    tmp_operand_name_1 = var_xinfid;

    tmp_subscript_name_1 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_1 );
    if ( tmp_subscript_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        goto try_except_handler_2;
    }
    tmp_assign_source_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscript_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        goto try_except_handler_2;
    }
    {
        PyObject *old = par_x;
        assert( old != NULL );
        par_x = tmp_assign_source_5;
        Py_DECREF( old );
    }

    tmp_subscribed_name_2 = par_y;

    tmp_operand_name_2 = var_yinfid;

    tmp_subscript_name_2 = UNARY_OPERATION( PyNumber_Invert, tmp_operand_name_2 );
    if ( tmp_subscript_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        goto try_except_handler_2;
    }
    tmp_assign_source_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscript_name_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 869;
        goto try_except_handler_2;
    }
    {
        PyObject *old = par_y;
        assert( old != NULL );
        par_y = tmp_assign_source_6;
        Py_DECREF( old );
    }

    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyTuple_New( 2 );
    tmp_tuple_element_1 = PyExc_TypeError;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_compare_right_2, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = PyExc_NotImplementedError;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_compare_right_2, 1, tmp_tuple_element_1 );
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 870;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_no_5:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_called_name_7 = PyCell_GET( self->m_closure[7] );

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "result_type" );
        exception_tb = NULL;

        exception_lineno = 875;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = par_y;

    if ( tmp_args_element_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 875;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = const_float_1_0;
    frame_function->f_lineno = 875;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 875;
        goto frame_exception_exit_1;
    }
    assert( var_dtype == NULL );
    var_dtype = tmp_assign_source_7;

    tmp_called_name_8 = PyCell_GET( self->m_closure[1] );

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "array" );
        exception_tb = NULL;

        exception_lineno = 876;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_2 = par_y;

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "y" );
        exception_tb = NULL;

        exception_lineno = 876;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = var_dtype;

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = Py_False;
    tmp_dict_key_2 = const_str_plain_copy;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = Py_True;
    tmp_dict_key_3 = const_str_plain_subok;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 876;
    tmp_assign_source_8 = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_y;
        par_y = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_called_name_9 = LOOKUP_BUILTIN( const_str_plain_abs );
    assert( tmp_called_name_9 != NULL );
    tmp_left_name_1 = par_x;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "x" );
        exception_tb = NULL;

        exception_lineno = 877;
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = par_y;

    tmp_args_element_name_9 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 877;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        goto frame_exception_exit_1;
    }
    assert( var_z == NULL );
    var_z = tmp_assign_source_9;

    tmp_called_name_10 = PyCell_GET( self->m_closure[4] );

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "issubdtype" );
        exception_tb = NULL;

        exception_lineno = 879;
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = var_z;

    tmp_args_element_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_dtype );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_11 = PyCell_GET( self->m_closure[6] );

    if ( tmp_args_element_name_11 == NULL )
    {
        Py_DECREF( tmp_args_element_name_10 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "number" );
        exception_tb = NULL;

        exception_lineno = 879;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 879;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_cond_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_cond_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 879;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 879;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_no_6;
    }
    else
    {
        goto branch_yes_6;
    }
    branch_yes_6:;
    tmp_source_name_4 = var_z;

    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_astype );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 880;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = PyCell_GET( self->m_closure[3] );

    if ( tmp_args_element_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_11 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "float_" );
        exception_tb = NULL;

        exception_lineno = 880;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 880;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 880;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_z;
        assert( old != NULL );
        var_z = tmp_assign_source_10;
        Py_DECREF( old );
    }

    branch_no_6:;
    tmp_called_name_12 = PyCell_GET( self->m_closure[0] );

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "around" );
        exception_tb = NULL;

        exception_lineno = 882;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_13 = var_z;

    tmp_args_element_name_14 = PyCell_GET( self->m_closure[2] );

    if ( tmp_args_element_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "decimal" );
        exception_tb = NULL;

        exception_lineno = 882;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 882;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_compexpr_left_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_12, call_args );
    }

    if ( tmp_compexpr_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 882;
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_float_10_0;
    tmp_operand_name_3 = PyCell_GET( self->m_closure[2] );

    if ( tmp_operand_name_3 == NULL )
    {
        Py_DECREF( tmp_compexpr_left_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "decimal" );
        exception_tb = NULL;

        exception_lineno = 882;
        goto frame_exception_exit_1;
    }

    tmp_right_name_2 = UNARY_OPERATION( PyNumber_Negative, tmp_operand_name_3 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_4 );

        exception_lineno = 882;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_4 = POWER_OPERATION( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compexpr_left_4 );

        exception_lineno = 882;
        goto frame_exception_exit_1;
    }
    tmp_return_value = RICH_COMPARE_LE( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_left_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 882;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( var_xinfid )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_xinfid,
                    var_xinfid
                );

                assert( res == 0 );
            }

            if ( var_yinfid )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_yinfid,
                    var_yinfid
                );

                assert( res == 0 );
            }

            if ( var_dtype )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    var_dtype
                );

                assert( res == 0 );
            }

            if ( var_z )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_z,
                    var_z
                );

                assert( res == 0 );
            }

            if ( self->m_closure[5]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_npany,
                    self->m_closure[5]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[7]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_result_type,
                    self->m_closure[7]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_array,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[4]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_issubdtype,
                    self->m_closure[4]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[6]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_number,
                    self->m_closure[6]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[3]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_float_,
                    self->m_closure[3]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_around,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_decimal,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    Py_XDECREF( var_xinfid );
    var_xinfid = NULL;

    Py_XDECREF( var_yinfid );
    var_yinfid = NULL;

    Py_XDECREF( var_dtype );
    var_dtype = NULL;

    Py_XDECREF( var_z );
    var_z = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( par_x );
    par_x = NULL;

    Py_XDECREF( par_y );
    par_y = NULL;

    Py_XDECREF( var_xinfid );
    var_xinfid = NULL;

    Py_XDECREF( var_yinfid );
    var_yinfid = NULL;

    Py_XDECREF( var_dtype );
    var_dtype = NULL;

    Py_XDECREF( var_z );
    var_z = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_20_assert_array_less_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *par_err_msg = python_pars[ 2 ];
    PyObject *par_verbose = python_pars[ 3 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_eed94b1bf413990886124f4252687f2e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_compare );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_compare );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_compare" );
        exception_tb = NULL;

        exception_lineno = 955;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_operator );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_operator );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "operator" );
        exception_tb = NULL;

        exception_lineno = 955;
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___lt__ );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 955;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_x;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_y;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = par_err_msg;

    tmp_dict_key_1 = const_str_plain_err_msg;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = par_verbose;

    tmp_dict_key_2 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = const_str_digest_ba3a38dfc99e9008935c1c3fb4efa93f;
    tmp_dict_key_3 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 957;
    tmp_unused = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 957;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_20_assert_array_less_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_20_assert_array_less_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_21_runstring_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    // Locals dictionary setup.
    PyObject *locals_dict = PyDict_New();

    PyObject *par_astr = python_pars[ 0 ];
    PyObject *par_dict = python_pars[ 1 ];
    PyObject *tmp_exec_1__exec_source = NULL;
    PyObject *tmp_exec_1__globals = NULL;
    PyObject *tmp_exec_1__locals = NULL;
    PyObject *tmp_exec_1__plain = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_eval_globals_1;
    PyObject *tmp_eval_locals_1;
    PyObject *tmp_eval_locals_2;
    PyObject *tmp_eval_locals_3;
    PyObject *tmp_eval_source_1;
    PyObject *tmp_exec_compiled_1;
    PyObject *tmp_exec_result_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_locals_value;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = par_astr;

    assert( tmp_exec_1__exec_source == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_exec_1__exec_source = tmp_assign_source_1;

    tmp_assign_source_2 = par_dict;

    assert( tmp_exec_1__globals == NULL );
    Py_INCREF( tmp_assign_source_2 );
    tmp_exec_1__globals = tmp_assign_source_2;

    tmp_assign_source_3 = Py_False;
    assert( tmp_exec_1__plain == NULL );
    Py_INCREF( tmp_assign_source_3 );
    tmp_exec_1__plain = tmp_assign_source_3;

    tmp_compare_left_1 = tmp_exec_1__globals;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    {
        PyObject *old = tmp_exec_1__globals;
        assert( old != NULL );
        tmp_exec_1__globals = tmp_assign_source_4;
        Py_INCREF( tmp_exec_1__globals );
        Py_DECREF( old );
    }

    tmp_assign_source_5 = locals_dict;
    Py_INCREF( locals_dict );
    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_5,
        const_str_plain_astr,
        par_astr
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_5,
        const_str_plain_dict,
        par_dict
    );

    assert( tmp_exec_1__locals == NULL );
    tmp_exec_1__locals = tmp_assign_source_5;

    tmp_assign_source_6 = Py_True;
    {
        PyObject *old = tmp_exec_1__plain;
        assert( old != NULL );
        tmp_exec_1__plain = tmp_assign_source_6;
        Py_INCREF( tmp_exec_1__plain );
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_assign_source_7 = tmp_exec_1__globals;

    assert( tmp_exec_1__locals == NULL );
    Py_INCREF( tmp_assign_source_7 );
    tmp_exec_1__locals = tmp_assign_source_7;

    branch_end_1:;
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_4ed8d96b7c558a29e4001b857971058e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_isinstance_inst_1 = tmp_exec_1__exec_source;

    tmp_isinstance_cls_1 = (PyObject *)&PyFile_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = tmp_exec_1__exec_source;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_read );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 960;
    tmp_assign_source_8 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_exec_1__exec_source;
        assert( old != NULL );
        tmp_exec_1__exec_source = tmp_assign_source_8;
        Py_DECREF( old );
    }

    branch_no_2:;
    // Tried code:
    tmp_eval_source_1 = tmp_exec_1__exec_source;

    tmp_eval_globals_1 = tmp_exec_1__globals;

    tmp_eval_locals_1 = tmp_exec_1__locals;

    tmp_exec_compiled_1 = COMPILE_CODE( tmp_eval_source_1, const_str_angle_string, const_str_plain_exec, NULL, NULL );
    if ( tmp_exec_compiled_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        goto try_except_handler_3;
    }
    tmp_exec_result_1 = EVAL_CODE( tmp_exec_compiled_1, tmp_eval_globals_1, tmp_eval_locals_1 );
    Py_DECREF( tmp_exec_compiled_1 );
    if ( tmp_exec_result_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_exec_result_1 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_2 = tmp_exec_1__plain;

    tmp_compare_right_2 = Py_True;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_eval_locals_2 = tmp_exec_1__locals;

    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_astr );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );


        goto try_except_handler_2;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_astr;
        par_astr = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_dict );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_1 );
        Py_XDECREF( exception_keeper_value_1 );
        Py_XDECREF( exception_keeper_tb_1 );


        goto try_except_handler_2;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_dict;
        par_dict = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    branch_no_3:;
    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_exec_1__exec_source );
    tmp_exec_1__exec_source = NULL;

    Py_XDECREF( tmp_exec_1__globals );
    tmp_exec_1__globals = NULL;

    Py_XDECREF( tmp_exec_1__locals );
    tmp_exec_1__locals = NULL;

    Py_XDECREF( tmp_exec_1__plain );
    tmp_exec_1__plain = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = locals_dict;
            Py_INCREF( locals_dict );
            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_astr,
                par_astr
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_dict,
                par_dict
            );



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_compare_left_3 = tmp_exec_1__plain;

    tmp_compare_right_3 = Py_True;
    tmp_is_3 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_3 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_eval_locals_3 = tmp_exec_1__locals;

    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_astr );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto try_except_handler_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_astr;
        par_astr = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_dict );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto try_except_handler_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_dict;
        par_dict = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    branch_no_4:;
    Py_XDECREF( tmp_exec_1__exec_source );
    tmp_exec_1__exec_source = NULL;

    Py_XDECREF( tmp_exec_1__globals );
    tmp_exec_1__globals = NULL;

    Py_XDECREF( tmp_exec_1__locals );
    tmp_exec_1__locals = NULL;

    Py_XDECREF( tmp_exec_1__plain );
    tmp_exec_1__plain = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_21_runstring_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_astr );
    par_astr = NULL;

    Py_XDECREF( par_dict );
    par_dict = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( par_astr );
    par_astr = NULL;

    Py_XDECREF( par_dict );
    par_dict = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_21_runstring_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
Py_DECREF( locals_dict );
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:
        Py_DECREF( locals_dict );

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_22_assert_string_equal_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_actual = python_pars[ 0 ];
    PyObject *par_desired = python_pars[ 1 ];
    PyObject *var_difflib = NULL;
    PyObject *var_diff = NULL;
    PyObject *var_diff_list = NULL;
    PyObject *var_d1 = NULL;
    PyObject *var_l = NULL;
    PyObject *var_d2 = NULL;
    PyObject *var_d3 = NULL;
    PyObject *var_msg = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_make_exception_arg_3;
    PyObject *tmp_make_exception_arg_4;
    PyObject *tmp_make_exception_arg_5;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_operand_name_2;
    PyObject *tmp_operand_name_3;
    PyObject *tmp_operand_name_4;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    Py_ssize_t tmp_slice_index_upper_1;
    Py_ssize_t tmp_slice_index_upper_2;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_slice_source_2;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_type_arg_1;
    PyObject *tmp_type_arg_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_42d4d08591aaf7b9488da449f1a61731, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( var_difflib )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_difflib,
            var_difflib
        );

        assert( res == 0 );
    }

    if ( var_diff )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_diff,
            var_diff
        );

        assert( res == 0 );
    }

    if ( var_diff_list )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_diff_list,
            var_diff_list
        );

        assert( res == 0 );
    }

    if ( var_d1 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_d1,
            var_d1
        );

        assert( res == 0 );
    }

    if ( var_l )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_l,
            var_l
        );

        assert( res == 0 );
    }

    if ( var_d2 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_d2,
            var_d2
        );

        assert( res == 0 );
    }

    if ( var_d3 )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_d3,
            var_d3
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 989;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_difflib, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 989;
        goto frame_exception_exit_1;
    }
    assert( var_difflib == NULL );
    var_difflib = tmp_assign_source_1;

    tmp_isinstance_inst_1 = par_actual;

    tmp_isinstance_cls_1 = LOOKUP_BUILTIN( const_str_plain_str );
    assert( tmp_isinstance_cls_1 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 991;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_type_arg_1 = par_actual;

    tmp_operand_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_operand_name_1 != NULL );
    tmp_make_exception_arg_1 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 992;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 992;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_desired;

    tmp_isinstance_cls_2 = LOOKUP_BUILTIN( const_str_plain_str );
    assert( tmp_isinstance_cls_2 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 993;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_type_arg_2 = par_desired;

    tmp_operand_name_2 = BUILTIN_TYPE1( tmp_type_arg_2 );
    assert( tmp_operand_name_2 != NULL );
    tmp_make_exception_arg_2 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_2 );
    Py_DECREF( tmp_operand_name_2 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 994;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 994;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 994;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_match );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_c8d28aa411cf9a88d9aed194157300dd;
    tmp_right_name_1 = par_desired;

    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    tmp_right_name_2 = const_str_digest_bf444768bd6e1671ab2a507b3ebb9a78;
    tmp_args_element_name_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_actual;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_M );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 995;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 995;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_source_name_4 = var_difflib;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_Differ );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 998;
    tmp_source_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_compare );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_actual;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_splitlines );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 998;
    tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_desired;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_splitlines );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 998;
    tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 998;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_list_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_list_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = PySequence_List( tmp_list_arg_1 );
    Py_DECREF( tmp_list_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        goto frame_exception_exit_1;
    }
    assert( var_diff == NULL );
    var_diff = tmp_assign_source_2;

    tmp_assign_source_3 = PyList_New( 0 );
    assert( var_diff_list == NULL );
    var_diff_list = tmp_assign_source_3;

    loop_start_1:;
    tmp_cond_value_2 = var_diff;

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    goto loop_end_1;
    branch_no_4:;
    tmp_source_name_7 = var_diff;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_pop );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1001;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1001;
    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1001;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_d1;
        var_d1 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_source_name_8 = var_d1;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_startswith );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1002;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1002;
    tmp_cond_value_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, &PyTuple_GET_ITEM( const_tuple_str_digest_b8872718382dd39ffa4013e303d20ce5_tuple, 0 ) );

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1002;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 1002;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    goto loop_start_1;
    branch_no_5:;
    tmp_source_name_9 = var_d1;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_startswith );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1004;
    tmp_cond_value_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, &PyTuple_GET_ITEM( const_tuple_str_digest_a3a2dd55b816c9490fff0582d282bf95_tuple, 0 ) );

    Py_DECREF( tmp_called_name_8 );
    if ( tmp_cond_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 1004;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_assign_source_5 = PyList_New( 1 );
    tmp_list_element_1 = var_d1;

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_5, 0, tmp_list_element_1 );
    {
        PyObject *old = var_l;
        var_l = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_source_name_10 = var_diff;

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_pop );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1006;
    tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_d2;
        var_d2 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_source_name_11 = var_d2;

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_startswith );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1007;
    tmp_cond_value_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_str_digest_414106dd45b7d5d635f248d06d3dd69b_tuple, 0 ) );

    Py_DECREF( tmp_called_name_10 );
    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 1007;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_source_name_12 = var_l;

    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_append );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_d2;

    frame_function->f_lineno = 1008;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_13 = var_diff;

    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_pop );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1009;
    tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_name_12 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_d2;
        assert( old != NULL );
        var_d2 = tmp_assign_source_7;
        Py_DECREF( old );
    }

    branch_no_7:;
    tmp_source_name_14 = var_d2;

    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_startswith );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1010;
    tmp_cond_value_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, &PyTuple_GET_ITEM( const_tuple_str_digest_d712c8efe69b6cc6265cde822508613c_tuple, 0 ) );

    Py_DECREF( tmp_called_name_13 );
    if ( tmp_cond_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 1010;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_operand_name_3 = var_d2;

    tmp_make_exception_arg_3 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_3 );
    if ( tmp_make_exception_arg_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1011;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1011;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_3 };
        tmp_raise_type_3 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_3 );
    assert( tmp_raise_type_3 != NULL );
    exception_type = tmp_raise_type_3;
    exception_lineno = 1011;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_8:;
    tmp_source_name_15 = var_l;

    tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_append );
    if ( tmp_called_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1012;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_d2;

    frame_function->f_lineno = 1012;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    Py_DECREF( tmp_called_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1012;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_16 = var_diff;

    tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_pop );
    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1013;
    tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    Py_DECREF( tmp_called_name_15 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1013;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_d3;
        var_d3 = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_source_name_17 = var_d3;

    tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_startswith );
    if ( tmp_called_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1014;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1014;
    tmp_cond_value_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, &PyTuple_GET_ITEM( const_tuple_str_digest_414106dd45b7d5d635f248d06d3dd69b_tuple, 0 ) );

    Py_DECREF( tmp_called_name_16 );
    if ( tmp_cond_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1014;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 1014;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_source_name_18 = var_l;

    tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_append );
    if ( tmp_called_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1015;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = var_d3;

    frame_function->f_lineno = 1015;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    Py_DECREF( tmp_called_name_17 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1015;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_9;
    branch_no_9:;
    tmp_source_name_19 = var_diff;

    tmp_called_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_insert );
    if ( tmp_called_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = const_int_0;
    tmp_args_element_name_10 = var_d3;

    frame_function->f_lineno = 1017;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_18, call_args );
    }

    Py_DECREF( tmp_called_name_18 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_9:;
    tmp_source_name_20 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_20 == NULL ))
    {
        tmp_source_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }

    tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_match );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    tmp_left_name_4 = const_str_digest_c8d28aa411cf9a88d9aed194157300dd;
    tmp_sliceslicedel_index_lower_1 = 2;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_slice_source_1 = var_d2;

    tmp_right_name_3 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    if ( tmp_right_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    tmp_left_name_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_left_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_bf444768bd6e1671ab2a507b3ebb9a78;
    tmp_args_element_name_11 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_3 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    tmp_sliceslicedel_index_lower_2 = 2;
    tmp_slice_index_upper_2 = PY_SSIZE_T_MAX;
    tmp_slice_source_2 = var_d1;

    tmp_args_element_name_12 = LOOKUP_INDEX_SLICE( tmp_slice_source_2, tmp_sliceslicedel_index_lower_2, tmp_slice_index_upper_2 );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );
        Py_DECREF( tmp_args_element_name_11 );

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1018;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_cond_value_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_called_name_19 );
    Py_DECREF( tmp_args_element_name_11 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_cond_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_8 );

        exception_lineno = 1018;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    goto loop_start_1;
    branch_no_10:;
    tmp_source_name_21 = var_diff_list;

    tmp_called_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_extend );
    if ( tmp_called_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1020;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_13 = var_l;

    frame_function->f_lineno = 1020;
    {
        PyObject *call_args[] = { tmp_args_element_name_13 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_called_name_20 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1020;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto loop_start_1;
    branch_no_6:;
    tmp_operand_name_4 = var_d1;

    tmp_make_exception_arg_4 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_4 );
    if ( tmp_make_exception_arg_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1022;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1022;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_4 };
        tmp_raise_type_4 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_4 );
    assert( tmp_raise_type_4 != NULL );
    exception_type = tmp_raise_type_4;
    exception_lineno = 1022;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_cond_value_9 = var_diff_list;

    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_no_11;
    }
    else
    {
        goto branch_yes_11;
    }
    branch_yes_11:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_11:;
    tmp_left_name_5 = const_str_digest_6cc5cefb53b579746bcbb4d68e503416;
    tmp_source_name_23 = const_str_empty;
    tmp_called_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_join );
    assert( tmp_called_name_22 != NULL );
    tmp_args_element_name_14 = var_diff_list;

    frame_function->f_lineno = 1025;
    {
        PyObject *call_args[] = { tmp_args_element_name_14 };
        tmp_source_name_22 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
    }

    Py_DECREF( tmp_called_name_22 );
    if ( tmp_source_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        goto frame_exception_exit_1;
    }
    tmp_called_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_rstrip );
    Py_DECREF( tmp_source_name_22 );
    if ( tmp_called_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1025;
    tmp_right_name_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_21 );
    Py_DECREF( tmp_called_name_21 );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_9 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1025;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_9;

    tmp_compare_left_1 = par_actual;

    tmp_compare_right_1 = par_desired;

    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1026;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_make_exception_arg_5 = var_msg;

    frame_function->f_lineno = 1027;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_5 };
        tmp_raise_type_5 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_5 != NULL );
    exception_type = tmp_raise_type_5;
    exception_lineno = 1027;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_12:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual
                );

                assert( res == 0 );
            }

            if ( par_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired
                );

                assert( res == 0 );
            }

            if ( var_difflib )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_difflib,
                    var_difflib
                );

                assert( res == 0 );
            }

            if ( var_diff )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_diff,
                    var_diff
                );

                assert( res == 0 );
            }

            if ( var_diff_list )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_diff_list,
                    var_diff_list
                );

                assert( res == 0 );
            }

            if ( var_d1 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_d1,
                    var_d1
                );

                assert( res == 0 );
            }

            if ( var_l )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_l,
                    var_l
                );

                assert( res == 0 );
            }

            if ( var_d2 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_d2,
                    var_d2
                );

                assert( res == 0 );
            }

            if ( var_d3 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_d3,
                    var_d3
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_22_assert_string_equal_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)var_difflib );
    Py_DECREF( var_difflib );
    var_difflib = NULL;

    Py_XDECREF( var_diff );
    var_diff = NULL;

    Py_XDECREF( var_diff_list );
    var_diff_list = NULL;

    Py_XDECREF( var_d1 );
    var_d1 = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_d2 );
    var_d2 = NULL;

    Py_XDECREF( var_d3 );
    var_d3 = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    Py_XDECREF( var_difflib );
    var_difflib = NULL;

    Py_XDECREF( var_diff );
    var_diff = NULL;

    Py_XDECREF( var_diff_list );
    var_diff_list = NULL;

    Py_XDECREF( var_d1 );
    var_d1 = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_d2 );
    var_d2 = NULL;

    Py_XDECREF( var_d3 );
    var_d3 = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_22_assert_string_equal_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_23_rundocs_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_filename = python_pars[ 0 ];
    PyObject *par_raise_on_error = python_pars[ 1 ];
    PyObject *var_doctest = NULL;
    PyObject *var_imp = NULL;
    PyObject *var_f = NULL;
    PyObject *var_name = NULL;
    PyObject *var_path = NULL;
    PyObject *var_file = NULL;
    PyObject *var_pathname = NULL;
    PyObject *var_description = NULL;
    PyObject *var_m = NULL;
    PyObject *var_tests = NULL;
    PyObject *var_runner = NULL;
    PyCellObject *var_msg = PyCell_EMPTY();
    PyObject *var_out = NULL;
    PyObject *var_test = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_locals_2;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_unpack_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_da65c2aed225a04117b73452ab716f1b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_filename )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_filename,
            par_filename
        );

        assert( res == 0 );
    }

    if ( par_raise_on_error )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_raise_on_error,
            par_raise_on_error
        );

        assert( res == 0 );
    }

    if ( var_doctest )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_doctest,
            var_doctest
        );

        assert( res == 0 );
    }

    if ( var_imp )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_imp,
            var_imp
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_name )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_name,
            var_name
        );

        assert( res == 0 );
    }

    if ( var_path )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_path,
            var_path
        );

        assert( res == 0 );
    }

    if ( var_file )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_file,
            var_file
        );

        assert( res == 0 );
    }

    if ( var_pathname )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_pathname,
            var_pathname
        );

        assert( res == 0 );
    }

    if ( var_description )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_description,
            var_description
        );

        assert( res == 0 );
    }

    if ( var_m )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_m,
            var_m
        );

        assert( res == 0 );
    }

    if ( var_tests )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_tests,
            var_tests
        );

        assert( res == 0 );
    }

    if ( var_runner )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_runner,
            var_runner
        );

        assert( res == 0 );
    }

    if ( var_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_out )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_out,
            var_out
        );

        assert( res == 0 );
    }

    if ( var_test )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_test,
            var_test
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1052;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_doctest, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        goto frame_exception_exit_1;
    }
    assert( var_doctest == NULL );
    var_doctest = tmp_assign_source_1;

    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_2 = PyDict_New();
    if ( par_filename )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_filename,
            par_filename
        );

        assert( res == 0 );
    }

    if ( par_raise_on_error )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_raise_on_error,
            par_raise_on_error
        );

        assert( res == 0 );
    }

    if ( var_doctest )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_doctest,
            var_doctest
        );

        assert( res == 0 );
    }

    if ( var_imp )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_imp,
            var_imp
        );

        assert( res == 0 );
    }

    if ( var_f )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_f,
            var_f
        );

        assert( res == 0 );
    }

    if ( var_name )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_name,
            var_name
        );

        assert( res == 0 );
    }

    if ( var_path )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_path,
            var_path
        );

        assert( res == 0 );
    }

    if ( var_file )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_file,
            var_file
        );

        assert( res == 0 );
    }

    if ( var_pathname )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_pathname,
            var_pathname
        );

        assert( res == 0 );
    }

    if ( var_description )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_description,
            var_description
        );

        assert( res == 0 );
    }

    if ( var_m )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_m,
            var_m
        );

        assert( res == 0 );
    }

    if ( var_tests )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_tests,
            var_tests
        );

        assert( res == 0 );
    }

    if ( var_runner )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_runner,
            var_runner
        );

        assert( res == 0 );
    }

    if ( var_msg->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_msg,
            var_msg->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_out )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_out,
            var_out
        );

        assert( res == 0 );
    }

    if ( var_test )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_2,
            const_str_plain_test,
            var_test
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1053;
    tmp_assign_source_2 = IMPORT_MODULE( const_str_plain_imp, tmp_import_globals_2, tmp_import_locals_2, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1053;
        goto frame_exception_exit_1;
    }
    assert( var_imp == NULL );
    var_imp = tmp_assign_source_2;

    tmp_compare_left_1 = par_filename;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 1055;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__getframe );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1055;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        goto frame_exception_exit_1;
    }
    assert( var_f == NULL );
    var_f = tmp_assign_source_3;

    tmp_source_name_2 = var_f;

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_f_globals );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_str_plain___file__;
    tmp_assign_source_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_filename;
        assert( old != NULL );
        par_filename = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_no_1:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_path );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_splitext );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_path );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_basename );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_filename;

    frame_function->f_lineno = 1057;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1057;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_subscribed_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_0;
    tmp_assign_source_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_5;

    tmp_assign_source_6 = PyList_New( 1 );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_assign_source_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 1058;
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_path );
    if ( tmp_source_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_6 );

        exception_lineno = 1058;
        goto frame_exception_exit_1;
    }
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_dirname );
    Py_DECREF( tmp_source_name_7 );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_6 );

        exception_lineno = 1058;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_filename;

    frame_function->f_lineno = 1058;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_list_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_6 );

        exception_lineno = 1058;
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_6, 0, tmp_list_element_1 );
    assert( var_path == NULL );
    var_path = tmp_assign_source_6;

    // Tried code:
    tmp_source_name_9 = var_imp;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_find_module );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    tmp_args_element_name_4 = var_name;

    tmp_args_element_name_5 = var_path;

    frame_function->f_lineno = 1059;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    tmp_assign_source_7 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_7;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_8 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_8 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_8;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_9 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_9 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_9;

    tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_10 = UNPACK_NEXT( tmp_unpack_3, 2 );
    if ( tmp_assign_source_10 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1059;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_3 == NULL );
    tmp_tuple_unpack_1__element_3 = tmp_assign_source_10;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_2;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_11 = tmp_tuple_unpack_1__element_1;

    assert( var_file == NULL );
    Py_INCREF( tmp_assign_source_11 );
    var_file = tmp_assign_source_11;

    tmp_assign_source_12 = tmp_tuple_unpack_1__element_2;

    assert( var_pathname == NULL );
    Py_INCREF( tmp_assign_source_12 );
    var_pathname = tmp_assign_source_12;

    tmp_assign_source_13 = tmp_tuple_unpack_1__element_3;

    assert( var_description == NULL );
    Py_INCREF( tmp_assign_source_13 );
    var_description = tmp_assign_source_13;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_3 );
    Py_DECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Tried code:
    tmp_source_name_10 = var_imp;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_load_module );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        goto try_except_handler_3;
    }
    tmp_args_element_name_6 = var_name;

    tmp_args_element_name_7 = var_file;

    tmp_args_element_name_8 = var_pathname;

    tmp_args_element_name_9 = var_description;

    frame_function->f_lineno = 1061;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_14 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1061;
        goto try_except_handler_3;
    }
    assert( var_m == NULL );
    var_m = tmp_assign_source_14;

    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_source_name_11 = var_file;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_close );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1063;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1063;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
    Py_DECREF( tmp_called_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1063;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    tmp_source_name_12 = var_file;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_close );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1063;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1063;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    Py_DECREF( tmp_called_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1063;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_14 = var_doctest;

    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_DocTestFinder );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1065;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1065;
    tmp_source_name_13 = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    Py_DECREF( tmp_called_name_10 );
    if ( tmp_source_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1065;
        goto frame_exception_exit_1;
    }
    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_find );
    Py_DECREF( tmp_source_name_13 );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1065;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_m;

    frame_function->f_lineno = 1065;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_assign_source_15 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1065;
        goto frame_exception_exit_1;
    }
    assert( var_tests == NULL );
    var_tests = tmp_assign_source_15;

    tmp_source_name_15 = var_doctest;

    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_DocTestRunner );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1066;
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_c05cf8ed9016cad683e758f62a6613d4 );
    frame_function->f_lineno = 1066;
    tmp_assign_source_16 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_11, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_11 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1066;
        goto frame_exception_exit_1;
    }
    assert( var_runner == NULL );
    var_runner = tmp_assign_source_16;

    tmp_assign_source_17 = PyList_New( 0 );
    {
        PyObject *old = PyCell_GET( var_msg );
        PyCell_SET( var_msg, tmp_assign_source_17 );
        Py_XDECREF( old );
    }

    tmp_cond_value_1 = par_raise_on_error;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1069;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_18 = MAKE_FUNCTION_function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils( var_msg );
    assert( var_out == NULL );
    var_out = tmp_assign_source_18;

    goto branch_end_2;
    branch_no_2:;
    tmp_assign_source_19 = Py_None;
    assert( var_out == NULL );
    Py_INCREF( tmp_assign_source_19 );
    var_out = tmp_assign_source_19;

    branch_end_2:;
    tmp_iter_arg_2 = var_tests;

    tmp_assign_source_20 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1074;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_20;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_21 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_21 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1074;
            goto try_except_handler_4;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_21;
        Py_XDECREF( old );
    }

    tmp_assign_source_22 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_test;
        var_test = tmp_assign_source_22;
        Py_INCREF( var_test );
        Py_XDECREF( old );
    }

    tmp_source_name_16 = var_runner;

    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_run );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1075;
        goto try_except_handler_4;
    }
    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_test;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_2 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = var_out;

    tmp_dict_key_1 = const_str_plain_out;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1075;
    tmp_unused = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_1, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1075;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1074;
        goto try_except_handler_4;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_source_name_17 = var_runner;

    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_failures );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_0;
    tmp_and_left_value_1 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1077;
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1077;
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_and_right_value_1 = par_raise_on_error;

    Py_INCREF( tmp_and_right_value_1 );
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1077;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_left_name_1 = const_str_digest_2504623327411b88e755c287d1ce7706;
    tmp_source_name_18 = const_str_newline;
    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_join );
    assert( tmp_called_name_13 != NULL );
    tmp_args_element_name_11 = PyCell_GET( var_msg );

    if ( tmp_args_element_name_11 == NULL )
    {
        Py_DECREF( tmp_called_name_13 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "msg" );
        exception_tb = NULL;

        exception_lineno = 1078;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 1078;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        goto frame_exception_exit_1;
    }
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1078;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1078;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_filename )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_filename,
                    par_filename
                );

                assert( res == 0 );
            }

            if ( par_raise_on_error )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_raise_on_error,
                    par_raise_on_error
                );

                assert( res == 0 );
            }

            if ( var_doctest )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_doctest,
                    var_doctest
                );

                assert( res == 0 );
            }

            if ( var_imp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_imp,
                    var_imp
                );

                assert( res == 0 );
            }

            if ( var_f )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_f,
                    var_f
                );

                assert( res == 0 );
            }

            if ( var_name )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_name,
                    var_name
                );

                assert( res == 0 );
            }

            if ( var_path )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_path,
                    var_path
                );

                assert( res == 0 );
            }

            if ( var_file )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_file,
                    var_file
                );

                assert( res == 0 );
            }

            if ( var_pathname )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_pathname,
                    var_pathname
                );

                assert( res == 0 );
            }

            if ( var_description )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_description,
                    var_description
                );

                assert( res == 0 );
            }

            if ( var_m )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_m,
                    var_m
                );

                assert( res == 0 );
            }

            if ( var_tests )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_tests,
                    var_tests
                );

                assert( res == 0 );
            }

            if ( var_runner )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_runner,
                    var_runner
                );

                assert( res == 0 );
            }

            if ( var_msg->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_out )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_out,
                    var_out
                );

                assert( res == 0 );
            }

            if ( var_test )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_test,
                    var_test
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_23_rundocs_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_filename );
    Py_DECREF( par_filename );
    par_filename = NULL;

    CHECK_OBJECT( (PyObject *)par_raise_on_error );
    Py_DECREF( par_raise_on_error );
    par_raise_on_error = NULL;

    CHECK_OBJECT( (PyObject *)var_doctest );
    Py_DECREF( var_doctest );
    var_doctest = NULL;

    CHECK_OBJECT( (PyObject *)var_imp );
    Py_DECREF( var_imp );
    var_imp = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)var_path );
    Py_DECREF( var_path );
    var_path = NULL;

    CHECK_OBJECT( (PyObject *)var_file );
    Py_DECREF( var_file );
    var_file = NULL;

    CHECK_OBJECT( (PyObject *)var_pathname );
    Py_DECREF( var_pathname );
    var_pathname = NULL;

    CHECK_OBJECT( (PyObject *)var_description );
    Py_DECREF( var_description );
    var_description = NULL;

    CHECK_OBJECT( (PyObject *)var_m );
    Py_DECREF( var_m );
    var_m = NULL;

    CHECK_OBJECT( (PyObject *)var_tests );
    Py_DECREF( var_tests );
    var_tests = NULL;

    CHECK_OBJECT( (PyObject *)var_runner );
    Py_DECREF( var_runner );
    var_runner = NULL;

    CHECK_OBJECT( (PyObject *)var_msg );
    Py_DECREF( var_msg );
    var_msg = NULL;

    CHECK_OBJECT( (PyObject *)var_out );
    Py_DECREF( var_out );
    var_out = NULL;

    Py_XDECREF( var_test );
    var_test = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( par_filename );
    par_filename = NULL;

    CHECK_OBJECT( (PyObject *)par_raise_on_error );
    Py_DECREF( par_raise_on_error );
    par_raise_on_error = NULL;

    Py_XDECREF( var_doctest );
    var_doctest = NULL;

    Py_XDECREF( var_imp );
    var_imp = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_path );
    var_path = NULL;

    Py_XDECREF( var_file );
    var_file = NULL;

    Py_XDECREF( var_pathname );
    var_pathname = NULL;

    Py_XDECREF( var_description );
    var_description = NULL;

    Py_XDECREF( var_m );
    var_m = NULL;

    Py_XDECREF( var_tests );
    var_tests = NULL;

    Py_XDECREF( var_runner );
    var_runner = NULL;

    CHECK_OBJECT( (PyObject *)var_msg );
    Py_DECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_out );
    var_out = NULL;

    Py_XDECREF( var_test );
    var_test = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_23_rundocs_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_s = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_89a43f46680c3f0d4ec63f81244a810a, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "msg" );
        exception_tb = NULL;

        exception_lineno = 1070;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_s;

    frame_function->f_lineno = 1070;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_s )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_s,
                    par_s
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_24_raises_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    PyObject *var_nose = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cd0d3ab68268b8b182327a55f30686c5, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_import_nose );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_import_nose );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "import_nose" );
        exception_tb = NULL;

        exception_lineno = 1082;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 1082;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        goto frame_exception_exit_1;
    }
    assert( var_nose == NULL );
    var_nose = tmp_assign_source_1;

    tmp_source_name_2 = var_nose;

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_tools );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_raises );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kwargs;

    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_return_value = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kwargs )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    par_kwargs
                );

                assert( res == 0 );
            }

            if ( var_nose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_nose,
                    var_nose
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_24_raises_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_nose );
    Py_DECREF( var_nose );
    var_nose = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_nose );
    var_nose = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_24_raises_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_25_assert_raises_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    PyObject *var_nose = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e4e8dd9562b52d56409fe506920e113b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_import_nose );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_import_nose );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "import_nose" );
        exception_tb = NULL;

        exception_lineno = 1098;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 1098;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1098;
        goto frame_exception_exit_1;
    }
    assert( var_nose == NULL );
    var_nose = tmp_assign_source_1;

    tmp_source_name_2 = var_nose;

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_tools );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_assert_raises );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kwargs;

    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_return_value = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kwargs )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    par_kwargs
                );

                assert( res == 0 );
            }

            if ( var_nose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_nose,
                    var_nose
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_25_assert_raises_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_nose );
    Py_DECREF( var_nose );
    var_nose = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_nose );
    var_nose = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_25_assert_raises_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_exception_class = python_pars[ 0 ];
    PyObject *par_expected_regexp = python_pars[ 1 ];
    PyObject *par_callable_obj = python_pars[ 2 ];
    PyObject *par_args = python_pars[ 3 ];
    PyObject *par_kwargs = python_pars[ 4 ];
    PyObject *var_nose = NULL;
    PyCellObject *var__AssertRaisesContext = PyCell_EMPTY();
    PyObject *var_impl = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    PyObject *tmp_key_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e67db4e37ff46531ff4ac7fd61eae93a, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_import_nose );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_import_nose );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "import_nose" );
        exception_tb = NULL;

        exception_lineno = 1116;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 1116;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1116;
        goto frame_exception_exit_1;
    }
    assert( var_nose == NULL );
    var_nose = tmp_assign_source_1;

    tmp_compare_left_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl );

    if (unlikely( tmp_compare_left_1 == NULL ))
    {
        tmp_compare_left_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl );
    }

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_raises_regex_impl" );
        exception_tb = NULL;

        exception_lineno = 1119;
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_source_name_2 = var_nose;

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_tools );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;
        goto try_except_handler_2;
    }
    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_assert_raises_regex );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;
        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl, tmp_assign_source_2 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_AttributeError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1123;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    // Tried code:
    tmp_source_name_4 = var_nose;

    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_tools );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;
        goto try_except_handler_3;
    }
    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_assert_raises_regexp );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1126;
        goto try_except_handler_3;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl, tmp_assign_source_3 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_AttributeError;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1127;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_4 = PyTuple_New( 1 );
    tmp_tuple_element_1 = LOOKUP_BUILTIN( const_str_plain_object );
    assert( tmp_tuple_element_1 != NULL );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_4, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_4;

    tmp_assign_source_5 = impl_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( NULL );
    assert( tmp_assign_source_5 != NULL );
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_5;

    // Tried code:
    tmp_compare_left_4 = const_str_plain___metaclass__;
    tmp_compare_right_4 = tmp_class_creation_1__class_dict;

    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_4, tmp_compare_left_4 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_6 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        goto try_except_handler_4;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_bases_name_1 = tmp_class_creation_1__bases;

    tmp_assign_source_6 = SELECT_METACLASS( tmp_bases_name_1, GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_6;

    tmp_called_name_2 = tmp_class_creation_1__metaclass;

    tmp_args_element_name_1 = const_str_plain__AssertRaisesContext;
    tmp_args_element_name_2 = tmp_class_creation_1__bases;

    tmp_args_element_name_3 = tmp_class_creation_1__class_dict;

    frame_function->f_lineno = 1131;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        goto try_except_handler_4;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_7;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    tmp_assign_source_8 = tmp_class_creation_1__class;

    {
        PyObject *old = PyCell_GET( var__AssertRaisesContext );
        PyCell_SET( var__AssertRaisesContext, tmp_assign_source_8 );
        Py_INCREF( tmp_assign_source_8 );
        Py_XDECREF( old );
    }

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_assign_source_9 = MAKE_FUNCTION_function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils( var__AssertRaisesContext );
    assert( var_impl == NULL );
    var_impl = tmp_assign_source_9;

    tmp_assign_source_10 = var_impl;

    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl, tmp_assign_source_10 );
    goto branch_end_3;
    branch_no_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_3:;
    goto try_end_2;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_2:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    branch_no_1:;
    tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl );

    if (unlikely( tmp_dircall_arg1_1 == NULL ))
    {
        tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl );
    }

    if ( tmp_dircall_arg1_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_raises_regex_impl" );
        exception_tb = NULL;

        exception_lineno = 1176;
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg2_1 = PyTuple_New( 3 );
    tmp_tuple_element_2 = par_exception_class;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = par_expected_regexp;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 1, tmp_tuple_element_2 );
    tmp_tuple_element_2 = par_callable_obj;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 2, tmp_tuple_element_2 );
    tmp_dircall_arg3_1 = par_args;

    tmp_dircall_arg4_1 = par_kwargs;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl_function_5_complex_call_helper_pos_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1177;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_exception_class )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_exception_class,
                    par_exception_class
                );

                assert( res == 0 );
            }

            if ( par_expected_regexp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_expected_regexp,
                    par_expected_regexp
                );

                assert( res == 0 );
            }

            if ( par_callable_obj )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_callable_obj,
                    par_callable_obj
                );

                assert( res == 0 );
            }

            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kwargs )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    par_kwargs
                );

                assert( res == 0 );
            }

            if ( var_nose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_nose,
                    var_nose
                );

                assert( res == 0 );
            }

            if ( var__AssertRaisesContext->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__AssertRaisesContext,
                    var__AssertRaisesContext->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_impl )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_impl,
                    var_impl
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_exception_class );
    Py_DECREF( par_exception_class );
    par_exception_class = NULL;

    CHECK_OBJECT( (PyObject *)par_expected_regexp );
    Py_DECREF( par_expected_regexp );
    par_expected_regexp = NULL;

    CHECK_OBJECT( (PyObject *)par_callable_obj );
    Py_DECREF( par_callable_obj );
    par_callable_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    CHECK_OBJECT( (PyObject *)var_nose );
    Py_DECREF( var_nose );
    var_nose = NULL;

    CHECK_OBJECT( (PyObject *)var__AssertRaisesContext );
    Py_DECREF( var__AssertRaisesContext );
    var__AssertRaisesContext = NULL;

    Py_XDECREF( var_impl );
    var_impl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_exception_class );
    Py_DECREF( par_exception_class );
    par_exception_class = NULL;

    CHECK_OBJECT( (PyObject *)par_expected_regexp );
    Py_DECREF( par_expected_regexp );
    par_expected_regexp = NULL;

    CHECK_OBJECT( (PyObject *)par_callable_obj );
    Py_DECREF( par_callable_obj );
    par_callable_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    Py_XDECREF( var_nose );
    var_nose = NULL;

    CHECK_OBJECT( (PyObject *)var__AssertRaisesContext );
    Py_DECREF( var__AssertRaisesContext );
    var__AssertRaisesContext = NULL;

    Py_XDECREF( var_impl );
    var_impl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var___doc__ = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var_failureException = NULL;
    PyObject *var___enter__ = NULL;
    PyObject *var___exit__ = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_defaults_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_digest_a972e06f82fc56ec857dbfbe96117f49;
    assert( var___doc__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___doc__ = tmp_assign_source_2;

    tmp_defaults_1 = const_tuple_none_tuple;
    tmp_assign_source_3 = MAKE_FUNCTION_function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ) );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_3;

    tmp_assign_source_4 = MAKE_FUNCTION_function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );
    assert( var_failureException == NULL );
    var_failureException = tmp_assign_source_4;

    tmp_assign_source_5 = MAKE_FUNCTION_function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );
    assert( var___enter__ == NULL );
    var___enter__ = tmp_assign_source_5;

    tmp_assign_source_6 = MAKE_FUNCTION_function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  );
    assert( var___exit__ == NULL );
    var___exit__ = tmp_assign_source_6;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var___doc__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___doc__,
            var___doc__
        );

        assert( res == 0 );
    }

    if ( var___init__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___init__,
            var___init__
        );

        assert( res == 0 );
    }

    if ( var_failureException )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_failureException,
            var_failureException
        );

        assert( res == 0 );
    }

    if ( var___enter__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___enter__,
            var___enter__
        );

        assert( res == 0 );
    }

    if ( var___exit__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___exit__,
            var___exit__
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;

    CHECK_OBJECT( (PyObject *)var___init__ );
    Py_DECREF( var___init__ );
    var___init__ = NULL;

    CHECK_OBJECT( (PyObject *)var_failureException );
    Py_DECREF( var_failureException );
    var_failureException = NULL;

    CHECK_OBJECT( (PyObject *)var___enter__ );
    Py_DECREF( var___enter__ );
    var___enter__ = NULL;

    CHECK_OBJECT( (PyObject *)var___exit__ );
    Py_DECREF( var___exit__ );
    var___exit__ = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_expected = python_pars[ 1 ];
    PyObject *par_expected_regexp = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_frame_locals;
    bool tmp_result;
    PyObject *tmp_return_value;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3575a0e9fbc395e93c9cd8a07c227ba5, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_assattr_name_1 = par_expected;

    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_expected, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1135;
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = par_expected_regexp;

    tmp_assattr_target_2 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_expected_regexp, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1136;
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_expected )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_expected,
                    par_expected
                );

                assert( res == 0 );
            }

            if ( par_expected_regexp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_expected_regexp,
                    par_expected_regexp
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_expected );
    Py_DECREF( par_expected );
    par_expected = NULL;

    CHECK_OBJECT( (PyObject *)par_expected_regexp );
    Py_DECREF( par_expected_regexp );
    par_expected_regexp = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_expected );
    Py_DECREF( par_expected );
    par_expected = NULL;

    CHECK_OBJECT( (PyObject *)par_expected_regexp );
    Py_DECREF( par_expected_regexp );
    par_expected_regexp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_make_exception_arg_1 = par_msg;

    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_return_value != NULL );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_msg );
    Py_DECREF( par_msg );
    par_msg = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = par_self;

    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_type = python_pars[ 1 ];
    PyObject *par_exc_value = python_pars[ 2 ];
    PyObject *par_tb = python_pars[ 3 ];
    PyObject *var_exc_name = NULL;
    PyObject *var_expected_regexp = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_str_arg_1;
    PyObject *tmp_str_arg_2;
    PyObject *tmp_str_arg_3;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_22425dfac68b1934190c6706cc5558bf, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_compare_left_1 = par_exc_type;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    // Tried code:
    tmp_source_name_2 = par_self;

    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_expected );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        goto try_except_handler_2;
    }
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___name__ );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        goto try_except_handler_2;
    }
    assert( var_exc_name == NULL );
    var_exc_name = tmp_assign_source_1;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_AttributeError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_3 = par_self;

    tmp_str_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_expected );
    if ( tmp_str_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = PyObject_Str( tmp_str_arg_1 );
    Py_DECREF( tmp_str_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        goto frame_exception_exit_1;
    }
    assert( var_exc_name == NULL );
    var_exc_name = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto frame_exception_exit_1;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    tmp_source_name_4 = par_self;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_failureException );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1150;
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = const_str_digest_78ccf3b264ec8c8b4336a7805cf6825b;
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_format );
    assert( tmp_called_name_2 != NULL );
    tmp_args_element_name_2 = var_exc_name;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "exc_name" );
        exception_tb = NULL;

        exception_lineno = 1151;
        goto frame_exception_exit_1;
    }

    frame_function->f_lineno = 1151;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1151;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1151;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_raise_type_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1151;
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_1;
    exception_lineno = 1151;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_issubclass );
    assert( tmp_called_name_3 != NULL );
    tmp_args_element_name_3 = par_exc_type;

    tmp_source_name_6 = par_self;

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_expected );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1152;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1152;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;
    tmp_assattr_name_1 = par_exc_value;

    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_exception, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1155;
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    tmp_compare_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_expected_regexp );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1156;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = Py_None;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_4:;
    tmp_source_name_8 = par_self;

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_expected_regexp );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;
        goto frame_exception_exit_1;
    }
    assert( var_expected_regexp == NULL );
    var_expected_regexp = tmp_assign_source_3;

    tmp_isinstance_inst_1 = var_expected_regexp;

    tmp_isinstance_cls_1 = LOOKUP_BUILTIN( const_str_plain_basestring );
    assert( tmp_isinstance_cls_1 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 1161;
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_compile );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1161;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_expected_regexp;

    frame_function->f_lineno = 1161;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1161;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_expected_regexp;
        assert( old != NULL );
        var_expected_regexp = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_no_5:;
    tmp_source_name_10 = var_expected_regexp;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_search );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;
        goto frame_exception_exit_1;
    }
    tmp_str_arg_2 = par_exc_value;

    tmp_args_element_name_6 = PyObject_Str( tmp_str_arg_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1162;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1162;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1162;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_6;
    }
    else
    {
        goto branch_yes_6;
    }
    branch_yes_6:;
    tmp_source_name_11 = par_self;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_failureException );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1163;
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_10bbed5c16f2cf6e80902c569bddb5f4;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_source_name_12 = var_expected_regexp;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_pattern );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1165;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_str_arg_3 = par_exc_value;

    tmp_tuple_element_1 = PyObject_Str( tmp_str_arg_3 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1165;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_args_element_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1164;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1165;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_raise_type_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1165;
        goto frame_exception_exit_1;
    }
    exception_type = tmp_raise_type_2;
    exception_lineno = 1165;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_6:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_exc_type )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_exc_type,
                    par_exc_type
                );

                assert( res == 0 );
            }

            if ( par_exc_value )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_exc_value,
                    par_exc_value
                );

                assert( res == 0 );
            }

            if ( par_tb )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_tb,
                    par_tb
                );

                assert( res == 0 );
            }

            if ( var_exc_name )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_exc_name,
                    var_exc_name
                );

                assert( res == 0 );
            }

            if ( var_expected_regexp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_expected_regexp,
                    var_expected_regexp
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_True;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    Py_XDECREF( var_expected_regexp );
    var_expected_regexp = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_type );
    Py_DECREF( par_exc_type );
    par_exc_type = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_value );
    Py_DECREF( par_exc_value );
    par_exc_value = NULL;

    CHECK_OBJECT( (PyObject *)par_tb );
    Py_DECREF( par_tb );
    par_tb = NULL;

    Py_XDECREF( var_exc_name );
    var_exc_name = NULL;

    Py_XDECREF( var_expected_regexp );
    var_expected_regexp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_regex = python_pars[ 1 ];
    PyObject *par_callable_obj = python_pars[ 2 ];
    PyObject *par_a = python_pars[ 3 ];
    PyObject *par_kw = python_pars[ 4 ];
    PyObject *var_mgr = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_c924695e3d917a7e69c51bff702e46aa, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "_AssertRaisesContext" );
        exception_tb = NULL;

        exception_lineno = 1169;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_cls;

    tmp_args_element_name_2 = par_regex;

    frame_function->f_lineno = 1169;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1169;
        goto frame_exception_exit_1;
    }
    assert( var_mgr == NULL );
    var_mgr = tmp_assign_source_1;

    tmp_compare_left_1 = par_callable_obj;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = var_mgr;

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_assign_source_2 = var_mgr;

    assert( tmp_with_1__source == NULL );
    Py_INCREF( tmp_assign_source_2 );
    tmp_with_1__source = tmp_assign_source_2;

    // Tried code:
    tmp_source_name_1 = tmp_with_1__source;

    tmp_assign_source_3 = LOOKUP_SPECIAL( tmp_source_name_1, const_str_plain___exit__ );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_3;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1172;
    tmp_assign_source_4 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_4;

    tmp_assign_source_5 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_5 );
    tmp_with_1__indicator = tmp_assign_source_5;

    // Tried code:
    // Tried code:
    tmp_dircall_arg1_1 = par_callable_obj;

    tmp_dircall_arg2_1 = par_a;

    tmp_dircall_arg3_1 = par_kw;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_unused = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_6 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_6;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_3 = tmp_with_1__exit;

    tmp_args_element_name_3 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_4 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_5 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 1173;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1173;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_4 = tmp_with_1__exit;

    frame_function->f_lineno = 1173;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1173;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_4 = tmp_with_1__indicator;

    tmp_compare_right_4 = Py_True;
    tmp_is_3 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_3 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 1173;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_cls )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_cls,
                    par_cls
                );

                assert( res == 0 );
            }

            if ( par_regex )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_regex,
                    par_regex
                );

                assert( res == 0 );
            }

            if ( par_callable_obj )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_callable_obj,
                    par_callable_obj
                );

                assert( res == 0 );
            }

            if ( par_a )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_a,
                    par_a
                );

                assert( res == 0 );
            }

            if ( par_kw )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kw,
                    par_kw
                );

                assert( res == 0 );
            }

            if ( var_mgr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_mgr,
                    var_mgr
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__AssertRaisesContext,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_regex );
    Py_DECREF( par_regex );
    par_regex = NULL;

    CHECK_OBJECT( (PyObject *)par_callable_obj );
    Py_DECREF( par_callable_obj );
    par_callable_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_a );
    Py_DECREF( par_a );
    par_a = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_mgr );
    Py_DECREF( var_mgr );
    var_mgr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_regex );
    Py_DECREF( par_regex );
    par_regex = NULL;

    CHECK_OBJECT( (PyObject *)par_callable_obj );
    Py_DECREF( par_callable_obj );
    par_callable_obj = NULL;

    CHECK_OBJECT( (PyObject *)par_a );
    Py_DECREF( par_a );
    par_a = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_mgr );
    var_mgr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_27_decorate_methods_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[ 0 ];
    PyObject *par_decorator = python_pars[ 1 ];
    PyObject *par_testmatch = python_pars[ 2 ];
    PyObject *var_cls_attr = NULL;
    PyObject *var_isfunction = NULL;
    PyObject *var__m = NULL;
    PyObject *var_methods = NULL;
    PyObject *var_function = NULL;
    PyObject *var_funcname = NULL;
    PyObject *tmp_list_contraction_1__$0 = NULL;
    PyObject *tmp_list_contraction_1__contraction_result = NULL;
    PyObject *tmp_list_contraction_1__iter_value_0 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_import_name_from_1;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_outline_return_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_setattr_attr_1;
    PyObject *tmp_setattr_target_1;
    PyObject *tmp_setattr_value_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;
    tmp_outline_return_value_1 = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a16362c40d4a926aa17d83f5f9b86aab, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_compare_left_1 = par_testmatch;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_compile );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_4768c214d294535d1b934026c8fbb084;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_sep );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1204;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_testmatch;
        assert( old != NULL );
        par_testmatch = tmp_assign_source_1;
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_re );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "re" );
        exception_tb = NULL;

        exception_lineno = 1206;
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_compile );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1206;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_testmatch;

    frame_function->f_lineno = 1206;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1206;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_testmatch;
        assert( old != NULL );
        par_testmatch = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_end_1:;
    tmp_source_name_4 = par_cls;

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE_DICT_SLOT( tmp_source_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1207;
        goto frame_exception_exit_1;
    }
    assert( var_cls_attr == NULL );
    var_cls_attr = tmp_assign_source_3;

    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_cls )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_cls,
            par_cls
        );

        assert( res == 0 );
    }

    if ( par_decorator )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_decorator,
            par_decorator
        );

        assert( res == 0 );
    }

    if ( par_testmatch )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_testmatch,
            par_testmatch
        );

        assert( res == 0 );
    }

    if ( var_cls_attr )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_cls_attr,
            var_cls_attr
        );

        assert( res == 0 );
    }

    if ( var_isfunction )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_isfunction,
            var_isfunction
        );

        assert( res == 0 );
    }

    if ( var__m )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__m,
            var__m
        );

        assert( res == 0 );
    }

    if ( var_methods )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_methods,
            var_methods
        );

        assert( res == 0 );
    }

    if ( var_function )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_function,
            var_function
        );

        assert( res == 0 );
    }

    if ( var_funcname )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_funcname,
            var_funcname
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1210;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_plain_inspect, tmp_import_globals_1, tmp_import_locals_1, const_tuple_str_plain_isfunction_tuple, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1210;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_isfunction );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1210;
        goto frame_exception_exit_1;
    }
    assert( var_isfunction == NULL );
    var_isfunction = tmp_assign_source_4;

    // Tried code:
    tmp_source_name_5 = var_cls_attr;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_values );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    PyThreadState_GET()->frame->f_lineno = 1212;
    tmp_iter_arg_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    assert( tmp_list_contraction_1__$0 == NULL );
    tmp_list_contraction_1__$0 = tmp_assign_source_6;

    tmp_assign_source_7 = PyList_New( 0 );
    assert( tmp_list_contraction_1__contraction_result == NULL );
    tmp_list_contraction_1__contraction_result = tmp_assign_source_7;

    loop_start_1:;
    tmp_next_source_1 = tmp_list_contraction_1__$0;

    tmp_assign_source_8 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            PyThreadState_GET()->frame->f_lineno = 1212;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_list_contraction_1__iter_value_0;
        tmp_list_contraction_1__iter_value_0 = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_assign_source_9 = tmp_list_contraction_1__iter_value_0;

    {
        PyObject *old = var__m;
        var__m = tmp_assign_source_9;
        Py_INCREF( var__m );
        Py_XDECREF( old );
    }

    tmp_called_name_4 = var_isfunction;

    tmp_args_element_name_3 = var__m;

    PyThreadState_GET()->frame->f_lineno = 1212;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_append_list_1 = tmp_list_contraction_1__contraction_result;

    tmp_append_value_1 = var__m;

    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_outline_return_value_1 = tmp_list_contraction_1__contraction_result;

    Py_INCREF( tmp_outline_return_value_1 );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_27_decorate_methods_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__$0 );
    Py_DECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_list_contraction_1__contraction_result );
    Py_DECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    goto outline_result_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_list_contraction_1__$0 );
    tmp_list_contraction_1__$0 = NULL;

    Py_XDECREF( tmp_list_contraction_1__contraction_result );
    tmp_list_contraction_1__contraction_result = NULL;

    Py_XDECREF( tmp_list_contraction_1__iter_value_0 );
    tmp_list_contraction_1__iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_27_decorate_methods_of_numpy$testing$utils );
    return NULL;
    outline_result_1:;
    tmp_assign_source_5 = tmp_outline_return_value_1;
    assert( var_methods == NULL );
    var_methods = tmp_assign_source_5;

    tmp_iter_arg_2 = var_methods;

    tmp_assign_source_10 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_10;

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_11 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_11 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1213;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_assign_source_12 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_function;
        var_function = tmp_assign_source_12;
        Py_INCREF( var_function );
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_hasattr_source_1 = var_function;

    tmp_hasattr_attr_1 = const_str_plain_compat_func_name;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1215;
        goto try_except_handler_4;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_6 = var_function;

    tmp_assign_source_13 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_compat_func_name );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1216;
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_funcname;
        var_funcname = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    goto branch_end_3;
    branch_no_3:;
    tmp_source_name_7 = var_function;

    tmp_assign_source_14 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___name__ );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1218;
        goto try_except_handler_4;
    }
    {
        PyObject *old = var_funcname;
        var_funcname = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    branch_end_3:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_2 == NULL )
    {
        exception_keeper_tb_2 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_2 );
    }
    else if ( exception_keeper_lineno_2 != -1 )
    {
        exception_keeper_tb_2 = ADD_TRACEBACK( exception_keeper_tb_2, frame_function, exception_keeper_lineno_2 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    PUBLISH_EXCEPTION( &exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_AttributeError;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1219;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    goto loop_start_2;
    goto branch_end_4;
    branch_no_4:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_4:;
    // End of try:
    try_end_1:;
    tmp_source_name_8 = par_testmatch;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_search );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    tmp_args_element_name_4 = var_funcname;

    frame_function->f_lineno = 1222;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_and_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_9 = var_funcname;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_startswith );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    frame_function->f_lineno = 1222;
    tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_str_plain___tuple, 0 ) );

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    tmp_and_right_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    Py_INCREF( tmp_and_right_value_1 );
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1222;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_setattr_target_1 = par_cls;

    tmp_setattr_attr_1 = var_funcname;

    tmp_called_name_7 = par_decorator;

    tmp_args_element_name_5 = var_function;

    frame_function->f_lineno = 1223;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_setattr_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    if ( tmp_setattr_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1223;
        goto try_except_handler_3;
    }
    tmp_unused = BUILTIN_SETATTR( tmp_setattr_target_1, tmp_setattr_attr_1, tmp_setattr_value_1 );
    Py_DECREF( tmp_setattr_value_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1223;
        goto try_except_handler_3;
    }
    branch_no_5:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_cls )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_cls,
                    par_cls
                );

                assert( res == 0 );
            }

            if ( par_decorator )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_decorator,
                    par_decorator
                );

                assert( res == 0 );
            }

            if ( par_testmatch )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_testmatch,
                    par_testmatch
                );

                assert( res == 0 );
            }

            if ( var_cls_attr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_cls_attr,
                    var_cls_attr
                );

                assert( res == 0 );
            }

            if ( var_isfunction )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_isfunction,
                    var_isfunction
                );

                assert( res == 0 );
            }

            if ( var__m )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__m,
                    var__m
                );

                assert( res == 0 );
            }

            if ( var_methods )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_methods,
                    var_methods
                );

                assert( res == 0 );
            }

            if ( var_function )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_function,
                    var_function
                );

                assert( res == 0 );
            }

            if ( var_funcname )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_funcname,
                    var_funcname
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_27_decorate_methods_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_decorator );
    Py_DECREF( par_decorator );
    par_decorator = NULL;

    CHECK_OBJECT( (PyObject *)par_testmatch );
    Py_DECREF( par_testmatch );
    par_testmatch = NULL;

    CHECK_OBJECT( (PyObject *)var_cls_attr );
    Py_DECREF( var_cls_attr );
    var_cls_attr = NULL;

    CHECK_OBJECT( (PyObject *)var_isfunction );
    Py_DECREF( var_isfunction );
    var_isfunction = NULL;

    Py_XDECREF( var__m );
    var__m = NULL;

    CHECK_OBJECT( (PyObject *)var_methods );
    Py_DECREF( var_methods );
    var_methods = NULL;

    Py_XDECREF( var_function );
    var_function = NULL;

    Py_XDECREF( var_funcname );
    var_funcname = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_cls );
    Py_DECREF( par_cls );
    par_cls = NULL;

    CHECK_OBJECT( (PyObject *)par_decorator );
    Py_DECREF( par_decorator );
    par_decorator = NULL;

    Py_XDECREF( par_testmatch );
    par_testmatch = NULL;

    Py_XDECREF( var_cls_attr );
    var_cls_attr = NULL;

    Py_XDECREF( var_isfunction );
    var_isfunction = NULL;

    Py_XDECREF( var__m );
    var__m = NULL;

    Py_XDECREF( var_methods );
    var_methods = NULL;

    Py_XDECREF( var_function );
    var_function = NULL;

    Py_XDECREF( var_funcname );
    var_funcname = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_27_decorate_methods_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_28_measure_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    // Locals dictionary setup.
    PyObject *locals_dict = PyDict_New();

    PyObject *par_code_str = python_pars[ 0 ];
    PyObject *par_times = python_pars[ 1 ];
    PyObject *par_label = python_pars[ 2 ];
    PyObject *var_frame = NULL;
    PyObject *var_locs = NULL;
    PyObject *var_globs = NULL;
    PyObject *var_code = NULL;
    PyObject *var_i = NULL;
    PyObject *var_elapsed = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_exec_1__exec_source = NULL;
    PyObject *tmp_exec_1__globals = NULL;
    PyObject *tmp_exec_1__locals = NULL;
    PyObject *tmp_exec_1__plain = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compile_filename_1;
    PyObject *tmp_compile_mode_1;
    PyObject *tmp_compile_source_1;
    PyObject *tmp_eval_globals_1;
    PyObject *tmp_eval_locals_1;
    PyObject *tmp_eval_locals_2;
    PyObject *tmp_eval_locals_3;
    PyObject *tmp_eval_source_1;
    PyObject *tmp_exec_compiled_1;
    PyObject *tmp_exec_result_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    bool tmp_is_4;
    bool tmp_is_5;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_locals_value;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d121f8f975ce6d236da5714368310521, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = PyDict_GetItem( locals_dict, const_str_plain_sys );

    if ( tmp_source_name_1 == NULL )
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

        if (unlikely( tmp_source_name_1 == NULL ))
        {
            tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
        }

        if ( tmp_source_name_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "sys" );
            exception_tb = NULL;

            exception_lineno = 1260;
            goto frame_exception_exit_1;
        }

    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__getframe );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1260;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        goto frame_exception_exit_1;
    }
    assert( var_frame == NULL );
    var_frame = tmp_assign_source_1;

    // Tried code:
    tmp_iter_arg_1 = PyTuple_New( 2 );
    tmp_source_name_2 = var_frame;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_f_locals );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1261;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_3 = var_frame;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_f_globals );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1261;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 1, tmp_tuple_element_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_2;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1261;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_3;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1261;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_4;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_2;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_5 = tmp_tuple_unpack_1__element_1;

    assert( var_locs == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_locs = tmp_assign_source_5;

    tmp_assign_source_6 = tmp_tuple_unpack_1__element_2;

    assert( var_globs == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_globs = tmp_assign_source_6;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_compile_source_1 = par_code_str;

    tmp_left_name_1 = const_str_digest_7ac790b77fb2e800593801101da6838e;
    tmp_right_name_1 = par_label;

    tmp_compile_filename_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_compile_filename_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        goto frame_exception_exit_1;
    }
    tmp_compile_mode_1 = const_str_plain_exec;
    tmp_assign_source_7 = COMPILE_CODE( tmp_compile_source_1, tmp_compile_filename_1, tmp_compile_mode_1, NULL, NULL );
    Py_DECREF( tmp_compile_filename_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        goto frame_exception_exit_1;
    }
    assert( var_code == NULL );
    var_code = tmp_assign_source_7;

    tmp_assign_source_8 = const_int_0;
    assert( var_i == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_i = tmp_assign_source_8;

    tmp_called_name_2 = PyDict_GetItem( locals_dict, const_str_plain_jiffies );

    if ( tmp_called_name_2 == NULL )
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_jiffies );

        if (unlikely( tmp_called_name_2 == NULL ))
        {
            tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_jiffies );
        }

        if ( tmp_called_name_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "jiffies" );
            exception_tb = NULL;

            exception_lineno = 1267;
            goto frame_exception_exit_1;
        }

    }

    frame_function->f_lineno = 1267;
    tmp_assign_source_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        goto frame_exception_exit_1;
    }
    assert( var_elapsed == NULL );
    var_elapsed = tmp_assign_source_9;

    loop_start_1:;
    tmp_compare_left_1 = var_i;

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "i" );
        exception_tb = NULL;

        exception_lineno = 1268;
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = par_times;

    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_left_name_2 = var_i;

    if ( tmp_left_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "i" );
        exception_tb = NULL;

        exception_lineno = 1269;
        goto frame_exception_exit_1;
    }

    tmp_right_name_2 = const_int_pos_1;
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
    tmp_assign_source_10 = tmp_left_name_2;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1269;
        goto frame_exception_exit_1;
    }
    var_i = tmp_assign_source_10;

    tmp_assign_source_11 = var_code;

    {
        PyObject *old = tmp_exec_1__exec_source;
        tmp_exec_1__exec_source = tmp_assign_source_11;
        Py_INCREF( tmp_exec_1__exec_source );
        Py_XDECREF( old );
    }

    tmp_assign_source_12 = var_globs;

    {
        PyObject *old = tmp_exec_1__globals;
        tmp_exec_1__globals = tmp_assign_source_12;
        Py_INCREF( tmp_exec_1__globals );
        Py_XDECREF( old );
    }

    tmp_assign_source_13 = var_locs;

    {
        PyObject *old = tmp_exec_1__locals;
        tmp_exec_1__locals = tmp_assign_source_13;
        Py_INCREF( tmp_exec_1__locals );
        Py_XDECREF( old );
    }

    tmp_assign_source_14 = Py_False;
    {
        PyObject *old = tmp_exec_1__plain;
        tmp_exec_1__plain = tmp_assign_source_14;
        Py_INCREF( tmp_exec_1__plain );
        Py_XDECREF( old );
    }

    tmp_compare_left_2 = tmp_exec_1__globals;

    tmp_compare_right_2 = Py_None;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_15 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    {
        PyObject *old = tmp_exec_1__globals;
        assert( old != NULL );
        tmp_exec_1__globals = tmp_assign_source_15;
        Py_INCREF( tmp_exec_1__globals );
        Py_DECREF( old );
    }

    tmp_compare_left_3 = tmp_exec_1__locals;

    tmp_compare_right_3 = Py_None;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_2 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_16 = locals_dict;
    Py_INCREF( locals_dict );
    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_code_str,
        par_code_str
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_times,
        par_times
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_label,
        par_label
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_frame,
        var_frame
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_locs,
        var_locs
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_globs,
        var_globs
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_code,
        var_code
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_i,
        var_i
    );

    DICT_SYNC_FROM_VARIABLE(
        tmp_assign_source_16,
        const_str_plain_elapsed,
        var_elapsed
    );

    {
        PyObject *old = tmp_exec_1__locals;
        assert( old != NULL );
        tmp_exec_1__locals = tmp_assign_source_16;
        Py_DECREF( old );
    }

    tmp_assign_source_17 = Py_True;
    {
        PyObject *old = tmp_exec_1__plain;
        assert( old != NULL );
        tmp_exec_1__plain = tmp_assign_source_17;
        Py_INCREF( tmp_exec_1__plain );
        Py_DECREF( old );
    }

    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    tmp_compare_left_4 = tmp_exec_1__locals;

    tmp_compare_right_4 = Py_None;
    tmp_is_3 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_3 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_assign_source_18 = tmp_exec_1__globals;

    {
        PyObject *old = tmp_exec_1__locals;
        assert( old != NULL );
        tmp_exec_1__locals = tmp_assign_source_18;
        Py_INCREF( tmp_exec_1__locals );
        Py_DECREF( old );
    }

    branch_no_4:;
    branch_end_2:;
    // Tried code:
    tmp_isinstance_inst_1 = tmp_exec_1__exec_source;

    tmp_isinstance_cls_1 = (PyObject *)&PyFile_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        goto try_except_handler_3;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_4 = tmp_exec_1__exec_source;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_read );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        goto try_except_handler_3;
    }
    frame_function->f_lineno = 1270;
    tmp_assign_source_19 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_exec_1__exec_source;
        assert( old != NULL );
        tmp_exec_1__exec_source = tmp_assign_source_19;
        Py_DECREF( old );
    }

    branch_no_5:;
    // Tried code:
    tmp_eval_source_1 = tmp_exec_1__exec_source;

    tmp_eval_globals_1 = tmp_exec_1__globals;

    tmp_eval_locals_1 = tmp_exec_1__locals;

    tmp_exec_compiled_1 = COMPILE_CODE( tmp_eval_source_1, const_str_angle_string, const_str_plain_exec, NULL, NULL );
    if ( tmp_exec_compiled_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        goto try_except_handler_4;
    }
    tmp_exec_result_1 = EVAL_CODE( tmp_exec_compiled_1, tmp_eval_globals_1, tmp_eval_locals_1 );
    Py_DECREF( tmp_exec_compiled_1 );
    if ( tmp_exec_result_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_exec_result_1 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_5 = tmp_exec_1__plain;

    tmp_compare_right_5 = Py_True;
    tmp_is_4 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    if ( tmp_is_4 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_eval_locals_2 = tmp_exec_1__locals;

    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_code_str );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_code_str;
        par_code_str = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_times );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_times;
        par_times = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_label );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_label;
        par_label = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_frame );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_frame;
        var_frame = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_locs );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_locs;
        var_locs = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_globs );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_globs;
        var_globs = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_code );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_code;
        var_code = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_i );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_i;
        var_i = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_2, const_str_plain_elapsed );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );


        goto try_except_handler_3;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_elapsed;
        var_elapsed = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    branch_no_6:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_exec_1__exec_source );
    tmp_exec_1__exec_source = NULL;

    Py_XDECREF( tmp_exec_1__globals );
    tmp_exec_1__globals = NULL;

    Py_XDECREF( tmp_exec_1__locals );
    tmp_exec_1__locals = NULL;

    Py_XDECREF( tmp_exec_1__plain );
    tmp_exec_1__plain = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    tmp_compare_left_6 = tmp_exec_1__plain;

    tmp_compare_right_6 = Py_True;
    tmp_is_5 = ( tmp_compare_left_6 == tmp_compare_right_6 );
    if ( tmp_is_5 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_eval_locals_3 = tmp_exec_1__locals;

    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_code_str );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_code_str;
        par_code_str = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_times );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_times;
        par_times = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_label );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = par_label;
        par_label = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_frame );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_frame;
        var_frame = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_locs );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_locs;
        var_locs = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_globs );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_globs;
        var_globs = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_code );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_code;
        var_code = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_i );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_i;
        var_i = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    tmp_locals_value = PyObject_GetItem( tmp_eval_locals_3, const_str_plain_elapsed );
    if ( tmp_locals_value == NULL && !EXCEPTION_MATCH_BOOL_SINGLE( GET_ERROR_OCCURRED(), PyExc_KeyError ) )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );



        goto frame_exception_exit_1;
    }
    CLEAR_ERROR_OCCURRED();
    if ( tmp_locals_value != NULL )
    {
    {
        PyObject *old = var_elapsed;
        var_elapsed = tmp_locals_value;
        Py_XDECREF( old );
    }

    }
    branch_no_7:;
    Py_XDECREF( tmp_exec_1__exec_source );
    tmp_exec_1__exec_source = NULL;

    Py_XDECREF( tmp_exec_1__globals );
    tmp_exec_1__globals = NULL;

    Py_XDECREF( tmp_exec_1__locals );
    tmp_exec_1__locals = NULL;

    Py_XDECREF( tmp_exec_1__plain );
    tmp_exec_1__plain = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_called_name_4 = PyDict_GetItem( locals_dict, const_str_plain_jiffies );

    if ( tmp_called_name_4 == NULL )
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_jiffies );

        if (unlikely( tmp_called_name_4 == NULL ))
        {
            tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_jiffies );
        }

        if ( tmp_called_name_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyString_FromFormat( "global name '%s' is not defined", "jiffies" );
            exception_tb = NULL;

            exception_lineno = 1271;
            goto frame_exception_exit_1;
        }

    }

    frame_function->f_lineno = 1271;
    tmp_left_name_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_left_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = var_elapsed;

    tmp_assign_source_20 = BINARY_OPERATION_SUB( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_3 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_elapsed;
        assert( old != NULL );
        var_elapsed = tmp_assign_source_20;
        Py_DECREF( old );
    }

    tmp_left_name_4 = const_float_0_01;
    tmp_right_name_4 = var_elapsed;

    tmp_return_value = BINARY_OPERATION_MUL( tmp_left_name_4, tmp_right_name_4 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1272;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = locals_dict;
            Py_INCREF( locals_dict );
            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_code_str,
                par_code_str
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_times,
                par_times
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_label,
                par_label
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_frame,
                var_frame
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_locs,
                var_locs
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_globs,
                var_globs
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_code,
                var_code
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_i,
                var_i
            );

            DICT_SYNC_FROM_VARIABLE(
                tmp_frame_locals,
                const_str_plain_elapsed,
                var_elapsed
            );



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_28_measure_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_code_str );
    Py_DECREF( par_code_str );
    par_code_str = NULL;

    CHECK_OBJECT( (PyObject *)par_times );
    Py_DECREF( par_times );
    par_times = NULL;

    CHECK_OBJECT( (PyObject *)par_label );
    Py_DECREF( par_label );
    par_label = NULL;

    CHECK_OBJECT( (PyObject *)var_frame );
    Py_DECREF( var_frame );
    var_frame = NULL;

    CHECK_OBJECT( (PyObject *)var_locs );
    Py_DECREF( var_locs );
    var_locs = NULL;

    CHECK_OBJECT( (PyObject *)var_globs );
    Py_DECREF( var_globs );
    var_globs = NULL;

    CHECK_OBJECT( (PyObject *)var_code );
    Py_DECREF( var_code );
    var_code = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    CHECK_OBJECT( (PyObject *)var_elapsed );
    Py_DECREF( var_elapsed );
    var_elapsed = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( par_code_str );
    par_code_str = NULL;

    Py_XDECREF( par_times );
    par_times = NULL;

    Py_XDECREF( par_label );
    par_label = NULL;

    Py_XDECREF( var_frame );
    var_frame = NULL;

    Py_XDECREF( var_locs );
    var_locs = NULL;

    Py_XDECREF( var_globs );
    var_globs = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_elapsed );
    var_elapsed = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_28_measure_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
Py_DECREF( locals_dict );
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:
        Py_DECREF( locals_dict );

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_29__assert_valid_refcount_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_op = python_pars[ 0 ];
    PyObject *var_np = NULL;
    PyObject *var_b = NULL;
    PyObject *var_c = NULL;
    PyObject *var_rc = NULL;
    PyObject *var_j = NULL;
    PyObject *var_d = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_81e84cbbcb43fd608f0de5831954e2fb, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_op )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_op,
            par_op
        );

        assert( res == 0 );
    }

    if ( var_np )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np
        );

        assert( res == 0 );
    }

    if ( var_b )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_b,
            var_b
        );

        assert( res == 0 );
    }

    if ( var_c )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_c,
            var_c
        );

        assert( res == 0 );
    }

    if ( var_rc )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_rc,
            var_rc
        );

        assert( res == 0 );
    }

    if ( var_j )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_j,
            var_j
        );

        assert( res == 0 );
    }

    if ( var_d )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_d,
            var_d
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1280;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1280;
        goto frame_exception_exit_1;
    }
    assert( var_np == NULL );
    var_np = tmp_assign_source_1;

    tmp_source_name_2 = var_np;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_arange );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1282;
    tmp_source_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_int_pos_10000_tuple, 0 ) );

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_reshape );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1282;
    tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_int_pos_100_int_pos_100_tuple, 0 ) );

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        goto frame_exception_exit_1;
    }
    assert( var_b == NULL );
    var_b = tmp_assign_source_2;

    tmp_assign_source_3 = var_b;

    assert( var_c == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_c = tmp_assign_source_3;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 1286;
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_getrefcount );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1286;
    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1286;
        goto frame_exception_exit_1;
    }
    assert( var_rc == NULL );
    var_rc = tmp_assign_source_4;

    tmp_iter_arg_1 = const_tuple_cc0d7a281e580497181b34c5d19dd2ca_tuple;
    tmp_assign_source_5 = MAKE_ITERATOR( tmp_iter_arg_1 );
    assert( tmp_assign_source_5 != NULL );
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_5;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_6 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1287;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_assign_source_7 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_j;
        var_j = tmp_assign_source_7;
        Py_INCREF( var_j );
        Py_XDECREF( old );
    }

    tmp_called_name_4 = par_op;

    tmp_args_element_name_1 = var_b;

    tmp_args_element_name_2 = var_c;

    frame_function->f_lineno = 1288;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1288;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_d;
        var_d = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1287;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_ );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_ );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_" );
        exception_tb = NULL;

        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }

    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_getrefcount );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1289;
    tmp_compexpr_left_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = var_rc;

    tmp_args_element_name_3 = RICH_COMPARE_GE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1289;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1289;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_result = var_d != NULL;
    if ( tmp_result == true )
    {
        Py_DECREF( var_d );
        var_d = NULL;
    }

    if ( tmp_result == false )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 629 ], 47, 0 );
        exception_tb = NULL;

        exception_lineno = 1290;
        goto frame_exception_exit_1;
    }


#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_op )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_op,
                    par_op
                );

                assert( res == 0 );
            }

            if ( var_np )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np
                );

                assert( res == 0 );
            }

            if ( var_b )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_b,
                    var_b
                );

                assert( res == 0 );
            }

            if ( var_c )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_c,
                    var_c
                );

                assert( res == 0 );
            }

            if ( var_rc )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rc,
                    var_rc
                );

                assert( res == 0 );
            }

            if ( var_j )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_j,
                    var_j
                );

                assert( res == 0 );
            }

            if ( var_d )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_d,
                    var_d
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_29__assert_valid_refcount_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_op );
    Py_DECREF( par_op );
    par_op = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    CHECK_OBJECT( (PyObject *)var_b );
    Py_DECREF( var_b );
    var_b = NULL;

    CHECK_OBJECT( (PyObject *)var_c );
    Py_DECREF( var_c );
    var_c = NULL;

    CHECK_OBJECT( (PyObject *)var_rc );
    Py_DECREF( var_rc );
    var_rc = NULL;

    Py_XDECREF( var_j );
    var_j = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_op );
    Py_DECREF( par_op );
    par_op = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_b );
    var_b = NULL;

    Py_XDECREF( var_c );
    var_c = NULL;

    Py_XDECREF( var_rc );
    var_rc = NULL;

    Py_XDECREF( var_j );
    var_j = NULL;

    Py_XDECREF( var_d );
    var_d = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_29__assert_valid_refcount_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_30_assert_allclose_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_actual = python_pars[ 0 ];
    PyObject *par_desired = python_pars[ 1 ];
    PyCellObject *par_rtol = PyCell_NEW1( python_pars[ 2 ] );
    PyCellObject *par_atol = PyCell_NEW1( python_pars[ 3 ] );
    PyCellObject *par_equal_nan = PyCell_NEW1( python_pars[ 4 ] );
    PyObject *par_err_msg = python_pars[ 5 ];
    PyObject *par_verbose = python_pars[ 6 ];
    PyCellObject *var_np = PyCell_EMPTY();
    PyObject *var_compare = NULL;
    PyObject *var_header = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_str_arg_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_edae6eb33a8c360aab01cb7a8ffbe19e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_actual )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_actual,
            par_actual
        );

        assert( res == 0 );
    }

    if ( par_desired )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_desired,
            par_desired
        );

        assert( res == 0 );
    }

    if ( par_rtol->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_rtol,
            par_rtol->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_atol->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_atol,
            par_atol->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_equal_nan->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_equal_nan,
            par_equal_nan->ob_ref
        );

        assert( res == 0 );
    }

    if ( par_err_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_err_msg,
            par_err_msg
        );

        assert( res == 0 );
    }

    if ( par_verbose )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_verbose,
            par_verbose
        );

        assert( res == 0 );
    }

    if ( var_np->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_compare )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_compare,
            var_compare
        );

        assert( res == 0 );
    }

    if ( var_header )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_header,
            var_header
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1338;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1338;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_np );
        PyCell_SET( var_np, tmp_assign_source_1 );
        Py_XDECREF( old );
    }

    tmp_assign_source_2 = MAKE_FUNCTION_function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils( par_atol, par_equal_nan, var_np, par_rtol );
    assert( var_compare == NULL );
    var_compare = tmp_assign_source_2;

    // Tried code:
    tmp_iter_arg_1 = PyTuple_New( 2 );
    tmp_source_name_1 = PyCell_GET( var_np );

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_iter_arg_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1344;
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_asanyarray );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = par_actual;

    frame_function->f_lineno = 1344;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = PyCell_GET( var_np );

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_iter_arg_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1344;
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_asanyarray );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = par_desired;

    frame_function->f_lineno = 1344;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_tuple_element_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 1, tmp_tuple_element_1 );
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;

    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        exception_lineno = 1344;
        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                goto try_except_handler_2;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_6 = tmp_tuple_unpack_1__element_1;

    {
        PyObject *old = par_actual;
        assert( old != NULL );
        par_actual = tmp_assign_source_6;
        Py_INCREF( par_actual );
        Py_DECREF( old );
    }

    tmp_assign_source_7 = tmp_tuple_unpack_1__element_2;

    {
        PyObject *old = par_desired;
        assert( old != NULL );
        par_desired = tmp_assign_source_7;
        Py_INCREF( par_desired );
        Py_DECREF( old );
    }

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_1 );
    Py_DECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__element_2 );
    Py_DECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_left_name_1 = const_str_digest_f17ec8fa29d8c2f383bd2b681e08c700;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_2 = PyCell_GET( par_rtol );

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "rtol" );
        exception_tb = NULL;

        exception_lineno = 1345;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = PyCell_GET( par_atol );

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "atol" );
        exception_tb = NULL;

        exception_lineno = 1345;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_2 );
    tmp_assign_source_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1345;
        goto frame_exception_exit_1;
    }
    assert( var_header == NULL );
    var_header = tmp_assign_source_8;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_compare );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_assert_array_compare );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "assert_array_compare" );
        exception_tb = NULL;

        exception_lineno = 1346;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_3 = var_compare;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = par_actual;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_3 );
    tmp_tuple_element_3 = par_desired;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_3 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_str_arg_1 = par_err_msg;

    tmp_dict_value_1 = PyObject_Str( tmp_str_arg_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1346;
        goto frame_exception_exit_1;
    }
    tmp_dict_key_1 = const_str_plain_err_msg;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    tmp_dict_value_2 = par_verbose;

    tmp_dict_key_2 = const_str_plain_verbose;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = var_header;

    tmp_dict_key_3 = const_str_plain_header;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 1347;
    tmp_unused = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1347;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_actual )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_actual,
                    par_actual
                );

                assert( res == 0 );
            }

            if ( par_desired )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_desired,
                    par_desired
                );

                assert( res == 0 );
            }

            if ( par_rtol->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rtol,
                    par_rtol->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_atol->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_atol,
                    par_atol->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_equal_nan->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_equal_nan,
                    par_equal_nan->ob_ref
                );

                assert( res == 0 );
            }

            if ( par_err_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_err_msg,
                    par_err_msg
                );

                assert( res == 0 );
            }

            if ( par_verbose )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_verbose,
                    par_verbose
                );

                assert( res == 0 );
            }

            if ( var_np->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_compare )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_compare,
                    var_compare
                );

                assert( res == 0 );
            }

            if ( var_header )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_header,
                    var_header
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_30_assert_allclose_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_rtol );
    Py_DECREF( par_rtol );
    par_rtol = NULL;

    CHECK_OBJECT( (PyObject *)par_atol );
    Py_DECREF( par_atol );
    par_atol = NULL;

    CHECK_OBJECT( (PyObject *)par_equal_nan );
    Py_DECREF( par_equal_nan );
    par_equal_nan = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    CHECK_OBJECT( (PyObject *)var_compare );
    Py_DECREF( var_compare );
    var_compare = NULL;

    CHECK_OBJECT( (PyObject *)var_header );
    Py_DECREF( var_header );
    var_header = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_actual );
    Py_DECREF( par_actual );
    par_actual = NULL;

    CHECK_OBJECT( (PyObject *)par_desired );
    Py_DECREF( par_desired );
    par_desired = NULL;

    CHECK_OBJECT( (PyObject *)par_rtol );
    Py_DECREF( par_rtol );
    par_rtol = NULL;

    CHECK_OBJECT( (PyObject *)par_atol );
    Py_DECREF( par_atol );
    par_atol = NULL;

    CHECK_OBJECT( (PyObject *)par_equal_nan );
    Py_DECREF( par_equal_nan );
    par_equal_nan = NULL;

    CHECK_OBJECT( (PyObject *)par_err_msg );
    Py_DECREF( par_err_msg );
    par_err_msg = NULL;

    CHECK_OBJECT( (PyObject *)par_verbose );
    Py_DECREF( par_verbose );
    par_verbose = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_compare );
    var_compare = NULL;

    Py_XDECREF( var_header );
    var_header = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_30_assert_allclose_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a31fcecd29c0c1003e04b552a4f105ab, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_3 = PyCell_GET( self->m_closure[2] );

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "np" );
        exception_tb = NULL;

        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_core );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_numeric );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_isclose );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = par_x;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_y;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[3] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "rtol" );
        exception_tb = NULL;

        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_rtol;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    tmp_dict_value_2 = PyCell_GET( self->m_closure[0] );

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "atol" );
        exception_tb = NULL;

        exception_lineno = 1341;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_2 = const_str_plain_atol;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    tmp_dict_value_3 = PyCell_GET( self->m_closure[1] );

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "equal_nan" );
        exception_tb = NULL;

        exception_lineno = 1342;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_3 = const_str_plain_equal_nan;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 1342;
    tmp_return_value = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1342;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[3]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rtol,
                    self->m_closure[3]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_atol,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_equal_nan,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *par_nulp = python_pars[ 2 ];
    PyObject *var_np = NULL;
    PyObject *var_ax = NULL;
    PyObject *var_ay = NULL;
    PyObject *var_ref = NULL;
    PyObject *var_msg = NULL;
    PyObject *var_max_nulp = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_make_exception_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cf664cdcbe5f723bdc04dbe913ac524e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_nulp )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_nulp,
            par_nulp
        );

        assert( res == 0 );
    }

    if ( var_np )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np
        );

        assert( res == 0 );
    }

    if ( var_ax )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ax,
            var_ax
        );

        assert( res == 0 );
    }

    if ( var_ay )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ay,
            var_ay
        );

        assert( res == 0 );
    }

    if ( var_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ref,
            var_ref
        );

        assert( res == 0 );
    }

    if ( var_msg )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_msg,
            var_msg
        );

        assert( res == 0 );
    }

    if ( var_max_nulp )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_max_nulp,
            var_max_nulp
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1398;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1398;
        goto frame_exception_exit_1;
    }
    assert( var_np == NULL );
    var_np = tmp_assign_source_1;

    tmp_source_name_1 = var_np;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_x;

    frame_function->f_lineno = 1399;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        goto frame_exception_exit_1;
    }
    assert( var_ax == NULL );
    var_ax = tmp_assign_source_2;

    tmp_source_name_2 = var_np;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_abs );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1400;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_y;

    frame_function->f_lineno = 1400;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1400;
        goto frame_exception_exit_1;
    }
    assert( var_ay == NULL );
    var_ay = tmp_assign_source_3;

    tmp_left_name_1 = par_nulp;

    tmp_source_name_3 = var_np;

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_spacing );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = var_np;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_where );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_1 = var_ax;

    tmp_compexpr_right_1 = var_ay;

    tmp_args_element_name_4 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_ax;

    tmp_args_element_name_6 = var_ay;

    frame_function->f_lineno = 1401;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1401;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = BINARY_OPERATION_MUL( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1401;
        goto frame_exception_exit_1;
    }
    assert( var_ref == NULL );
    var_ref = tmp_assign_source_4;

    tmp_source_name_5 = var_np;

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_all );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = var_np;

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_abs );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = par_x;

    tmp_right_name_2 = par_y;

    tmp_args_element_name_8 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1402;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_compexpr_left_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = var_ref;

    tmp_args_element_name_7 = RICH_COMPARE_LE( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1402;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1402;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_source_name_7 = var_np;

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_iscomplexobj );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = par_x;

    frame_function->f_lineno = 1403;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_8 = var_np;

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_iscomplexobj );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = par_y;

    frame_function->f_lineno = 1403;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_2 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1403;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_left_name_3 = const_str_digest_26a84684c8f1d9eaff79f73dc42d465f;
    tmp_right_name_3 = par_nulp;

    tmp_assign_source_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1404;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_5;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_9 = var_np;

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_max );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1406;
        goto frame_exception_exit_1;
    }
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_nulp_diff );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_nulp_diff );
    }

    if ( tmp_called_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "nulp_diff" );
        exception_tb = NULL;

        exception_lineno = 1406;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = par_x;

    tmp_args_element_name_13 = par_y;

    frame_function->f_lineno = 1406;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_args_element_name_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
    }

    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 1406;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1406;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1406;
        goto frame_exception_exit_1;
    }
    assert( var_max_nulp == NULL );
    var_max_nulp = tmp_assign_source_6;

    tmp_left_name_4 = const_str_digest_265f4d1ed58984854390f83322ffa237;
    tmp_right_name_4 = PyTuple_New( 2 );
    tmp_tuple_element_1 = par_nulp;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_max_nulp;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_1 );
    tmp_assign_source_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1407;
        goto frame_exception_exit_1;
    }
    assert( var_msg == NULL );
    var_msg = tmp_assign_source_7;

    branch_end_2:;
    tmp_make_exception_arg_1 = var_msg;

    frame_function->f_lineno = 1408;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1408;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( par_nulp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_nulp,
                    par_nulp
                );

                assert( res == 0 );
            }

            if ( var_np )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np
                );

                assert( res == 0 );
            }

            if ( var_ax )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ax,
                    var_ax
                );

                assert( res == 0 );
            }

            if ( var_ay )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ay,
                    var_ay
                );

                assert( res == 0 );
            }

            if ( var_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ref,
                    var_ref
                );

                assert( res == 0 );
            }

            if ( var_msg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_msg,
                    var_msg
                );

                assert( res == 0 );
            }

            if ( var_max_nulp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_max_nulp,
                    var_max_nulp
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_nulp );
    Py_DECREF( par_nulp );
    par_nulp = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    CHECK_OBJECT( (PyObject *)var_ax );
    Py_DECREF( var_ax );
    var_ax = NULL;

    CHECK_OBJECT( (PyObject *)var_ay );
    Py_DECREF( var_ay );
    var_ay = NULL;

    CHECK_OBJECT( (PyObject *)var_ref );
    Py_DECREF( var_ref );
    var_ref = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_nulp );
    Py_DECREF( par_nulp );
    par_nulp = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_ax );
    var_ax = NULL;

    Py_XDECREF( var_ay );
    var_ay = NULL;

    Py_XDECREF( var_ref );
    var_ref = NULL;

    Py_XDECREF( var_msg );
    var_msg = NULL;

    Py_XDECREF( var_max_nulp );
    var_max_nulp = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_32_assert_array_max_ulp_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_a = python_pars[ 0 ];
    PyObject *par_b = python_pars[ 1 ];
    PyObject *par_maxulp = python_pars[ 2 ];
    PyObject *par_dtype = python_pars[ 3 ];
    PyObject *var_np = NULL;
    PyObject *var_ret = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_96500b0fb70eb99b7f6b07ae329a54d6, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_a )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_a,
            par_a
        );

        assert( res == 0 );
    }

    if ( par_b )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_b,
            par_b
        );

        assert( res == 0 );
    }

    if ( par_maxulp )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_maxulp,
            par_maxulp
        );

        assert( res == 0 );
    }

    if ( par_dtype )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_dtype,
            par_dtype
        );

        assert( res == 0 );
    }

    if ( var_np )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np
        );

        assert( res == 0 );
    }

    if ( var_ret )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ret,
            var_ret
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1446;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        goto frame_exception_exit_1;
    }
    assert( var_np == NULL );
    var_np = tmp_assign_source_1;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_nulp_diff );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_nulp_diff );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "nulp_diff" );
        exception_tb = NULL;

        exception_lineno = 1447;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_a;

    tmp_args_element_name_2 = par_b;

    tmp_args_element_name_3 = par_dtype;

    frame_function->f_lineno = 1447;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1447;
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_2;

    tmp_source_name_1 = var_np;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_all );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1448;
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_1 = var_ret;

    tmp_compexpr_right_1 = par_maxulp;

    tmp_args_element_name_4 = RICH_COMPARE_LE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1448;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1448;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1448;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1448;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_65b92a364d9686732f28856d1578c69f;
    tmp_right_name_1 = par_maxulp;

    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1449;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1449;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1450;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_a )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_a,
                    par_a
                );

                assert( res == 0 );
            }

            if ( par_b )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_b,
                    par_b
                );

                assert( res == 0 );
            }

            if ( par_maxulp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_maxulp,
                    par_maxulp
                );

                assert( res == 0 );
            }

            if ( par_dtype )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    par_dtype
                );

                assert( res == 0 );
            }

            if ( var_np )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np
                );

                assert( res == 0 );
            }

            if ( var_ret )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ret,
                    var_ret
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_ret;

    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_32_assert_array_max_ulp_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_a );
    Py_DECREF( par_a );
    par_a = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    CHECK_OBJECT( (PyObject *)par_maxulp );
    Py_DECREF( par_maxulp );
    par_maxulp = NULL;

    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_a );
    Py_DECREF( par_a );
    par_a = NULL;

    CHECK_OBJECT( (PyObject *)par_b );
    Py_DECREF( par_b );
    par_b = NULL;

    CHECK_OBJECT( (PyObject *)par_maxulp );
    Py_DECREF( par_maxulp );
    par_maxulp = NULL;

    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_32_assert_array_max_ulp_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_33_nulp_diff_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_y = python_pars[ 1 ];
    PyObject *par_dtype = python_pars[ 2 ];
    PyCellObject *var_np = PyCell_EMPTY();
    PyObject *var_t = NULL;
    PyObject *var__diff = NULL;
    PyObject *var_rx = NULL;
    PyObject *var_ry = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_args_name_3;
    PyObject *tmp_args_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_kw_name_4;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_620b2341fdcebf2f55d1a9bce92c1454, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( par_y )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_y,
            par_y
        );

        assert( res == 0 );
    }

    if ( par_dtype )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_dtype,
            par_dtype
        );

        assert( res == 0 );
    }

    if ( var_np->ob_ref )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np->ob_ref
        );

        assert( res == 0 );
    }

    if ( var_t )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_t,
            var_t
        );

        assert( res == 0 );
    }

    if ( var__diff )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain__diff,
            var__diff
        );

        assert( res == 0 );
    }

    if ( var_rx )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_rx,
            var_rx
        );

        assert( res == 0 );
    }

    if ( var_ry )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_ry,
            var_ry
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1479;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1479;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = PyCell_GET( var_np );
        PyCell_SET( var_np, tmp_assign_source_1 );
        Py_XDECREF( old );
    }

    tmp_cond_value_1 = par_dtype;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1480;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = PyCell_GET( var_np );

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1481;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_array );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_x;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = par_dtype;

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1481;
    tmp_assign_source_2 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_x;
        assert( old != NULL );
        par_x = tmp_assign_source_2;
        Py_DECREF( old );
    }

    tmp_source_name_2 = PyCell_GET( var_np );

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1482;
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_array );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        goto frame_exception_exit_1;
    }
    tmp_args_name_2 = PyTuple_New( 1 );
    tmp_tuple_element_2 = par_y;

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_2 );
    tmp_kw_name_2 = _PyDict_NewPresized( 1 );
    tmp_dict_value_2 = par_dtype;

    tmp_dict_key_2 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    frame_function->f_lineno = 1482;
    tmp_assign_source_3 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_y;
        assert( old != NULL );
        par_y = tmp_assign_source_3;
        Py_DECREF( old );
    }

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = PyCell_GET( var_np );

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1484;
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_array );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_x;

    frame_function->f_lineno = 1484;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_x;
        assert( old != NULL );
        par_x = tmp_assign_source_4;
        Py_DECREF( old );
    }

    tmp_source_name_4 = PyCell_GET( var_np );

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1485;
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_array );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1485;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_y;

    frame_function->f_lineno = 1485;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1485;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_y;
        assert( old != NULL );
        par_y = tmp_assign_source_5;
        Py_DECREF( old );
    }

    branch_end_1:;
    tmp_source_name_5 = PyCell_GET( var_np );

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1487;
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_common_type );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1487;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_x;

    tmp_args_element_name_4 = par_y;

    frame_function->f_lineno = 1487;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1487;
        goto frame_exception_exit_1;
    }
    assert( var_t == NULL );
    var_t = tmp_assign_source_6;

    tmp_source_name_6 = PyCell_GET( var_np );

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_iscomplexobj );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_x;

    frame_function->f_lineno = 1488;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_or_left_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_source_name_7 = PyCell_GET( var_np );

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_iscomplexobj );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = par_y;

    frame_function->f_lineno = 1488;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_or_right_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_2 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1488;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_make_exception_arg_1 = const_str_digest_927431f33ccd0218ef72e4d9f521f626;
    frame_function->f_lineno = 1489;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
    }

    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1489;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_source_name_8 = PyCell_GET( var_np );

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1491;
        goto frame_exception_exit_1;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_array );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1491;
        goto frame_exception_exit_1;
    }
    tmp_args_name_3 = PyTuple_New( 1 );
    tmp_tuple_element_3 = par_x;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_args_name_3, 0, tmp_tuple_element_3 );
    tmp_kw_name_3 = _PyDict_NewPresized( 1 );
    tmp_dict_value_3 = var_t;

    tmp_dict_key_3 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->f_lineno = 1491;
    tmp_assign_source_7 = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_3, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_name_3 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1491;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_x;
        assert( old != NULL );
        par_x = tmp_assign_source_7;
        Py_DECREF( old );
    }

    tmp_source_name_9 = PyCell_GET( var_np );

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "np" );
        exception_tb = NULL;

        exception_lineno = 1492;
        goto frame_exception_exit_1;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_array );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1492;
        goto frame_exception_exit_1;
    }
    tmp_args_name_4 = PyTuple_New( 1 );
    tmp_tuple_element_4 = par_y;

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_4 );
    tmp_kw_name_4 = _PyDict_NewPresized( 1 );
    tmp_dict_value_4 = var_t;

    tmp_dict_key_4 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_4, tmp_dict_key_4, tmp_dict_value_4 );
    frame_function->f_lineno = 1492;
    tmp_assign_source_8 = CALL_FUNCTION( tmp_called_name_9, tmp_args_name_4, tmp_kw_name_4 );
    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_name_4 );
    Py_DECREF( tmp_kw_name_4 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1492;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_y;
        assert( old != NULL );
        par_y = tmp_assign_source_8;
        Py_DECREF( old );
    }

    tmp_source_name_10 = par_x;

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_shape );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1494;
        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = par_y;

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_shape );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1494;
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1494;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_left_name_1 = const_str_digest_7448f51d5d6a82072cd1cfc231b95107;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_source_name_12 = par_x;

    tmp_tuple_element_5 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_shape );
    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1496;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_5 );
    tmp_source_name_13 = par_y;

    tmp_tuple_element_5 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_shape );
    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1496;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_5 );
    tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1495;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1496;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_assign_source_9 = MAKE_FUNCTION_function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils( var_np );
    assert( var__diff == NULL );
    var__diff = tmp_assign_source_9;

    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_integer_repr );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_repr );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_repr" );
        exception_tb = NULL;

        exception_lineno = 1502;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = par_x;

    frame_function->f_lineno = 1502;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_10 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1502;
        goto frame_exception_exit_1;
    }
    assert( var_rx == NULL );
    var_rx = tmp_assign_source_10;

    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_integer_repr );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_integer_repr );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "integer_repr" );
        exception_tb = NULL;

        exception_lineno = 1503;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = par_y;

    frame_function->f_lineno = 1503;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1503;
        goto frame_exception_exit_1;
    }
    assert( var_ry == NULL );
    var_ry = tmp_assign_source_11;

    tmp_called_name_12 = var__diff;

    tmp_args_element_name_9 = var_rx;

    tmp_args_element_name_10 = var_ry;

    tmp_args_element_name_11 = var_t;

    frame_function->f_lineno = 1504;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_12, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1504;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_y )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_y,
                    par_y
                );

                assert( res == 0 );
            }

            if ( par_dtype )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    par_dtype
                );

                assert( res == 0 );
            }

            if ( var_np->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_t )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_t,
                    var_t
                );

                assert( res == 0 );
            }

            if ( var__diff )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain__diff,
                    var__diff
                );

                assert( res == 0 );
            }

            if ( var_rx )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rx,
                    var_rx
                );

                assert( res == 0 );
            }

            if ( var_ry )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ry,
                    var_ry
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_33_nulp_diff_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_y );
    Py_DECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    CHECK_OBJECT( (PyObject *)var_t );
    Py_DECREF( var_t );
    var_t = NULL;

    CHECK_OBJECT( (PyObject *)var__diff );
    Py_DECREF( var__diff );
    var__diff = NULL;

    CHECK_OBJECT( (PyObject *)var_rx );
    Py_DECREF( var_rx );
    var_rx = NULL;

    CHECK_OBJECT( (PyObject *)var_ry );
    Py_DECREF( var_ry );
    var_ry = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( par_x );
    par_x = NULL;

    Py_XDECREF( par_y );
    par_y = NULL;

    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var__diff );
    var__diff = NULL;

    Py_XDECREF( var_rx );
    var_rx = NULL;

    Py_XDECREF( var_ry );
    var_ry = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_33_nulp_diff_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_rx = python_pars[ 0 ];
    PyObject *par_ry = python_pars[ 1 ];
    PyObject *par_vdt = python_pars[ 2 ];
    PyObject *var_diff = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f46d6f13257c231e287f664132352d97, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "np" );
        exception_tb = NULL;

        exception_lineno = 1499;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_array );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1499;
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_left_name_1 = par_rx;

    tmp_right_name_1 = par_ry;

    tmp_tuple_element_1 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 1499;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = par_vdt;

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1499;
    tmp_assign_source_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1499;
        goto frame_exception_exit_1;
    }
    assert( var_diff == NULL );
    var_diff = tmp_assign_source_1;

    tmp_source_name_2 = PyCell_GET( self->m_closure[0] );

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "np" );
        exception_tb = NULL;

        exception_lineno = 1500;
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_abs );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1500;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_diff;

    frame_function->f_lineno = 1500;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1500;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_rx )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rx,
                    par_rx
                );

                assert( res == 0 );
            }

            if ( par_ry )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_ry,
                    par_ry
                );

                assert( res == 0 );
            }

            if ( par_vdt )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_vdt,
                    par_vdt
                );

                assert( res == 0 );
            }

            if ( var_diff )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_diff,
                    var_diff
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_rx );
    Py_DECREF( par_rx );
    par_rx = NULL;

    CHECK_OBJECT( (PyObject *)par_ry );
    Py_DECREF( par_ry );
    par_ry = NULL;

    CHECK_OBJECT( (PyObject *)par_vdt );
    Py_DECREF( par_vdt );
    par_vdt = NULL;

    CHECK_OBJECT( (PyObject *)var_diff );
    Py_DECREF( var_diff );
    var_diff = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_rx );
    Py_DECREF( par_rx );
    par_rx = NULL;

    CHECK_OBJECT( (PyObject *)par_ry );
    Py_DECREF( par_ry );
    par_ry = NULL;

    CHECK_OBJECT( (PyObject *)par_vdt );
    Py_DECREF( par_vdt );
    par_vdt = NULL;

    Py_XDECREF( var_diff );
    var_diff = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_34__integer_repr_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *par_vdt = python_pars[ 1 ];
    PyObject *par_comp = python_pars[ 2 ];
    PyObject *var_rx = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cd5bb3d79c37ce8371d5f35c9ec85905, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = par_x;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_view );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1511;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_vdt;

    frame_function->f_lineno = 1511;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1511;
        goto frame_exception_exit_1;
    }
    assert( var_rx == NULL );
    var_rx = tmp_assign_source_1;

    tmp_source_name_2 = var_rx;

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_size );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1512;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_1;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1512;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = par_comp;

    tmp_subscribed_name_1 = var_rx;

    tmp_compexpr_left_1 = var_rx;

    tmp_compexpr_right_1 = const_int_0;
    tmp_subscript_name_1 = RICH_COMPARE_LT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_subscript_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscript_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_1 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = var_rx;

    tmp_compexpr_left_2 = var_rx;

    tmp_compexpr_right_2 = const_int_0;
    tmp_ass_subscript_1 = RICH_COMPARE_LT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    if ( tmp_ass_subscript_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1513;
        goto frame_exception_exit_1;
    }
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscript_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1513;
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_compare_left_2 = var_rx;

    tmp_compare_right_2 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1515;
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_left_name_2 = par_comp;

    tmp_right_name_2 = var_rx;

    tmp_assign_source_2 = BINARY_OPERATION_SUB( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1516;
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_rx;
        assert( old != NULL );
        var_rx = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_2:;
    branch_end_1:;
    tmp_return_value = var_rx;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "rx" );
        exception_tb = NULL;

        exception_lineno = 1518;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( par_vdt )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_vdt,
                    par_vdt
                );

                assert( res == 0 );
            }

            if ( par_comp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_comp,
                    par_comp
                );

                assert( res == 0 );
            }

            if ( var_rx )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_rx,
                    var_rx
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_34__integer_repr_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_vdt );
    Py_DECREF( par_vdt );
    par_vdt = NULL;

    CHECK_OBJECT( (PyObject *)par_comp );
    Py_DECREF( par_comp );
    par_comp = NULL;

    Py_XDECREF( var_rx );
    var_rx = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)par_vdt );
    Py_DECREF( par_vdt );
    par_vdt = NULL;

    CHECK_OBJECT( (PyObject *)par_comp );
    Py_DECREF( par_comp );
    par_comp = NULL;

    Py_XDECREF( var_rx );
    var_rx = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_34__integer_repr_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_35_integer_repr_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *var_np = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_locals_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b88dc4f1201a03e15379a75926b9b64d, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    tmp_import_locals_1 = PyDict_New();
    if ( par_x )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_x,
            par_x
        );

        assert( res == 0 );
    }

    if ( var_np )
    {
        int res = PyDict_SetItem(
            tmp_import_locals_1,
            const_str_plain_np,
            var_np
        );

        assert( res == 0 );
    }

    frame_function->f_lineno = 1523;
    tmp_assign_source_1 = IMPORT_MODULE( const_str_plain_numpy, tmp_import_globals_1, tmp_import_locals_1, Py_None, const_int_0 );
    Py_DECREF( tmp_import_locals_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1523;
        goto frame_exception_exit_1;
    }
    assert( var_np == NULL );
    var_np = tmp_assign_source_1;

    tmp_source_name_1 = par_x;

    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_dtype );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1524;
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = var_np;

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_float32 );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1524;
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 1524;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain__integer_repr );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__integer_repr );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_integer_repr" );
        exception_tb = NULL;

        exception_lineno = 1525;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_x;

    tmp_source_name_3 = var_np;

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_int32 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1525;
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = var_np;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_int32 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1525;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1525;
    tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_long_neg_2147483648_tuple, 0 ) );

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1525;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1525;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1525;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_5 = par_x;

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_dtype );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1526;
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = var_np;

    tmp_compare_right_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_float64 );
    if ( tmp_compare_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1526;
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 1526;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain__integer_repr );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__integer_repr );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "_integer_repr" );
        exception_tb = NULL;

        exception_lineno = 1527;
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_x;

    tmp_source_name_7 = var_np;

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_int64 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1527;
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = var_np;

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_int64 );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1527;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1527;
    tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_long_neg_9223372036854775808_tuple, 0 ) );

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1527;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1527;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1527;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_left_name_1 = const_str_digest_e730e08a5048288138d6a29cf19c1970;
    tmp_source_name_9 = par_x;

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_dtype );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        goto frame_exception_exit_1;
    }
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1529;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_ValueError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1529;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_x )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_x,
                    par_x
                );

                assert( res == 0 );
            }

            if ( var_np )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_np,
                    var_np
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_35_integer_repr_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_np );
    Py_DECREF( var_np );
    var_np = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_35_integer_repr_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_class_1_WarningMessage_of_numpy$testing$utils( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var___doc__ = NULL;
    PyObject *var__WARNING_DETAILS = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var___str__ = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_defaults_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_digest_bfe64da05de8ea9d3dc43fbc0c1219dc;
    assert( var___doc__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___doc__ = tmp_assign_source_2;

    tmp_assign_source_3 = const_tuple_3866cf064071516dd9f2d31820e48b6c_tuple;
    assert( var__WARNING_DETAILS == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var__WARNING_DETAILS = tmp_assign_source_3;

    tmp_defaults_1 = const_tuple_none_none_tuple;
    tmp_assign_source_4 = MAKE_FUNCTION_function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ) );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_4;

    tmp_assign_source_5 = MAKE_FUNCTION_function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils(  );
    assert( var___str__ == NULL );
    var___str__ = tmp_assign_source_5;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var___doc__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___doc__,
            var___doc__
        );

        assert( res == 0 );
    }

    if ( var__WARNING_DETAILS )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__WARNING_DETAILS,
            var__WARNING_DETAILS
        );

        assert( res == 0 );
    }

    if ( var___init__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___init__,
            var___init__
        );

        assert( res == 0 );
    }

    if ( var___str__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___str__,
            var___str__
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;

    CHECK_OBJECT( (PyObject *)var__WARNING_DETAILS );
    Py_DECREF( var__WARNING_DETAILS );
    var__WARNING_DETAILS = NULL;

    CHECK_OBJECT( (PyObject *)var___init__ );
    Py_DECREF( var___init__ );
    var___init__ = NULL;

    CHECK_OBJECT( (PyObject *)var___str__ );
    Py_DECREF( var___str__ );
    var___str__ = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_message = python_pars[ 1 ];
    PyObject *par_category = python_pars[ 2 ];
    PyObject *par_filename = python_pars[ 3 ];
    PyObject *par_lineno = python_pars[ 4 ];
    PyObject *par_file = python_pars[ 5 ];
    PyObject *par_line = python_pars[ 6 ];
    PyObject *var_local_values = NULL;
    PyObject *var_attr = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_setattr_attr_1;
    PyObject *tmp_setattr_target_1;
    PyObject *tmp_setattr_value_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyDict_New();
    if ( par_self )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_self,
            par_self
        );

        assert( res == 0 );
    }

    if ( par_message )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_message,
            par_message
        );

        assert( res == 0 );
    }

    if ( par_category )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_category,
            par_category
        );

        assert( res == 0 );
    }

    if ( par_filename )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_filename,
            par_filename
        );

        assert( res == 0 );
    }

    if ( par_lineno )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_lineno,
            par_lineno
        );

        assert( res == 0 );
    }

    if ( par_file )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_file,
            par_file
        );

        assert( res == 0 );
    }

    if ( par_line )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_line,
            par_line
        );

        assert( res == 0 );
    }

    if ( var_local_values )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_local_values,
            var_local_values
        );

        assert( res == 0 );
    }

    if ( var_attr )
    {
        int res = PyDict_SetItem(
            tmp_assign_source_1,
            const_str_plain_attr,
            var_attr
        );

        assert( res == 0 );
    }

    assert( var_local_values == NULL );
    var_local_values = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a6ccce2decf1b651db1c2fa11a115723, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = par_self;

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__WARNING_DETAILS );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1553;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_attr;
        var_attr = tmp_assign_source_4;
        Py_INCREF( var_attr );
        Py_XDECREF( old );
    }

    tmp_setattr_target_1 = par_self;

    tmp_setattr_attr_1 = var_attr;

    tmp_subscribed_name_1 = var_local_values;

    tmp_subscript_name_1 = var_attr;

    tmp_setattr_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_setattr_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1554;
        goto try_except_handler_2;
    }
    tmp_unused = BUILTIN_SETATTR( tmp_setattr_target_1, tmp_setattr_attr_1, tmp_setattr_value_1 );
    Py_DECREF( tmp_setattr_value_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1554;
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1553;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_cond_value_1 = par_category;

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1555;
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_category;

    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___name__ );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1556;
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__category_name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1556;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    goto branch_end_1;
    branch_no_1:;
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__category_name, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1558;
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_message )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_message,
                    par_message
                );

                assert( res == 0 );
            }

            if ( par_category )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_category,
                    par_category
                );

                assert( res == 0 );
            }

            if ( par_filename )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_filename,
                    par_filename
                );

                assert( res == 0 );
            }

            if ( par_lineno )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_lineno,
                    par_lineno
                );

                assert( res == 0 );
            }

            if ( par_file )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_file,
                    par_file
                );

                assert( res == 0 );
            }

            if ( par_line )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_line,
                    par_line
                );

                assert( res == 0 );
            }

            if ( var_local_values )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_local_values,
                    var_local_values
                );

                assert( res == 0 );
            }

            if ( var_attr )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_attr,
                    var_attr
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_category );
    Py_DECREF( par_category );
    par_category = NULL;

    CHECK_OBJECT( (PyObject *)par_filename );
    Py_DECREF( par_filename );
    par_filename = NULL;

    CHECK_OBJECT( (PyObject *)par_lineno );
    Py_DECREF( par_lineno );
    par_lineno = NULL;

    CHECK_OBJECT( (PyObject *)par_file );
    Py_DECREF( par_file );
    par_file = NULL;

    CHECK_OBJECT( (PyObject *)par_line );
    Py_DECREF( par_line );
    par_line = NULL;

    CHECK_OBJECT( (PyObject *)var_local_values );
    Py_DECREF( var_local_values );
    var_local_values = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_message );
    Py_DECREF( par_message );
    par_message = NULL;

    CHECK_OBJECT( (PyObject *)par_category );
    Py_DECREF( par_category );
    par_category = NULL;

    CHECK_OBJECT( (PyObject *)par_filename );
    Py_DECREF( par_filename );
    par_filename = NULL;

    CHECK_OBJECT( (PyObject *)par_lineno );
    Py_DECREF( par_lineno );
    par_lineno = NULL;

    CHECK_OBJECT( (PyObject *)par_file );
    Py_DECREF( par_file );
    par_file = NULL;

    CHECK_OBJECT( (PyObject *)par_line );
    Py_DECREF( par_line );
    par_line = NULL;

    CHECK_OBJECT( (PyObject *)var_local_values );
    Py_DECREF( var_local_values );
    var_local_values = NULL;

    Py_XDECREF( var_attr );
    var_attr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_5ba100fadd74ce880b2ab679d91f1887, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_left_name_1 = const_str_digest_97ac1738f0f1baa91e1ac43976924303;
    tmp_right_name_1 = PyTuple_New( 5 );
    tmp_source_name_1 = par_self;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_message );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1562;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = par_self;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__category_name );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1562;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = par_self;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_filename );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1563;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 2, tmp_tuple_element_1 );
    tmp_source_name_4 = par_self;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_lineno );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1563;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 3, tmp_tuple_element_1 );
    tmp_source_name_5 = par_self;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_line );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1563;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 4, tmp_tuple_element_1 );
    tmp_return_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1561;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_class_2_WarningManager_of_numpy$testing$utils( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var___doc__ = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var___enter__ = NULL;
    PyObject *var___exit__ = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_defaults_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_digest_2ba8069a0e65272b7d5eefe3de48df04;
    assert( var___doc__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___doc__ = tmp_assign_source_2;

    tmp_defaults_1 = const_tuple_false_none_tuple;
    tmp_assign_source_3 = MAKE_FUNCTION_function_1___init___of_class_2_WarningManager_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ) );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_3;

    tmp_assign_source_4 = MAKE_FUNCTION_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils(  );
    assert( var___enter__ == NULL );
    var___enter__ = tmp_assign_source_4;

    tmp_assign_source_5 = MAKE_FUNCTION_function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils(  );
    assert( var___exit__ == NULL );
    var___exit__ = tmp_assign_source_5;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var___doc__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___doc__,
            var___doc__
        );

        assert( res == 0 );
    }

    if ( var___init__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___init__,
            var___init__
        );

        assert( res == 0 );
    }

    if ( var___enter__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___enter__,
            var___enter__
        );

        assert( res == 0 );
    }

    if ( var___exit__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___exit__,
            var___exit__
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( class_2_WarningManager_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;

    CHECK_OBJECT( (PyObject *)var___init__ );
    Py_DECREF( var___init__ );
    var___init__ = NULL;

    CHECK_OBJECT( (PyObject *)var___enter__ );
    Py_DECREF( var___enter__ );
    var___enter__ = NULL;

    CHECK_OBJECT( (PyObject *)var___exit__ );
    Py_DECREF( var___exit__ );
    var___exit__ = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( class_2_WarningManager_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1___init___of_class_2_WarningManager_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_record = python_pars[ 1 ];
    PyObject *par_module = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9ecb26975b952a181c2d41916c1878f4, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_assattr_name_1 = par_record;

    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__record, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1591;
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = par_module;

    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 1593;
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_modules );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1593;
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_str_plain_warnings;
    tmp_assattr_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1593;
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__module, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1593;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    goto branch_end_1;
    branch_no_1:;
    tmp_assattr_name_3 = par_module;

    tmp_assattr_target_3 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__module, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1595;
        goto frame_exception_exit_1;
    }
    branch_end_1:;
    tmp_assattr_name_4 = Py_False;
    tmp_assattr_target_4 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__entered, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1596;
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_record )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_record,
                    par_record
                );

                assert( res == 0 );
            }

            if ( par_module )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_module,
                    par_module
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_record );
    Py_DECREF( par_record );
    par_record = NULL;

    CHECK_OBJECT( (PyObject *)par_module );
    Py_DECREF( par_module );
    par_module = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_record );
    Py_DECREF( par_record );
    par_record = NULL;

    CHECK_OBJECT( (PyObject *)par_module );
    Py_DECREF( par_module );
    par_module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyCellObject *var_log = PyCell_EMPTY();
    PyObject *var_showwarning = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_frame_locals;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_129f616448917821adcf6ec6720fa727, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = par_self;

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__entered );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1599;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1599;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_794995e7a92670372eca23dc277265d0;
    tmp_right_name_1 = par_self;

    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1600;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1600;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1600;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_assattr_name_1 = Py_True;
    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__entered, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1601;
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__module );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1602;
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_filters );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1602;
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__filters, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1602;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_source_name_4 = par_self;

    tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__filters );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_3 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    tmp_assattr_target_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__module );
    if ( tmp_assattr_target_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 1603;
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_filters, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );
        Py_DECREF( tmp_assattr_target_3 );

        exception_lineno = 1603;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );
    Py_DECREF( tmp_assattr_target_3 );
    tmp_source_name_7 = par_self;

    tmp_source_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__module );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1604;
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_showwarning );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_assattr_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1604;
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_4 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__showwarning, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 1604;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    tmp_source_name_8 = par_self;

    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__record );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1605;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1605;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_1 = PyList_New( 0 );
    {
        PyObject *old = PyCell_GET( var_log );
        PyCell_SET( var_log, tmp_assign_source_1 );
        Py_XDECREF( old );
    }

    tmp_assign_source_2 = MAKE_FUNCTION_function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils( var_log );
    assert( var_showwarning == NULL );
    var_showwarning = tmp_assign_source_2;

    tmp_assattr_name_5 = var_showwarning;

    tmp_source_name_9 = par_self;

    tmp_assattr_target_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__module );
    if ( tmp_assattr_target_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1610;
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_showwarning, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_target_5 );

        exception_lineno = 1610;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_target_5 );
    tmp_return_value = PyCell_GET( var_log );

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "log" );
        exception_tb = NULL;

        exception_lineno = 1611;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( var_log->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_log,
                    var_log->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_showwarning )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_showwarning,
                    var_showwarning
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_log );
    Py_DECREF( var_log );
    var_log = NULL;

    Py_XDECREF( var_showwarning );
    var_showwarning = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_log );
    Py_DECREF( var_log );
    var_log = NULL;

    Py_XDECREF( var_showwarning );
    var_showwarning = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_args = python_pars[ 0 ];
    PyObject *par_kwargs = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bedbec43eef32e147159ef476305f109, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "log" );
        exception_tb = NULL;

        exception_lineno = 1609;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_WarningMessage );

    if (unlikely( tmp_dircall_arg1_1 == NULL ))
    {
        tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_WarningMessage );
    }

    if ( tmp_dircall_arg1_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "WarningMessage" );
        exception_tb = NULL;

        exception_lineno = 1609;
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kwargs;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_args_element_name_1 = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1609;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1609;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kwargs )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    par_kwargs
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_log,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_left_name_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_85689a2364b31f10b51f5a64448c6719, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = par_self;

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__entered );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1616;
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1616;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_9272fa8326047e802806f21006304928;
    tmp_right_name_1 = par_self;

    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1617;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1617;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_RuntimeError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1617;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__filters );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__module );
    if ( tmp_assattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1618;
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_filters, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_target_1 );

        exception_lineno = 1618;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_target_1 );
    tmp_source_name_4 = par_self;

    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__showwarning );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1619;
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_self;

    tmp_assattr_target_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__module );
    if ( tmp_assattr_target_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1619;
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_showwarning, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );
        Py_DECREF( tmp_assattr_target_2 );

        exception_lineno = 1619;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    Py_DECREF( tmp_assattr_target_2 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_36_assert_warns_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_warning_class = python_pars[ 0 ];
    PyObject *par_func = python_pars[ 1 ];
    PyObject *par_args = python_pars[ 2 ];
    PyObject *par_kw = python_pars[ 3 ];
    PyObject *var_l = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_isnot_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_make_exception_arg_2;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e21fdf4eeb0bfc5a06db8cfc887f8959, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 1649;
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_catch_warnings );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_2;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_aae7649b9175b1ed5738500d56e46831 );
    frame_function->f_lineno = 1649;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_1;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_assign_source_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_2;

    tmp_source_name_3 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1649;
    tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_3;

    tmp_assign_source_4 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_4 );
    tmp_with_1__indicator = tmp_assign_source_4;

    tmp_assign_source_5 = tmp_with_1__enter;

    assert( var_l == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_l = tmp_assign_source_5;

    // Tried code:
    // Tried code:
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 1650;
        goto try_except_handler_4;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_simplefilter );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1650;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 1650;
    tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_plain_always_tuple, 0 ) );

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1650;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_dircall_arg1_1 = par_func;

    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kw;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_assign_source_6 = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1651;
        goto try_except_handler_4;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_6;

    tmp_len_arg_1 = var_l;

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1652;
        goto try_except_handler_4;
    }
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1652;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_a45c67b2be89c200cea2763464bafa08;
    tmp_source_name_5 = par_func;

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___name__ );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1654;
        goto try_except_handler_4;
    }
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1653;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 1653;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1654;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_1:;
    tmp_subscribed_name_1 = var_l;

    tmp_subscript_name_1 = const_int_0;
    tmp_source_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1655;
        goto try_except_handler_4;
    }
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_category );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1655;
        goto try_except_handler_4;
    }
    tmp_compare_right_2 = par_warning_class;

    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_left_name_2 = const_str_digest_34e2f0683aaa71a2e4c98472a81cd441;
    tmp_right_name_2 = PyTuple_New( 3 );
    tmp_source_name_7 = par_func;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___name__ );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_2 );

        exception_lineno = 1657;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_warning_class;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = var_l;

    tmp_subscript_name_2 = const_int_0;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_2 );

        exception_lineno = 1657;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_right_name_2, 2, tmp_tuple_element_1 );
    tmp_make_exception_arg_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_make_exception_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1656;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 1656;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_2 };
        tmp_raise_type_2 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_2 );
    assert( tmp_raise_type_2 != NULL );
    exception_type = tmp_raise_type_2;
    exception_lineno = 1657;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_2:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1649;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_7 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_7;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_4 = tmp_with_1__exit;

    tmp_args_element_name_1 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_2 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_3 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 1657;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1657;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1657;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_4:;
    goto branch_end_3;
    branch_no_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_3:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_36_assert_warns_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_4 = tmp_with_1__indicator;

    tmp_compare_right_4 = Py_True;
    tmp_is_1 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 1657;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1657;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_5 = tmp_with_1__indicator;

    tmp_compare_right_5 = Py_True;
    tmp_is_2 = ( tmp_compare_left_5 == tmp_compare_right_5 );
    if ( tmp_is_2 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_6 = tmp_with_1__exit;

    frame_function->f_lineno = 1657;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1657;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 1658;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_warning_class )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_warning_class,
                    par_warning_class
                );

                assert( res == 0 );
            }

            if ( par_func )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_func,
                    par_func
                );

                assert( res == 0 );
            }

            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kw )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kw,
                    par_kw
                );

                assert( res == 0 );
            }

            if ( var_l )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_l,
                    var_l
                );

                assert( res == 0 );
            }

            if ( var_result )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_result,
                    var_result
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_36_assert_warns_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_warning_class );
    Py_DECREF( par_warning_class );
    par_warning_class = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_warning_class );
    Py_DECREF( par_warning_class );
    par_warning_class = NULL;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_36_assert_warns_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_37_assert_no_warnings_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_func = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_l = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_with_1__source = NULL;
    PyObject *tmp_with_1__exit = NULL;
    PyObject *tmp_with_1__enter = NULL;
    PyObject *tmp_with_1__indicator = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    int tmp_exc_match_exception_match_1;
    PyObject *tmp_frame_locals;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_49a0f05b2207530323b591c3cb8e653e, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    // Tried code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 1680;
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_catch_warnings );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_2;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_aae7649b9175b1ed5738500d56e46831 );
    frame_function->f_lineno = 1680;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__source == NULL );
    tmp_with_1__source = tmp_assign_source_1;

    tmp_source_name_2 = tmp_with_1__source;

    tmp_assign_source_2 = LOOKUP_SPECIAL( tmp_source_name_2, const_str_plain___exit__ );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__exit == NULL );
    tmp_with_1__exit = tmp_assign_source_2;

    tmp_source_name_3 = tmp_with_1__source;

    tmp_called_name_2 = LOOKUP_SPECIAL( tmp_source_name_3, const_str_plain___enter__ );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1680;
    tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_2;
    }
    assert( tmp_with_1__enter == NULL );
    tmp_with_1__enter = tmp_assign_source_3;

    tmp_assign_source_4 = Py_True;
    assert( tmp_with_1__indicator == NULL );
    Py_INCREF( tmp_assign_source_4 );
    tmp_with_1__indicator = tmp_assign_source_4;

    tmp_assign_source_5 = tmp_with_1__enter;

    assert( var_l == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_l = tmp_assign_source_5;

    // Tried code:
    // Tried code:
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 1681;
        goto try_except_handler_4;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_simplefilter );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1681;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 1681;
    tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_plain_always_tuple, 0 ) );

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1681;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_unused );
    tmp_dircall_arg1_1 = par_func;

    tmp_dircall_arg2_1 = par_args;

    tmp_dircall_arg3_1 = par_kw;

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_assign_source_6 = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1682;
        goto try_except_handler_4;
    }
    assert( var_result == NULL );
    var_result = tmp_assign_source_6;

    tmp_len_arg_1 = var_l;

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1683;
        goto try_except_handler_4;
    }
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1683;
        goto try_except_handler_4;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_left_name_1 = const_str_digest_98da8b224f1d546fc73cc79ce8ec2f64;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_source_name_5 = par_func;

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain___name__ );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1685;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_l;

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1684;
        goto try_except_handler_4;
    }
    frame_function->f_lineno = 1684;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_AssertionError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1685;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    goto try_except_handler_4;
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_1 == NULL )
    {
        exception_keeper_tb_1 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_1 );
    }
    else if ( exception_keeper_lineno_1 != -1 )
    {
        exception_keeper_tb_1 = ADD_TRACEBACK( exception_keeper_tb_1, frame_function, exception_keeper_lineno_1 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    PUBLISH_EXCEPTION( &exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1 );
    tmp_compare_left_2 = PyThreadState_GET()->exc_type;
    tmp_compare_right_2 = PyExc_BaseException;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        goto try_except_handler_3;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_7 = Py_False;
    {
        PyObject *old = tmp_with_1__indicator;
        assert( old != NULL );
        tmp_with_1__indicator = tmp_assign_source_7;
        Py_INCREF( tmp_with_1__indicator );
        Py_DECREF( old );
    }

    tmp_called_name_4 = tmp_with_1__exit;

    tmp_args_element_name_1 = PyThreadState_GET()->exc_type;
    tmp_args_element_name_2 = PyThreadState_GET()->exc_value;
    tmp_args_element_name_3 = PyThreadState_GET()->exc_traceback;
    frame_function->f_lineno = 1685;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1685;
        goto try_except_handler_3;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1685;
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == frame_function) frame_function->f_lineno = exception_tb->tb_lineno;
    goto try_except_handler_3;
    branch_end_2:;
    goto try_end_1;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_37_assert_no_warnings_of_numpy$testing$utils );
    return NULL;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    tmp_compare_left_3 = tmp_with_1__indicator;

    tmp_compare_right_3 = Py_True;
    tmp_is_1 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_name_5 = tmp_with_1__exit;

    frame_function->f_lineno = 1685;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        Py_DECREF( exception_keeper_type_2 );
        Py_XDECREF( exception_keeper_value_2 );
        Py_XDECREF( exception_keeper_tb_2 );

        exception_lineno = 1685;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    tmp_compare_left_4 = tmp_with_1__indicator;

    tmp_compare_right_4 = Py_True;
    tmp_is_2 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    if ( tmp_is_2 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_name_6 = tmp_with_1__exit;

    frame_function->f_lineno = 1685;
    tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1685;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    Py_XDECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    Py_XDECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_with_1__source );
    Py_DECREF( tmp_with_1__source );
    tmp_with_1__source = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__enter );
    Py_DECREF( tmp_with_1__enter );
    tmp_with_1__enter = NULL;

    CHECK_OBJECT( (PyObject *)tmp_with_1__exit );
    Py_DECREF( tmp_with_1__exit );
    tmp_with_1__exit = NULL;

    Py_XDECREF( tmp_with_1__indicator );
    tmp_with_1__indicator = NULL;

    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 1686;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_func )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_func,
                    par_func
                );

                assert( res == 0 );
            }

            if ( par_args )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    par_args
                );

                assert( res == 0 );
            }

            if ( par_kw )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kw,
                    par_kw
                );

                assert( res == 0 );
            }

            if ( var_l )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_l,
                    var_l
                );

                assert( res == 0 );
            }

            if ( var_result )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_result,
                    var_result
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_37_assert_no_warnings_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_func );
    Py_DECREF( par_func );
    par_func = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_37_assert_no_warnings_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_38__gen_alignment_data_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyCellObject *par_dtype = PyCell_NEW1( python_pars[ 0 ] );
    PyCellObject *par_type = PyCell_NEW1( python_pars[ 1 ] );
    PyCellObject *par_max_size = PyCell_NEW1( python_pars[ 2 ] );
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    {
        PyCellObject **closure = (PyCellObject **)malloc(3 * sizeof(PyCellObject *));
        closure[0] = par_dtype;
        Py_INCREF( closure[0] );
        closure[1] = par_max_size;
        Py_INCREF( closure[1] );
        closure[2] = par_type;
        Py_INCREF( closure[2] );

        tmp_return_value = Nuitka_Generator_New(
            genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils_context,
            const_str_plain__gen_alignment_data,
#if PYTHON_VERSION >= 350
            NULL,
#endif
            codeobj_7d0a5268db158ba066fa108948276239,
            closure,
            3
        );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_38__gen_alignment_data_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_max_size );
    Py_DECREF( par_max_size );
    par_max_size = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_dtype );
    Py_DECREF( par_dtype );
    par_dtype = NULL;

    CHECK_OBJECT( (PyObject *)par_type );
    Py_DECREF( par_type );
    par_type = NULL;

    CHECK_OBJECT( (PyObject *)par_max_size );
    Py_DECREF( par_max_size );
    par_max_size = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_38__gen_alignment_data_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static void genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils_context( Nuitka_GeneratorObject *generator )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyCellObject *var_o = PyCell_EMPTY();
    PyCellObject *var_s = PyCell_EMPTY();
    PyObject *var_inp = NULL;
    PyObject *var_out = NULL;
    PyObject *var_inp1 = NULL;
    PyObject *var_inp2 = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_called_name_32;
    PyObject *tmp_called_name_33;
    PyObject *tmp_called_name_34;
    PyObject *tmp_called_name_35;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_expression_name_2;
    PyObject *tmp_expression_name_3;
    PyObject *tmp_expression_name_4;
    PyObject *tmp_expression_name_5;
    PyObject *tmp_expression_name_6;
    PyObject *tmp_expression_name_7;
    PyObject *tmp_expression_name_8;
    PyObject *tmp_expression_name_9;
    PyObject *tmp_expression_name_10;
    PyObject *tmp_expression_name_11;
    PyObject *tmp_expression_name_12;
    PyObject *tmp_expression_name_13;
    PyObject *tmp_expression_name_14;
    PyObject *tmp_expression_name_15;
    PyObject *tmp_frame_locals;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_left_name_16;
    PyObject *tmp_left_name_17;
    PyObject *tmp_left_name_18;
    PyObject *tmp_left_name_19;
    PyObject *tmp_left_name_20;
    PyObject *tmp_left_name_21;
    PyObject *tmp_left_name_22;
    PyObject *tmp_left_name_23;
    PyObject *tmp_left_name_24;
    PyObject *tmp_left_name_25;
    PyObject *tmp_left_name_26;
    PyObject *tmp_left_name_27;
    PyObject *tmp_left_name_28;
    PyObject *tmp_left_name_29;
    PyObject *tmp_left_name_30;
    PyObject *tmp_left_name_31;
    PyObject *tmp_left_name_32;
    PyObject *tmp_left_name_33;
    PyObject *tmp_left_name_34;
    PyObject *tmp_left_name_35;
    PyObject *tmp_left_name_36;
    PyObject *tmp_left_name_37;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_range2_high_1;
    PyObject *tmp_range2_low_1;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_right_name_16;
    PyObject *tmp_right_name_17;
    PyObject *tmp_right_name_18;
    PyObject *tmp_right_name_19;
    PyObject *tmp_right_name_20;
    PyObject *tmp_right_name_21;
    PyObject *tmp_right_name_22;
    PyObject *tmp_right_name_23;
    PyObject *tmp_right_name_24;
    PyObject *tmp_right_name_25;
    PyObject *tmp_right_name_26;
    PyObject *tmp_right_name_27;
    PyObject *tmp_right_name_28;
    PyObject *tmp_right_name_29;
    PyObject *tmp_right_name_30;
    PyObject *tmp_right_name_31;
    PyObject *tmp_right_name_32;
    PyObject *tmp_right_name_33;
    PyObject *tmp_right_name_34;
    PyObject *tmp_right_name_35;
    PyObject *tmp_right_name_36;
    PyObject *tmp_right_name_37;
    Py_ssize_t tmp_slice_index_upper_1;
    Py_ssize_t tmp_slice_index_upper_2;
    Py_ssize_t tmp_slice_index_upper_3;
    Py_ssize_t tmp_slice_index_upper_4;
    Py_ssize_t tmp_slice_index_upper_5;
    Py_ssize_t tmp_slice_index_upper_6;
    Py_ssize_t tmp_slice_index_upper_7;
    Py_ssize_t tmp_slice_index_upper_8;
    Py_ssize_t tmp_slice_index_upper_9;
    Py_ssize_t tmp_slice_index_upper_10;
    Py_ssize_t tmp_slice_index_upper_11;
    Py_ssize_t tmp_slice_index_upper_12;
    Py_ssize_t tmp_slice_index_upper_13;
    Py_ssize_t tmp_slice_index_upper_14;
    Py_ssize_t tmp_slice_index_upper_15;
    Py_ssize_t tmp_slice_index_upper_16;
    Py_ssize_t tmp_slice_index_upper_17;
    Py_ssize_t tmp_slice_index_upper_18;
    Py_ssize_t tmp_slice_index_upper_19;
    Py_ssize_t tmp_slice_index_upper_20;
    Py_ssize_t tmp_slice_index_upper_21;
    Py_ssize_t tmp_slice_index_upper_22;
    Py_ssize_t tmp_slice_index_upper_23;
    Py_ssize_t tmp_slice_index_upper_24;
    Py_ssize_t tmp_slice_index_upper_25;
    Py_ssize_t tmp_slice_index_upper_26;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_lower_2;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_slice_source_2;
    PyObject *tmp_slice_source_3;
    PyObject *tmp_slice_source_4;
    PyObject *tmp_slice_source_5;
    PyObject *tmp_slice_source_6;
    PyObject *tmp_slice_source_7;
    PyObject *tmp_slice_source_8;
    PyObject *tmp_slice_source_9;
    PyObject *tmp_slice_source_10;
    PyObject *tmp_slice_source_11;
    PyObject *tmp_slice_source_12;
    PyObject *tmp_slice_source_13;
    PyObject *tmp_slice_source_14;
    PyObject *tmp_slice_source_15;
    PyObject *tmp_slice_source_16;
    PyObject *tmp_slice_source_17;
    PyObject *tmp_slice_source_18;
    PyObject *tmp_slice_source_19;
    PyObject *tmp_slice_source_20;
    PyObject *tmp_slice_source_21;
    PyObject *tmp_slice_source_22;
    PyObject *tmp_slice_source_23;
    PyObject *tmp_slice_source_24;
    PyObject *tmp_slice_source_25;
    PyObject *tmp_slice_source_26;
    PyObject *tmp_slice_source_27;
    PyObject *tmp_slice_source_28;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_2;
    Py_ssize_t tmp_sliceslicedel_index_lower_3;
    Py_ssize_t tmp_sliceslicedel_index_lower_4;
    Py_ssize_t tmp_sliceslicedel_index_lower_5;
    Py_ssize_t tmp_sliceslicedel_index_lower_6;
    Py_ssize_t tmp_sliceslicedel_index_lower_7;
    Py_ssize_t tmp_sliceslicedel_index_lower_8;
    Py_ssize_t tmp_sliceslicedel_index_lower_9;
    Py_ssize_t tmp_sliceslicedel_index_lower_10;
    Py_ssize_t tmp_sliceslicedel_index_lower_11;
    Py_ssize_t tmp_sliceslicedel_index_lower_12;
    Py_ssize_t tmp_sliceslicedel_index_lower_13;
    Py_ssize_t tmp_sliceslicedel_index_lower_14;
    Py_ssize_t tmp_sliceslicedel_index_lower_15;
    Py_ssize_t tmp_sliceslicedel_index_lower_16;
    Py_ssize_t tmp_sliceslicedel_index_lower_17;
    Py_ssize_t tmp_sliceslicedel_index_lower_18;
    Py_ssize_t tmp_sliceslicedel_index_lower_19;
    Py_ssize_t tmp_sliceslicedel_index_lower_20;
    Py_ssize_t tmp_sliceslicedel_index_lower_21;
    Py_ssize_t tmp_sliceslicedel_index_lower_22;
    Py_ssize_t tmp_sliceslicedel_index_lower_23;
    Py_ssize_t tmp_sliceslicedel_index_lower_24;
    Py_ssize_t tmp_sliceslicedel_index_lower_25;
    Py_ssize_t tmp_sliceslicedel_index_lower_26;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyObject *tmp_tuple_element_9;
    PyObject *tmp_tuple_element_10;
    PyObject *tmp_tuple_element_11;
    PyObject *tmp_tuple_element_12;
    PyObject *tmp_tuple_element_13;
    PyObject *tmp_tuple_element_14;
    PyObject *tmp_tuple_element_15;
    PyObject *tmp_tuple_element_16;
    PyObject *tmp_tuple_element_17;
    PyObject *tmp_tuple_element_18;
    PyObject *tmp_tuple_element_19;
    PyObject *tmp_tuple_element_20;
    PyObject *tmp_tuple_element_21;
    PyObject *tmp_tuple_element_22;
    PyObject *tmp_tuple_element_23;
    PyObject *tmp_tuple_element_24;
    PyObject *tmp_tuple_element_25;
    PyObject *tmp_tuple_element_26;
    PyObject *tmp_tuple_element_27;
    PyObject *tmp_tuple_element_28;
    PyObject *tmp_tuple_element_29;
    PyObject *tmp_tuple_element_30;
    PyObject *tmp_tuple_element_31;
    PyObject *tmp_tuple_element_32;
    PyObject *tmp_tuple_element_33;
    PyObject *tmp_tuple_element_34;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_generator = NULL;


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_35df8855789420c66c74432cc8a8fca2, module_numpy$testing$utils );
    generator->m_frame = cache_frame_generator;
    Py_INCREF( generator->m_frame );

#if PYTHON_VERSION >= 340
    generator->m_frame->f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->f_back );

    generator->m_frame->f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->f_back );

    PyThreadState_GET()->frame = generator->m_frame;
    Py_INCREF( generator->m_frame );

#if PYTHON_VERSION >= 340
    generator->m_frame->f_executing += 1;
#endif

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->f_exc_type == Py_None ) generator->m_frame->f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->f_exc_type );
    generator->m_frame->f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->f_exc_value );
    generator->m_frame->f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->f_exc_traceback );
#endif

    // Framed code:
    // Throwing into not started generators is possible. As they don't stand any
    // chance to deal with them, we might as well create traceback on the
    // outside,
    if ( generator->m_exception_type )
    {
        generator->m_yielded = NULL;

        exception_type = generator->m_exception_type;
        generator->m_exception_type = NULL;

        exception_value = generator->m_exception_value;
        generator->m_exception_value = NULL;

        exception_tb = generator->m_exception_tb;;
        generator->m_exception_tb = NULL;

        if (exception_tb == NULL)
        {
            exception_lineno = 1689;
            goto frame_exception_exit_1;
        }
        else
        {
            goto function_exception_exit;
        }
    }

    tmp_iter_arg_1 = const_tuple_int_0_int_pos_1_int_pos_2_tuple;
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    assert( tmp_assign_source_1 != NULL );
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            generator->m_frame->f_lineno = 1716;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = PyCell_GET( var_o );
        PyCell_SET( var_o, tmp_assign_source_3 );
        Py_INCREF( tmp_assign_source_3 );
        Py_XDECREF( old );
    }

    tmp_left_name_1 = PyCell_GET( var_o );

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1717;
        goto try_except_handler_2;
    }

    tmp_right_name_1 = const_int_pos_2;
    tmp_range2_low_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_range2_low_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1717;
        goto try_except_handler_2;
    }
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_1 != NULL );
    tmp_left_name_2 = PyCell_GET( var_o );

    if ( tmp_left_name_2 == NULL )
    {
        Py_DECREF( tmp_range2_low_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1717;
        goto try_except_handler_2;
    }

    tmp_right_name_2 = const_int_pos_3;
    tmp_args_element_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_range2_low_1 );

        exception_lineno = 1717;
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = PyCell_GET( generator->m_closure[1] );

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_range2_low_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "max_size" );
        exception_tb = NULL;

        exception_lineno = 1717;
        goto try_except_handler_2;
    }

    generator->m_frame->f_lineno = 1717;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_range2_high_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_range2_high_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_range2_low_1 );

        exception_lineno = 1717;
        goto try_except_handler_2;
    }
    tmp_iter_arg_2 = BUILTIN_RANGE2( tmp_range2_low_1, tmp_range2_high_1 );
    Py_DECREF( tmp_range2_low_1 );
    Py_DECREF( tmp_range2_high_1 );
    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1717;
        goto try_except_handler_2;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1717;
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            generator->m_frame->f_lineno = 1717;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_assign_source_6 = tmp_for_loop_2__iter_value;

    {
        PyObject *old = PyCell_GET( var_s );
        PyCell_SET( var_s, tmp_assign_source_6 );
        Py_INCREF( tmp_assign_source_6 );
        Py_XDECREF( old );
    }

    tmp_compare_left_1 = PyCell_GET( generator->m_closure[2] );

    if ( tmp_compare_left_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "type" );
        exception_tb = NULL;

        exception_lineno = 1718;
        goto try_except_handler_3;
    }

    tmp_compare_right_1 = const_str_plain_unary;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1718;
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_7 = MAKE_FUNCTION_function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( generator->m_closure[0], var_o, var_s );
    {
        PyObject *old = var_inp;
        var_inp = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_empty );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_empty );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "empty" );
        exception_tb = NULL;

        exception_lineno = 1720;
        goto try_except_handler_3;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyTuple_New( 1 );
    tmp_tuple_element_2 = PyCell_GET( var_s );

    if ( tmp_tuple_element_2 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1720;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_tuple_element_1, 0, tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1720;
        goto try_except_handler_3;
    }

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    generator->m_frame->f_lineno = 1720;
    tmp_slice_source_1 = CALL_FUNCTION( tmp_called_name_2, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1720;
        goto try_except_handler_3;
    }
    tmp_slice_lower_1 = PyCell_GET( var_o );

    if ( tmp_slice_lower_1 == NULL )
    {
        Py_DECREF( tmp_slice_source_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1720;
        goto try_except_handler_3;
    }

    tmp_assign_source_8 = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, Py_None );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1720;
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_out;
        var_out = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_expression_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_3 = var_out;

    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_expression_name_1, 0, tmp_tuple_element_3 );
    tmp_called_name_3 = var_inp;

    generator->m_frame->f_lineno = 1721;
    tmp_tuple_element_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_tuple_element_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 1721;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 1, tmp_tuple_element_3 );
    tmp_left_name_3 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_3 = PyTuple_New( 5 );
    tmp_tuple_element_4 = PyCell_GET( var_o );

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        Py_DECREF( tmp_right_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1721;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_4 );
    tmp_tuple_element_4 = PyCell_GET( var_o );

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        Py_DECREF( tmp_right_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1721;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_4 );
    tmp_tuple_element_4 = PyCell_GET( var_s );

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        Py_DECREF( tmp_right_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1721;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_3, 2, tmp_tuple_element_4 );
    tmp_tuple_element_4 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_4 == NULL )
    {
        Py_DECREF( tmp_expression_name_1 );
        Py_DECREF( tmp_right_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1721;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_3, 3, tmp_tuple_element_4 );
    tmp_tuple_element_4 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_right_name_3, 4, tmp_tuple_element_4 );
    tmp_tuple_element_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_tuple_element_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_1 );

        exception_lineno = 1721;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_1, 2, tmp_tuple_element_3 );
    tmp_unused = YIELD( generator, tmp_expression_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1721;
        goto try_except_handler_3;
    }
    tmp_expression_name_2 = PyTuple_New( 3 );
    tmp_called_name_4 = var_inp;

    generator->m_frame->f_lineno = 1722;
    tmp_tuple_element_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_4 );
    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_2 );

        exception_lineno = 1722;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_2, 0, tmp_tuple_element_5 );
    tmp_called_name_5 = var_inp;

    generator->m_frame->f_lineno = 1722;
    tmp_tuple_element_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_5 );
    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_2 );

        exception_lineno = 1722;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_2, 1, tmp_tuple_element_5 );
    tmp_left_name_4 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_4 = PyTuple_New( 5 );
    tmp_tuple_element_6 = PyCell_GET( var_o );

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_expression_name_2 );
        Py_DECREF( tmp_right_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1722;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_6 );
    tmp_tuple_element_6 = PyCell_GET( var_o );

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_expression_name_2 );
        Py_DECREF( tmp_right_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1722;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_6 );
    tmp_tuple_element_6 = PyCell_GET( var_s );

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_expression_name_2 );
        Py_DECREF( tmp_right_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1722;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_4, 2, tmp_tuple_element_6 );
    tmp_tuple_element_6 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_expression_name_2 );
        Py_DECREF( tmp_right_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1722;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_4, 3, tmp_tuple_element_6 );
    tmp_tuple_element_6 = const_str_digest_9080e25adf8a6e98de54bc174ec4ddea;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_4, 4, tmp_tuple_element_6 );
    tmp_tuple_element_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_tuple_element_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_2 );

        exception_lineno = 1722;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_2, 2, tmp_tuple_element_5 );
    tmp_unused = YIELD( generator, tmp_expression_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1722;
        goto try_except_handler_3;
    }
    tmp_expression_name_3 = PyTuple_New( 3 );
    tmp_sliceslicedel_index_lower_1 = 1;
    tmp_slice_index_upper_1 = PY_SSIZE_T_MAX;
    tmp_slice_source_2 = var_out;

    tmp_tuple_element_7 = LOOKUP_INDEX_SLICE( tmp_slice_source_2, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );

        exception_lineno = 1723;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_3, 0, tmp_tuple_element_7 );
    tmp_sliceslicedel_index_lower_2 = 0;
    tmp_slice_index_upper_2 = -1;
    tmp_called_name_6 = var_inp;

    generator->m_frame->f_lineno = 1723;
    tmp_slice_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_6 );
    if ( tmp_slice_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );

        exception_lineno = 1723;
        goto try_except_handler_3;
    }
    tmp_tuple_element_7 = LOOKUP_INDEX_SLICE( tmp_slice_source_3, tmp_sliceslicedel_index_lower_2, tmp_slice_index_upper_2 );
    Py_DECREF( tmp_slice_source_3 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );

        exception_lineno = 1723;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_3, 1, tmp_tuple_element_7 );
    tmp_left_name_5 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_5 = PyTuple_New( 5 );
    tmp_left_name_6 = PyCell_GET( var_o );

    if ( tmp_left_name_6 == NULL )
    {
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1724;
        goto try_except_handler_3;
    }

    tmp_right_name_6 = const_int_pos_1;
    tmp_tuple_element_8 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_6 );
    if ( tmp_tuple_element_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );

        exception_lineno = 1724;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_5, 0, tmp_tuple_element_8 );
    tmp_tuple_element_8 = PyCell_GET( var_o );

    if ( tmp_tuple_element_8 == NULL )
    {
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1724;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_right_name_5, 1, tmp_tuple_element_8 );
    tmp_left_name_7 = PyCell_GET( var_s );

    if ( tmp_left_name_7 == NULL )
    {
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1724;
        goto try_except_handler_3;
    }

    tmp_right_name_7 = const_int_pos_1;
    tmp_tuple_element_8 = BINARY_OPERATION_SUB( tmp_left_name_7, tmp_right_name_7 );
    if ( tmp_tuple_element_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );

        exception_lineno = 1724;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_5, 2, tmp_tuple_element_8 );
    tmp_tuple_element_8 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_8 == NULL )
    {
        Py_DECREF( tmp_expression_name_3 );
        Py_DECREF( tmp_right_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1724;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_right_name_5, 3, tmp_tuple_element_8 );
    tmp_tuple_element_8 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_right_name_5, 4, tmp_tuple_element_8 );
    tmp_tuple_element_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_3 );

        exception_lineno = 1723;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_3, 2, tmp_tuple_element_7 );
    tmp_unused = YIELD( generator, tmp_expression_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        goto try_except_handler_3;
    }
    tmp_expression_name_4 = PyTuple_New( 3 );
    tmp_sliceslicedel_index_lower_3 = 0;
    tmp_slice_index_upper_3 = -1;
    tmp_slice_source_4 = var_out;

    tmp_tuple_element_9 = LOOKUP_INDEX_SLICE( tmp_slice_source_4, tmp_sliceslicedel_index_lower_3, tmp_slice_index_upper_3 );
    if ( tmp_tuple_element_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );

        exception_lineno = 1725;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_4, 0, tmp_tuple_element_9 );
    tmp_sliceslicedel_index_lower_4 = 1;
    tmp_slice_index_upper_4 = PY_SSIZE_T_MAX;
    tmp_called_name_7 = var_inp;

    generator->m_frame->f_lineno = 1725;
    tmp_slice_source_5 = CALL_FUNCTION_NO_ARGS( tmp_called_name_7 );
    if ( tmp_slice_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );

        exception_lineno = 1725;
        goto try_except_handler_3;
    }
    tmp_tuple_element_9 = LOOKUP_INDEX_SLICE( tmp_slice_source_5, tmp_sliceslicedel_index_lower_4, tmp_slice_index_upper_4 );
    Py_DECREF( tmp_slice_source_5 );
    if ( tmp_tuple_element_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );

        exception_lineno = 1725;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_4, 1, tmp_tuple_element_9 );
    tmp_left_name_8 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_8 = PyTuple_New( 5 );
    tmp_tuple_element_10 = PyCell_GET( var_o );

    if ( tmp_tuple_element_10 == NULL )
    {
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1726;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_right_name_8, 0, tmp_tuple_element_10 );
    tmp_left_name_9 = PyCell_GET( var_o );

    if ( tmp_left_name_9 == NULL )
    {
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1726;
        goto try_except_handler_3;
    }

    tmp_right_name_9 = const_int_pos_1;
    tmp_tuple_element_10 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_9 );
    if ( tmp_tuple_element_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );

        exception_lineno = 1726;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_8, 1, tmp_tuple_element_10 );
    tmp_left_name_10 = PyCell_GET( var_s );

    if ( tmp_left_name_10 == NULL )
    {
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1726;
        goto try_except_handler_3;
    }

    tmp_right_name_10 = const_int_pos_1;
    tmp_tuple_element_10 = BINARY_OPERATION_SUB( tmp_left_name_10, tmp_right_name_10 );
    if ( tmp_tuple_element_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );

        exception_lineno = 1726;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_8, 2, tmp_tuple_element_10 );
    tmp_tuple_element_10 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_10 == NULL )
    {
        Py_DECREF( tmp_expression_name_4 );
        Py_DECREF( tmp_right_name_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1726;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_right_name_8, 3, tmp_tuple_element_10 );
    tmp_tuple_element_10 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_right_name_8, 4, tmp_tuple_element_10 );
    tmp_tuple_element_9 = BINARY_OPERATION_REMAINDER( tmp_left_name_8, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_tuple_element_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_4 );

        exception_lineno = 1725;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_4, 2, tmp_tuple_element_9 );
    tmp_unused = YIELD( generator, tmp_expression_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1725;
        goto try_except_handler_3;
    }
    tmp_expression_name_5 = PyTuple_New( 3 );
    tmp_sliceslicedel_index_lower_5 = 0;
    tmp_slice_index_upper_5 = -1;
    tmp_called_name_8 = var_inp;

    generator->m_frame->f_lineno = 1727;
    tmp_slice_source_6 = CALL_FUNCTION_NO_ARGS( tmp_called_name_8 );
    if ( tmp_slice_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );

        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    tmp_tuple_element_11 = LOOKUP_INDEX_SLICE( tmp_slice_source_6, tmp_sliceslicedel_index_lower_5, tmp_slice_index_upper_5 );
    Py_DECREF( tmp_slice_source_6 );
    if ( tmp_tuple_element_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );

        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_5, 0, tmp_tuple_element_11 );
    tmp_sliceslicedel_index_lower_6 = 1;
    tmp_slice_index_upper_6 = PY_SSIZE_T_MAX;
    tmp_called_name_9 = var_inp;

    generator->m_frame->f_lineno = 1727;
    tmp_slice_source_7 = CALL_FUNCTION_NO_ARGS( tmp_called_name_9 );
    if ( tmp_slice_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );

        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    tmp_tuple_element_11 = LOOKUP_INDEX_SLICE( tmp_slice_source_7, tmp_sliceslicedel_index_lower_6, tmp_slice_index_upper_6 );
    Py_DECREF( tmp_slice_source_7 );
    if ( tmp_tuple_element_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );

        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_5, 1, tmp_tuple_element_11 );
    tmp_left_name_11 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_11 = PyTuple_New( 5 );
    tmp_tuple_element_12 = PyCell_GET( var_o );

    if ( tmp_tuple_element_12 == NULL )
    {
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1728;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_right_name_11, 0, tmp_tuple_element_12 );
    tmp_left_name_12 = PyCell_GET( var_o );

    if ( tmp_left_name_12 == NULL )
    {
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1728;
        goto try_except_handler_3;
    }

    tmp_right_name_12 = const_int_pos_1;
    tmp_tuple_element_12 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_12 );
    if ( tmp_tuple_element_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );

        exception_lineno = 1728;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_11, 1, tmp_tuple_element_12 );
    tmp_left_name_13 = PyCell_GET( var_s );

    if ( tmp_left_name_13 == NULL )
    {
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1728;
        goto try_except_handler_3;
    }

    tmp_right_name_13 = const_int_pos_1;
    tmp_tuple_element_12 = BINARY_OPERATION_SUB( tmp_left_name_13, tmp_right_name_13 );
    if ( tmp_tuple_element_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );

        exception_lineno = 1728;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_11, 2, tmp_tuple_element_12 );
    tmp_tuple_element_12 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_12 == NULL )
    {
        Py_DECREF( tmp_expression_name_5 );
        Py_DECREF( tmp_right_name_11 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1728;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_right_name_11, 3, tmp_tuple_element_12 );
    tmp_tuple_element_12 = const_str_plain_aliased;
    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_right_name_11, 4, tmp_tuple_element_12 );
    tmp_tuple_element_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_11, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_tuple_element_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_5 );

        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_5, 2, tmp_tuple_element_11 );
    tmp_unused = YIELD( generator, tmp_expression_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1727;
        goto try_except_handler_3;
    }
    tmp_expression_name_6 = PyTuple_New( 3 );
    tmp_sliceslicedel_index_lower_7 = 1;
    tmp_slice_index_upper_7 = PY_SSIZE_T_MAX;
    tmp_called_name_10 = var_inp;

    generator->m_frame->f_lineno = 1729;
    tmp_slice_source_8 = CALL_FUNCTION_NO_ARGS( tmp_called_name_10 );
    if ( tmp_slice_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );

        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    tmp_tuple_element_13 = LOOKUP_INDEX_SLICE( tmp_slice_source_8, tmp_sliceslicedel_index_lower_7, tmp_slice_index_upper_7 );
    Py_DECREF( tmp_slice_source_8 );
    if ( tmp_tuple_element_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );

        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_6, 0, tmp_tuple_element_13 );
    tmp_sliceslicedel_index_lower_8 = 0;
    tmp_slice_index_upper_8 = -1;
    tmp_called_name_11 = var_inp;

    generator->m_frame->f_lineno = 1729;
    tmp_slice_source_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_11 );
    if ( tmp_slice_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );

        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    tmp_tuple_element_13 = LOOKUP_INDEX_SLICE( tmp_slice_source_9, tmp_sliceslicedel_index_lower_8, tmp_slice_index_upper_8 );
    Py_DECREF( tmp_slice_source_9 );
    if ( tmp_tuple_element_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );

        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_6, 1, tmp_tuple_element_13 );
    tmp_left_name_14 = const_str_digest_0c802ca97afbb39d58c81bee322d6fe6;
    tmp_right_name_14 = PyTuple_New( 5 );
    tmp_left_name_15 = PyCell_GET( var_o );

    if ( tmp_left_name_15 == NULL )
    {
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1730;
        goto try_except_handler_3;
    }

    tmp_right_name_15 = const_int_pos_1;
    tmp_tuple_element_14 = BINARY_OPERATION_ADD( tmp_left_name_15, tmp_right_name_15 );
    if ( tmp_tuple_element_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );

        exception_lineno = 1730;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_14, 0, tmp_tuple_element_14 );
    tmp_tuple_element_14 = PyCell_GET( var_o );

    if ( tmp_tuple_element_14 == NULL )
    {
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1730;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_right_name_14, 1, tmp_tuple_element_14 );
    tmp_left_name_16 = PyCell_GET( var_s );

    if ( tmp_left_name_16 == NULL )
    {
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1730;
        goto try_except_handler_3;
    }

    tmp_right_name_16 = const_int_pos_1;
    tmp_tuple_element_14 = BINARY_OPERATION_SUB( tmp_left_name_16, tmp_right_name_16 );
    if ( tmp_tuple_element_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );

        exception_lineno = 1730;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_14, 2, tmp_tuple_element_14 );
    tmp_tuple_element_14 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_14 == NULL )
    {
        Py_DECREF( tmp_expression_name_6 );
        Py_DECREF( tmp_right_name_14 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1730;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_right_name_14, 3, tmp_tuple_element_14 );
    tmp_tuple_element_14 = const_str_plain_aliased;
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_right_name_14, 4, tmp_tuple_element_14 );
    tmp_tuple_element_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_14, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_tuple_element_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_6 );

        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_6, 2, tmp_tuple_element_13 );
    tmp_unused = YIELD( generator, tmp_expression_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1729;
        goto try_except_handler_3;
    }
    branch_no_1:;
    tmp_compare_left_2 = PyCell_GET( generator->m_closure[2] );

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "type" );
        exception_tb = NULL;

        exception_lineno = 1731;
        goto try_except_handler_3;
    }

    tmp_compare_right_2 = const_str_plain_binary;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_9 = MAKE_FUNCTION_function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( generator->m_closure[0], var_o, var_s );
    {
        PyObject *old = var_inp1;
        var_inp1 = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_assign_source_10 = MAKE_FUNCTION_function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( generator->m_closure[0], var_o, var_s );
    {
        PyObject *old = var_inp2;
        var_inp2 = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_empty );

    if (unlikely( tmp_called_name_12 == NULL ))
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_empty );
    }

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "empty" );
        exception_tb = NULL;

        exception_lineno = 1734;
        goto try_except_handler_3;
    }

    tmp_args_name_2 = PyTuple_New( 1 );
    tmp_tuple_element_15 = PyTuple_New( 1 );
    tmp_tuple_element_16 = PyCell_GET( var_s );

    if ( tmp_tuple_element_16 == NULL )
    {
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_tuple_element_15 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1734;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_tuple_element_15, 0, tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_15 );
    tmp_kw_name_2 = _PyDict_NewPresized( 1 );
    tmp_dict_value_2 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1734;
        goto try_except_handler_3;
    }

    tmp_dict_key_2 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    generator->m_frame->f_lineno = 1734;
    tmp_slice_source_10 = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_slice_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        goto try_except_handler_3;
    }
    tmp_slice_lower_2 = PyCell_GET( var_o );

    if ( tmp_slice_lower_2 == NULL )
    {
        Py_DECREF( tmp_slice_source_10 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1734;
        goto try_except_handler_3;
    }

    tmp_assign_source_11 = LOOKUP_SLICE( tmp_slice_source_10, tmp_slice_lower_2, Py_None );
    Py_DECREF( tmp_slice_source_10 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_out;
        var_out = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_expression_name_7 = PyTuple_New( 4 );
    tmp_tuple_element_17 = var_out;

    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_expression_name_7, 0, tmp_tuple_element_17 );
    tmp_called_name_13 = var_inp1;

    generator->m_frame->f_lineno = 1735;
    tmp_tuple_element_17 = CALL_FUNCTION_NO_ARGS( tmp_called_name_13 );
    if ( tmp_tuple_element_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_7 );

        exception_lineno = 1735;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_7, 1, tmp_tuple_element_17 );
    tmp_called_name_14 = var_inp2;

    generator->m_frame->f_lineno = 1735;
    tmp_tuple_element_17 = CALL_FUNCTION_NO_ARGS( tmp_called_name_14 );
    if ( tmp_tuple_element_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_7 );

        exception_lineno = 1735;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_7, 2, tmp_tuple_element_17 );
    tmp_left_name_17 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_17 = PyTuple_New( 6 );
    tmp_tuple_element_18 = PyCell_GET( var_o );

    if ( tmp_tuple_element_18 == NULL )
    {
        Py_DECREF( tmp_expression_name_7 );
        Py_DECREF( tmp_right_name_17 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1736;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 0, tmp_tuple_element_18 );
    tmp_tuple_element_18 = PyCell_GET( var_o );

    if ( tmp_tuple_element_18 == NULL )
    {
        Py_DECREF( tmp_expression_name_7 );
        Py_DECREF( tmp_right_name_17 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1736;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 1, tmp_tuple_element_18 );
    tmp_tuple_element_18 = PyCell_GET( var_o );

    if ( tmp_tuple_element_18 == NULL )
    {
        Py_DECREF( tmp_expression_name_7 );
        Py_DECREF( tmp_right_name_17 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1736;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 2, tmp_tuple_element_18 );
    tmp_tuple_element_18 = PyCell_GET( var_s );

    if ( tmp_tuple_element_18 == NULL )
    {
        Py_DECREF( tmp_expression_name_7 );
        Py_DECREF( tmp_right_name_17 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1736;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 3, tmp_tuple_element_18 );
    tmp_tuple_element_18 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_18 == NULL )
    {
        Py_DECREF( tmp_expression_name_7 );
        Py_DECREF( tmp_right_name_17 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1736;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 4, tmp_tuple_element_18 );
    tmp_tuple_element_18 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_right_name_17, 5, tmp_tuple_element_18 );
    tmp_tuple_element_17 = BINARY_OPERATION_REMAINDER( tmp_left_name_17, tmp_right_name_17 );
    Py_DECREF( tmp_right_name_17 );
    if ( tmp_tuple_element_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_7 );

        exception_lineno = 1735;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_7, 3, tmp_tuple_element_17 );
    tmp_unused = YIELD( generator, tmp_expression_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1735;
        goto try_except_handler_3;
    }
    tmp_expression_name_8 = PyTuple_New( 4 );
    tmp_called_name_15 = var_inp1;

    generator->m_frame->f_lineno = 1737;
    tmp_tuple_element_19 = CALL_FUNCTION_NO_ARGS( tmp_called_name_15 );
    if ( tmp_tuple_element_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_8 );

        exception_lineno = 1737;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_8, 0, tmp_tuple_element_19 );
    tmp_called_name_16 = var_inp1;

    generator->m_frame->f_lineno = 1737;
    tmp_tuple_element_19 = CALL_FUNCTION_NO_ARGS( tmp_called_name_16 );
    if ( tmp_tuple_element_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_8 );

        exception_lineno = 1737;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_8, 1, tmp_tuple_element_19 );
    tmp_called_name_17 = var_inp2;

    generator->m_frame->f_lineno = 1737;
    tmp_tuple_element_19 = CALL_FUNCTION_NO_ARGS( tmp_called_name_17 );
    if ( tmp_tuple_element_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_8 );

        exception_lineno = 1737;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_8, 2, tmp_tuple_element_19 );
    tmp_left_name_18 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_18 = PyTuple_New( 6 );
    tmp_tuple_element_20 = PyCell_GET( var_o );

    if ( tmp_tuple_element_20 == NULL )
    {
        Py_DECREF( tmp_expression_name_8 );
        Py_DECREF( tmp_right_name_18 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1738;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 0, tmp_tuple_element_20 );
    tmp_tuple_element_20 = PyCell_GET( var_o );

    if ( tmp_tuple_element_20 == NULL )
    {
        Py_DECREF( tmp_expression_name_8 );
        Py_DECREF( tmp_right_name_18 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1738;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 1, tmp_tuple_element_20 );
    tmp_tuple_element_20 = PyCell_GET( var_o );

    if ( tmp_tuple_element_20 == NULL )
    {
        Py_DECREF( tmp_expression_name_8 );
        Py_DECREF( tmp_right_name_18 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1738;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 2, tmp_tuple_element_20 );
    tmp_tuple_element_20 = PyCell_GET( var_s );

    if ( tmp_tuple_element_20 == NULL )
    {
        Py_DECREF( tmp_expression_name_8 );
        Py_DECREF( tmp_right_name_18 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1738;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 3, tmp_tuple_element_20 );
    tmp_tuple_element_20 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_20 == NULL )
    {
        Py_DECREF( tmp_expression_name_8 );
        Py_DECREF( tmp_right_name_18 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1738;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 4, tmp_tuple_element_20 );
    tmp_tuple_element_20 = const_str_digest_1b1287ebb1d4b1f4e8307f127391cdb6;
    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_right_name_18, 5, tmp_tuple_element_20 );
    tmp_tuple_element_19 = BINARY_OPERATION_REMAINDER( tmp_left_name_18, tmp_right_name_18 );
    Py_DECREF( tmp_right_name_18 );
    if ( tmp_tuple_element_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_8 );

        exception_lineno = 1737;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_8, 3, tmp_tuple_element_19 );
    tmp_unused = YIELD( generator, tmp_expression_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1737;
        goto try_except_handler_3;
    }
    tmp_expression_name_9 = PyTuple_New( 4 );
    tmp_called_name_18 = var_inp2;

    generator->m_frame->f_lineno = 1739;
    tmp_tuple_element_21 = CALL_FUNCTION_NO_ARGS( tmp_called_name_18 );
    if ( tmp_tuple_element_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_9 );

        exception_lineno = 1739;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_9, 0, tmp_tuple_element_21 );
    tmp_called_name_19 = var_inp1;

    generator->m_frame->f_lineno = 1739;
    tmp_tuple_element_21 = CALL_FUNCTION_NO_ARGS( tmp_called_name_19 );
    if ( tmp_tuple_element_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_9 );

        exception_lineno = 1739;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_9, 1, tmp_tuple_element_21 );
    tmp_called_name_20 = var_inp2;

    generator->m_frame->f_lineno = 1739;
    tmp_tuple_element_21 = CALL_FUNCTION_NO_ARGS( tmp_called_name_20 );
    if ( tmp_tuple_element_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_9 );

        exception_lineno = 1739;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_9, 2, tmp_tuple_element_21 );
    tmp_left_name_19 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_19 = PyTuple_New( 6 );
    tmp_tuple_element_22 = PyCell_GET( var_o );

    if ( tmp_tuple_element_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_9 );
        Py_DECREF( tmp_right_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1740;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 0, tmp_tuple_element_22 );
    tmp_tuple_element_22 = PyCell_GET( var_o );

    if ( tmp_tuple_element_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_9 );
        Py_DECREF( tmp_right_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1740;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 1, tmp_tuple_element_22 );
    tmp_tuple_element_22 = PyCell_GET( var_o );

    if ( tmp_tuple_element_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_9 );
        Py_DECREF( tmp_right_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1740;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 2, tmp_tuple_element_22 );
    tmp_tuple_element_22 = PyCell_GET( var_s );

    if ( tmp_tuple_element_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_9 );
        Py_DECREF( tmp_right_name_19 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1740;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 3, tmp_tuple_element_22 );
    tmp_tuple_element_22 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_9 );
        Py_DECREF( tmp_right_name_19 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1740;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 4, tmp_tuple_element_22 );
    tmp_tuple_element_22 = const_str_digest_91ae8b8c54cb3ed81a3eec57351d8df9;
    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_right_name_19, 5, tmp_tuple_element_22 );
    tmp_tuple_element_21 = BINARY_OPERATION_REMAINDER( tmp_left_name_19, tmp_right_name_19 );
    Py_DECREF( tmp_right_name_19 );
    if ( tmp_tuple_element_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_9 );

        exception_lineno = 1739;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_9, 3, tmp_tuple_element_21 );
    tmp_unused = YIELD( generator, tmp_expression_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1739;
        goto try_except_handler_3;
    }
    tmp_expression_name_10 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_9 = 1;
    tmp_slice_index_upper_9 = PY_SSIZE_T_MAX;
    tmp_slice_source_11 = var_out;

    tmp_tuple_element_23 = LOOKUP_INDEX_SLICE( tmp_slice_source_11, tmp_sliceslicedel_index_lower_9, tmp_slice_index_upper_9 );
    if ( tmp_tuple_element_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_10, 0, tmp_tuple_element_23 );
    tmp_sliceslicedel_index_lower_10 = 0;
    tmp_slice_index_upper_10 = -1;
    tmp_called_name_21 = var_inp1;

    generator->m_frame->f_lineno = 1741;
    tmp_slice_source_12 = CALL_FUNCTION_NO_ARGS( tmp_called_name_21 );
    if ( tmp_slice_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    tmp_tuple_element_23 = LOOKUP_INDEX_SLICE( tmp_slice_source_12, tmp_sliceslicedel_index_lower_10, tmp_slice_index_upper_10 );
    Py_DECREF( tmp_slice_source_12 );
    if ( tmp_tuple_element_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_10, 1, tmp_tuple_element_23 );
    tmp_sliceslicedel_index_lower_11 = 0;
    tmp_slice_index_upper_11 = -1;
    tmp_called_name_22 = var_inp2;

    generator->m_frame->f_lineno = 1741;
    tmp_slice_source_13 = CALL_FUNCTION_NO_ARGS( tmp_called_name_22 );
    if ( tmp_slice_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    tmp_tuple_element_23 = LOOKUP_INDEX_SLICE( tmp_slice_source_13, tmp_sliceslicedel_index_lower_11, tmp_slice_index_upper_11 );
    Py_DECREF( tmp_slice_source_13 );
    if ( tmp_tuple_element_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_10, 2, tmp_tuple_element_23 );
    tmp_left_name_20 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_20 = PyTuple_New( 6 );
    tmp_left_name_21 = PyCell_GET( var_o );

    if ( tmp_left_name_21 == NULL )
    {
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1742;
        goto try_except_handler_3;
    }

    tmp_right_name_21 = const_int_pos_1;
    tmp_tuple_element_24 = BINARY_OPERATION_ADD( tmp_left_name_21, tmp_right_name_21 );
    if ( tmp_tuple_element_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );

        exception_lineno = 1742;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_20, 0, tmp_tuple_element_24 );
    tmp_tuple_element_24 = PyCell_GET( var_o );

    if ( tmp_tuple_element_24 == NULL )
    {
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1742;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_right_name_20, 1, tmp_tuple_element_24 );
    tmp_tuple_element_24 = PyCell_GET( var_o );

    if ( tmp_tuple_element_24 == NULL )
    {
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1742;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_right_name_20, 2, tmp_tuple_element_24 );
    tmp_left_name_22 = PyCell_GET( var_s );

    if ( tmp_left_name_22 == NULL )
    {
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1742;
        goto try_except_handler_3;
    }

    tmp_right_name_22 = const_int_pos_1;
    tmp_tuple_element_24 = BINARY_OPERATION_SUB( tmp_left_name_22, tmp_right_name_22 );
    if ( tmp_tuple_element_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );

        exception_lineno = 1742;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_20, 3, tmp_tuple_element_24 );
    tmp_tuple_element_24 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_24 == NULL )
    {
        Py_DECREF( tmp_expression_name_10 );
        Py_DECREF( tmp_right_name_20 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1742;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_right_name_20, 4, tmp_tuple_element_24 );
    tmp_tuple_element_24 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_right_name_20, 5, tmp_tuple_element_24 );
    tmp_tuple_element_23 = BINARY_OPERATION_REMAINDER( tmp_left_name_20, tmp_right_name_20 );
    Py_DECREF( tmp_right_name_20 );
    if ( tmp_tuple_element_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_10 );

        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_10, 3, tmp_tuple_element_23 );
    tmp_unused = YIELD( generator, tmp_expression_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1741;
        goto try_except_handler_3;
    }
    tmp_expression_name_11 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_12 = 0;
    tmp_slice_index_upper_12 = -1;
    tmp_slice_source_14 = var_out;

    tmp_tuple_element_25 = LOOKUP_INDEX_SLICE( tmp_slice_source_14, tmp_sliceslicedel_index_lower_12, tmp_slice_index_upper_12 );
    if ( tmp_tuple_element_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_11, 0, tmp_tuple_element_25 );
    tmp_sliceslicedel_index_lower_13 = 1;
    tmp_slice_index_upper_13 = PY_SSIZE_T_MAX;
    tmp_called_name_23 = var_inp1;

    generator->m_frame->f_lineno = 1743;
    tmp_slice_source_15 = CALL_FUNCTION_NO_ARGS( tmp_called_name_23 );
    if ( tmp_slice_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    tmp_tuple_element_25 = LOOKUP_INDEX_SLICE( tmp_slice_source_15, tmp_sliceslicedel_index_lower_13, tmp_slice_index_upper_13 );
    Py_DECREF( tmp_slice_source_15 );
    if ( tmp_tuple_element_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_11, 1, tmp_tuple_element_25 );
    tmp_sliceslicedel_index_lower_14 = 0;
    tmp_slice_index_upper_14 = -1;
    tmp_called_name_24 = var_inp2;

    generator->m_frame->f_lineno = 1743;
    tmp_slice_source_16 = CALL_FUNCTION_NO_ARGS( tmp_called_name_24 );
    if ( tmp_slice_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    tmp_tuple_element_25 = LOOKUP_INDEX_SLICE( tmp_slice_source_16, tmp_sliceslicedel_index_lower_14, tmp_slice_index_upper_14 );
    Py_DECREF( tmp_slice_source_16 );
    if ( tmp_tuple_element_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_11, 2, tmp_tuple_element_25 );
    tmp_left_name_23 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_23 = PyTuple_New( 6 );
    tmp_tuple_element_26 = PyCell_GET( var_o );

    if ( tmp_tuple_element_26 == NULL )
    {
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1744;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_right_name_23, 0, tmp_tuple_element_26 );
    tmp_left_name_24 = PyCell_GET( var_o );

    if ( tmp_left_name_24 == NULL )
    {
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1744;
        goto try_except_handler_3;
    }

    tmp_right_name_24 = const_int_pos_1;
    tmp_tuple_element_26 = BINARY_OPERATION_ADD( tmp_left_name_24, tmp_right_name_24 );
    if ( tmp_tuple_element_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );

        exception_lineno = 1744;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_23, 1, tmp_tuple_element_26 );
    tmp_tuple_element_26 = PyCell_GET( var_o );

    if ( tmp_tuple_element_26 == NULL )
    {
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1744;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_right_name_23, 2, tmp_tuple_element_26 );
    tmp_left_name_25 = PyCell_GET( var_s );

    if ( tmp_left_name_25 == NULL )
    {
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1744;
        goto try_except_handler_3;
    }

    tmp_right_name_25 = const_int_pos_1;
    tmp_tuple_element_26 = BINARY_OPERATION_SUB( tmp_left_name_25, tmp_right_name_25 );
    if ( tmp_tuple_element_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );

        exception_lineno = 1744;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_23, 3, tmp_tuple_element_26 );
    tmp_tuple_element_26 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_26 == NULL )
    {
        Py_DECREF( tmp_expression_name_11 );
        Py_DECREF( tmp_right_name_23 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1744;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_right_name_23, 4, tmp_tuple_element_26 );
    tmp_tuple_element_26 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_right_name_23, 5, tmp_tuple_element_26 );
    tmp_tuple_element_25 = BINARY_OPERATION_REMAINDER( tmp_left_name_23, tmp_right_name_23 );
    Py_DECREF( tmp_right_name_23 );
    if ( tmp_tuple_element_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_11 );

        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_11, 3, tmp_tuple_element_25 );
    tmp_unused = YIELD( generator, tmp_expression_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1743;
        goto try_except_handler_3;
    }
    tmp_expression_name_12 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_15 = 0;
    tmp_slice_index_upper_15 = -1;
    tmp_slice_source_17 = var_out;

    tmp_tuple_element_27 = LOOKUP_INDEX_SLICE( tmp_slice_source_17, tmp_sliceslicedel_index_lower_15, tmp_slice_index_upper_15 );
    if ( tmp_tuple_element_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_12, 0, tmp_tuple_element_27 );
    tmp_sliceslicedel_index_lower_16 = 0;
    tmp_slice_index_upper_16 = -1;
    tmp_called_name_25 = var_inp1;

    generator->m_frame->f_lineno = 1745;
    tmp_slice_source_18 = CALL_FUNCTION_NO_ARGS( tmp_called_name_25 );
    if ( tmp_slice_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    tmp_tuple_element_27 = LOOKUP_INDEX_SLICE( tmp_slice_source_18, tmp_sliceslicedel_index_lower_16, tmp_slice_index_upper_16 );
    Py_DECREF( tmp_slice_source_18 );
    if ( tmp_tuple_element_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_12, 1, tmp_tuple_element_27 );
    tmp_sliceslicedel_index_lower_17 = 1;
    tmp_slice_index_upper_17 = PY_SSIZE_T_MAX;
    tmp_called_name_26 = var_inp2;

    generator->m_frame->f_lineno = 1745;
    tmp_slice_source_19 = CALL_FUNCTION_NO_ARGS( tmp_called_name_26 );
    if ( tmp_slice_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    tmp_tuple_element_27 = LOOKUP_INDEX_SLICE( tmp_slice_source_19, tmp_sliceslicedel_index_lower_17, tmp_slice_index_upper_17 );
    Py_DECREF( tmp_slice_source_19 );
    if ( tmp_tuple_element_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_12, 2, tmp_tuple_element_27 );
    tmp_left_name_26 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_26 = PyTuple_New( 6 );
    tmp_tuple_element_28 = PyCell_GET( var_o );

    if ( tmp_tuple_element_28 == NULL )
    {
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1746;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_right_name_26, 0, tmp_tuple_element_28 );
    tmp_tuple_element_28 = PyCell_GET( var_o );

    if ( tmp_tuple_element_28 == NULL )
    {
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1746;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_right_name_26, 1, tmp_tuple_element_28 );
    tmp_left_name_27 = PyCell_GET( var_o );

    if ( tmp_left_name_27 == NULL )
    {
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1746;
        goto try_except_handler_3;
    }

    tmp_right_name_27 = const_int_pos_1;
    tmp_tuple_element_28 = BINARY_OPERATION_ADD( tmp_left_name_27, tmp_right_name_27 );
    if ( tmp_tuple_element_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );

        exception_lineno = 1746;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_26, 2, tmp_tuple_element_28 );
    tmp_left_name_28 = PyCell_GET( var_s );

    if ( tmp_left_name_28 == NULL )
    {
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1746;
        goto try_except_handler_3;
    }

    tmp_right_name_28 = const_int_pos_1;
    tmp_tuple_element_28 = BINARY_OPERATION_SUB( tmp_left_name_28, tmp_right_name_28 );
    if ( tmp_tuple_element_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );

        exception_lineno = 1746;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_26, 3, tmp_tuple_element_28 );
    tmp_tuple_element_28 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_28 == NULL )
    {
        Py_DECREF( tmp_expression_name_12 );
        Py_DECREF( tmp_right_name_26 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1746;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_right_name_26, 4, tmp_tuple_element_28 );
    tmp_tuple_element_28 = const_str_digest_92d25e009369af0f8a9ad22719acbbe8;
    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_right_name_26, 5, tmp_tuple_element_28 );
    tmp_tuple_element_27 = BINARY_OPERATION_REMAINDER( tmp_left_name_26, tmp_right_name_26 );
    Py_DECREF( tmp_right_name_26 );
    if ( tmp_tuple_element_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_12 );

        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_12, 3, tmp_tuple_element_27 );
    tmp_unused = YIELD( generator, tmp_expression_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1745;
        goto try_except_handler_3;
    }
    tmp_expression_name_13 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_18 = 1;
    tmp_slice_index_upper_18 = PY_SSIZE_T_MAX;
    tmp_called_name_27 = var_inp1;

    generator->m_frame->f_lineno = 1747;
    tmp_slice_source_20 = CALL_FUNCTION_NO_ARGS( tmp_called_name_27 );
    if ( tmp_slice_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    tmp_tuple_element_29 = LOOKUP_INDEX_SLICE( tmp_slice_source_20, tmp_sliceslicedel_index_lower_18, tmp_slice_index_upper_18 );
    Py_DECREF( tmp_slice_source_20 );
    if ( tmp_tuple_element_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_13, 0, tmp_tuple_element_29 );
    tmp_sliceslicedel_index_lower_19 = 0;
    tmp_slice_index_upper_19 = -1;
    tmp_called_name_28 = var_inp1;

    generator->m_frame->f_lineno = 1747;
    tmp_slice_source_21 = CALL_FUNCTION_NO_ARGS( tmp_called_name_28 );
    if ( tmp_slice_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    tmp_tuple_element_29 = LOOKUP_INDEX_SLICE( tmp_slice_source_21, tmp_sliceslicedel_index_lower_19, tmp_slice_index_upper_19 );
    Py_DECREF( tmp_slice_source_21 );
    if ( tmp_tuple_element_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_13, 1, tmp_tuple_element_29 );
    tmp_sliceslicedel_index_lower_20 = 0;
    tmp_slice_index_upper_20 = -1;
    tmp_called_name_29 = var_inp2;

    generator->m_frame->f_lineno = 1747;
    tmp_slice_source_22 = CALL_FUNCTION_NO_ARGS( tmp_called_name_29 );
    if ( tmp_slice_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    tmp_tuple_element_29 = LOOKUP_INDEX_SLICE( tmp_slice_source_22, tmp_sliceslicedel_index_lower_20, tmp_slice_index_upper_20 );
    Py_DECREF( tmp_slice_source_22 );
    if ( tmp_tuple_element_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_13, 2, tmp_tuple_element_29 );
    tmp_left_name_29 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_29 = PyTuple_New( 6 );
    tmp_left_name_30 = PyCell_GET( var_o );

    if ( tmp_left_name_30 == NULL )
    {
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1748;
        goto try_except_handler_3;
    }

    tmp_right_name_30 = const_int_pos_1;
    tmp_tuple_element_30 = BINARY_OPERATION_ADD( tmp_left_name_30, tmp_right_name_30 );
    if ( tmp_tuple_element_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );

        exception_lineno = 1748;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_29, 0, tmp_tuple_element_30 );
    tmp_tuple_element_30 = PyCell_GET( var_o );

    if ( tmp_tuple_element_30 == NULL )
    {
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1748;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_right_name_29, 1, tmp_tuple_element_30 );
    tmp_tuple_element_30 = PyCell_GET( var_o );

    if ( tmp_tuple_element_30 == NULL )
    {
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1748;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_right_name_29, 2, tmp_tuple_element_30 );
    tmp_left_name_31 = PyCell_GET( var_s );

    if ( tmp_left_name_31 == NULL )
    {
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1748;
        goto try_except_handler_3;
    }

    tmp_right_name_31 = const_int_pos_1;
    tmp_tuple_element_30 = BINARY_OPERATION_SUB( tmp_left_name_31, tmp_right_name_31 );
    if ( tmp_tuple_element_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );

        exception_lineno = 1748;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_29, 3, tmp_tuple_element_30 );
    tmp_tuple_element_30 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_30 == NULL )
    {
        Py_DECREF( tmp_expression_name_13 );
        Py_DECREF( tmp_right_name_29 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1748;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_right_name_29, 4, tmp_tuple_element_30 );
    tmp_tuple_element_30 = const_str_plain_aliased;
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_right_name_29, 5, tmp_tuple_element_30 );
    tmp_tuple_element_29 = BINARY_OPERATION_REMAINDER( tmp_left_name_29, tmp_right_name_29 );
    Py_DECREF( tmp_right_name_29 );
    if ( tmp_tuple_element_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_13 );

        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_13, 3, tmp_tuple_element_29 );
    tmp_unused = YIELD( generator, tmp_expression_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1747;
        goto try_except_handler_3;
    }
    tmp_expression_name_14 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_21 = 0;
    tmp_slice_index_upper_21 = -1;
    tmp_called_name_30 = var_inp1;

    generator->m_frame->f_lineno = 1749;
    tmp_slice_source_23 = CALL_FUNCTION_NO_ARGS( tmp_called_name_30 );
    if ( tmp_slice_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    tmp_tuple_element_31 = LOOKUP_INDEX_SLICE( tmp_slice_source_23, tmp_sliceslicedel_index_lower_21, tmp_slice_index_upper_21 );
    Py_DECREF( tmp_slice_source_23 );
    if ( tmp_tuple_element_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_14, 0, tmp_tuple_element_31 );
    tmp_sliceslicedel_index_lower_22 = 1;
    tmp_slice_index_upper_22 = PY_SSIZE_T_MAX;
    tmp_called_name_31 = var_inp1;

    generator->m_frame->f_lineno = 1749;
    tmp_slice_source_24 = CALL_FUNCTION_NO_ARGS( tmp_called_name_31 );
    if ( tmp_slice_source_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    tmp_tuple_element_31 = LOOKUP_INDEX_SLICE( tmp_slice_source_24, tmp_sliceslicedel_index_lower_22, tmp_slice_index_upper_22 );
    Py_DECREF( tmp_slice_source_24 );
    if ( tmp_tuple_element_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_14, 1, tmp_tuple_element_31 );
    tmp_sliceslicedel_index_lower_23 = 0;
    tmp_slice_index_upper_23 = -1;
    tmp_called_name_32 = var_inp2;

    generator->m_frame->f_lineno = 1749;
    tmp_slice_source_25 = CALL_FUNCTION_NO_ARGS( tmp_called_name_32 );
    if ( tmp_slice_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    tmp_tuple_element_31 = LOOKUP_INDEX_SLICE( tmp_slice_source_25, tmp_sliceslicedel_index_lower_23, tmp_slice_index_upper_23 );
    Py_DECREF( tmp_slice_source_25 );
    if ( tmp_tuple_element_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_14, 2, tmp_tuple_element_31 );
    tmp_left_name_32 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_32 = PyTuple_New( 6 );
    tmp_tuple_element_32 = PyCell_GET( var_o );

    if ( tmp_tuple_element_32 == NULL )
    {
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1750;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_right_name_32, 0, tmp_tuple_element_32 );
    tmp_left_name_33 = PyCell_GET( var_o );

    if ( tmp_left_name_33 == NULL )
    {
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1750;
        goto try_except_handler_3;
    }

    tmp_right_name_33 = const_int_pos_1;
    tmp_tuple_element_32 = BINARY_OPERATION_ADD( tmp_left_name_33, tmp_right_name_33 );
    if ( tmp_tuple_element_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );

        exception_lineno = 1750;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_32, 1, tmp_tuple_element_32 );
    tmp_tuple_element_32 = PyCell_GET( var_o );

    if ( tmp_tuple_element_32 == NULL )
    {
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1750;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_right_name_32, 2, tmp_tuple_element_32 );
    tmp_left_name_34 = PyCell_GET( var_s );

    if ( tmp_left_name_34 == NULL )
    {
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1750;
        goto try_except_handler_3;
    }

    tmp_right_name_34 = const_int_pos_1;
    tmp_tuple_element_32 = BINARY_OPERATION_SUB( tmp_left_name_34, tmp_right_name_34 );
    if ( tmp_tuple_element_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );

        exception_lineno = 1750;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_32, 3, tmp_tuple_element_32 );
    tmp_tuple_element_32 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_32 == NULL )
    {
        Py_DECREF( tmp_expression_name_14 );
        Py_DECREF( tmp_right_name_32 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1750;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_right_name_32, 4, tmp_tuple_element_32 );
    tmp_tuple_element_32 = const_str_plain_aliased;
    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_right_name_32, 5, tmp_tuple_element_32 );
    tmp_tuple_element_31 = BINARY_OPERATION_REMAINDER( tmp_left_name_32, tmp_right_name_32 );
    Py_DECREF( tmp_right_name_32 );
    if ( tmp_tuple_element_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_14 );

        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_14, 3, tmp_tuple_element_31 );
    tmp_unused = YIELD( generator, tmp_expression_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1749;
        goto try_except_handler_3;
    }
    tmp_expression_name_15 = PyTuple_New( 4 );
    tmp_sliceslicedel_index_lower_24 = 0;
    tmp_slice_index_upper_24 = -1;
    tmp_called_name_33 = var_inp1;

    generator->m_frame->f_lineno = 1751;
    tmp_slice_source_26 = CALL_FUNCTION_NO_ARGS( tmp_called_name_33 );
    if ( tmp_slice_source_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    tmp_tuple_element_33 = LOOKUP_INDEX_SLICE( tmp_slice_source_26, tmp_sliceslicedel_index_lower_24, tmp_slice_index_upper_24 );
    Py_DECREF( tmp_slice_source_26 );
    if ( tmp_tuple_element_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_15, 0, tmp_tuple_element_33 );
    tmp_sliceslicedel_index_lower_25 = 0;
    tmp_slice_index_upper_25 = -1;
    tmp_called_name_34 = var_inp1;

    generator->m_frame->f_lineno = 1751;
    tmp_slice_source_27 = CALL_FUNCTION_NO_ARGS( tmp_called_name_34 );
    if ( tmp_slice_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    tmp_tuple_element_33 = LOOKUP_INDEX_SLICE( tmp_slice_source_27, tmp_sliceslicedel_index_lower_25, tmp_slice_index_upper_25 );
    Py_DECREF( tmp_slice_source_27 );
    if ( tmp_tuple_element_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_15, 1, tmp_tuple_element_33 );
    tmp_sliceslicedel_index_lower_26 = 1;
    tmp_slice_index_upper_26 = PY_SSIZE_T_MAX;
    tmp_called_name_35 = var_inp2;

    generator->m_frame->f_lineno = 1751;
    tmp_slice_source_28 = CALL_FUNCTION_NO_ARGS( tmp_called_name_35 );
    if ( tmp_slice_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    tmp_tuple_element_33 = LOOKUP_INDEX_SLICE( tmp_slice_source_28, tmp_sliceslicedel_index_lower_26, tmp_slice_index_upper_26 );
    Py_DECREF( tmp_slice_source_28 );
    if ( tmp_tuple_element_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_15, 2, tmp_tuple_element_33 );
    tmp_left_name_35 = const_str_digest_ca97b54f456b9d063ac2656c890932f6;
    tmp_right_name_35 = PyTuple_New( 6 );
    tmp_tuple_element_34 = PyCell_GET( var_o );

    if ( tmp_tuple_element_34 == NULL )
    {
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1752;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_right_name_35, 0, tmp_tuple_element_34 );
    tmp_tuple_element_34 = PyCell_GET( var_o );

    if ( tmp_tuple_element_34 == NULL )
    {
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1752;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_right_name_35, 1, tmp_tuple_element_34 );
    tmp_left_name_36 = PyCell_GET( var_o );

    if ( tmp_left_name_36 == NULL )
    {
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "o" );
        exception_tb = NULL;

        exception_lineno = 1752;
        goto try_except_handler_3;
    }

    tmp_right_name_36 = const_int_pos_1;
    tmp_tuple_element_34 = BINARY_OPERATION_ADD( tmp_left_name_36, tmp_right_name_36 );
    if ( tmp_tuple_element_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );

        exception_lineno = 1752;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_35, 2, tmp_tuple_element_34 );
    tmp_left_name_37 = PyCell_GET( var_s );

    if ( tmp_left_name_37 == NULL )
    {
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "s" );
        exception_tb = NULL;

        exception_lineno = 1752;
        goto try_except_handler_3;
    }

    tmp_right_name_37 = const_int_pos_1;
    tmp_tuple_element_34 = BINARY_OPERATION_SUB( tmp_left_name_37, tmp_right_name_37 );
    if ( tmp_tuple_element_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );

        exception_lineno = 1752;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_right_name_35, 3, tmp_tuple_element_34 );
    tmp_tuple_element_34 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_tuple_element_34 == NULL )
    {
        Py_DECREF( tmp_expression_name_15 );
        Py_DECREF( tmp_right_name_35 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1752;
        goto try_except_handler_3;
    }

    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_right_name_35, 4, tmp_tuple_element_34 );
    tmp_tuple_element_34 = const_str_plain_aliased;
    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_right_name_35, 5, tmp_tuple_element_34 );
    tmp_tuple_element_33 = BINARY_OPERATION_REMAINDER( tmp_left_name_35, tmp_right_name_35 );
    Py_DECREF( tmp_right_name_35 );
    if ( tmp_tuple_element_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_expression_name_15 );

        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_expression_name_15, 3, tmp_tuple_element_33 );
    tmp_unused = YIELD( generator, tmp_expression_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1751;
        goto try_except_handler_3;
    }
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1717;
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1716;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if PYTHON_VERSION >= 340
    generator->m_frame->f_executing -= 1;
#endif

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->f_exc_type );
    Py_CLEAR( generator->m_frame->f_exc_value );
    Py_CLEAR( generator->m_frame->f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        int needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_tb->tb_frame != generator->m_frame )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( generator->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    generator->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( generator->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_type,
                    generator->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( generator->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_max_size,
                    generator->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_o->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_o,
                    var_o->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_s->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_s,
                    var_s->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_inp )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_inp,
                    var_inp
                );

                assert( res == 0 );
            }

            if ( var_out )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_out,
                    var_out
                );

                assert( res == 0 );
            }

            if ( var_inp1 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_inp1,
                    var_inp1
                );

                assert( res == 0 );
            }

            if ( var_inp2 )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_inp2,
                    var_inp2
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->f_exc_type );
    Py_CLEAR( generator->m_frame->f_exc_value );
    Py_CLEAR( generator->m_frame->f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;
    frame_no_exception_1:;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)var_o );
    Py_DECREF( var_o );
    var_o = NULL;

    CHECK_OBJECT( (PyObject *)var_s );
    Py_DECREF( var_s );
    var_s = NULL;

    Py_XDECREF( var_inp );
    var_inp = NULL;

    Py_XDECREF( var_out );
    var_out = NULL;

    Py_XDECREF( var_inp1 );
    var_inp1 = NULL;

    Py_XDECREF( var_inp2 );
    var_inp2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:
    try_end_3:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    CHECK_OBJECT( (PyObject *)var_o );
    Py_DECREF( var_o );
    var_o = NULL;

    CHECK_OBJECT( (PyObject *)var_s );
    Py_DECREF( var_s );
    var_s = NULL;

    Py_XDECREF( var_inp );
    var_inp = NULL;

    Py_XDECREF( var_out );
    var_out = NULL;

    Py_XDECREF( var_inp1 );
    var_inp1 = NULL;

    Py_XDECREF( var_inp2 );
    var_inp2 = NULL;


    RESTORE_ERROR_OCCURRED( PyExc_StopIteration, NULL, NULL );
    Py_INCREF( PyExc_StopIteration );

    generator->m_yielded = NULL;
    return;

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    generator->m_yielded = NULL;
    return;

}


static PyObject *impl_function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9906050be76d57fd965f5de66a14598d, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_arange );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_arange );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "arange" );
        exception_tb = NULL;

        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyCell_GET( self->m_closure[2] );

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "s" );
        exception_tb = NULL;

        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1719;
    tmp_slice_source_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }
    tmp_slice_lower_1 = PyCell_GET( self->m_closure[1] );

    if ( tmp_slice_lower_1 == NULL )
    {
        Py_DECREF( tmp_slice_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "o" );
        exception_tb = NULL;

        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, Py_None );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1719;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto function_return_exit;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_s,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_o,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_5232c97b289a40c836390c2babeee349, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_arange );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_arange );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "arange" );
        exception_tb = NULL;

        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyCell_GET( self->m_closure[2] );

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "s" );
        exception_tb = NULL;

        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1732;
    tmp_slice_source_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }
    tmp_slice_lower_1 = PyCell_GET( self->m_closure[1] );

    if ( tmp_slice_lower_1 == NULL )
    {
        Py_DECREF( tmp_slice_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "o" );
        exception_tb = NULL;

        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, Py_None );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1732;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto function_return_exit;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_s,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_o,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_slice_lower_1;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_tuple_element_1;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7487d2f1e13229893d72b28b1203255b, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_arange );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_arange );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "arange" );
        exception_tb = NULL;

        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }

    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyCell_GET( self->m_closure[2] );

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "s" );
        exception_tb = NULL;

        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = PyCell_GET( self->m_closure[0] );

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "dtype" );
        exception_tb = NULL;

        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }

    tmp_dict_key_1 = const_str_plain_dtype;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1733;
    tmp_slice_source_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }
    tmp_slice_lower_1 = PyCell_GET( self->m_closure[1] );

    if ( tmp_slice_lower_1 == NULL )
    {
        Py_DECREF( tmp_slice_source_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "o" );
        exception_tb = NULL;

        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_SLICE( tmp_slice_source_1, tmp_slice_lower_1, Py_None );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1733;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto function_return_exit;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( self->m_closure[2]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_s,
                    self->m_closure[2]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_dtype,
                    self->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( self->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_o,
                    self->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_class_3_IgnoreException_of_numpy$testing$utils( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var___doc__ = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_digest_b8db3dccafc565b29732d3a675d809bc;
    assert( var___doc__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___doc__ = tmp_assign_source_2;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var___doc__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___doc__,
            var___doc__
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( class_3_IgnoreException_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( class_3_IgnoreException_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_39_tempdir_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyCellObject *par_args = PyCell_NEW1( python_pars[ 0 ] );
    PyCellObject *par_kwargs = PyCell_NEW1( python_pars[ 1 ] );
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    {
        PyCellObject **closure = (PyCellObject **)malloc(2 * sizeof(PyCellObject *));
        closure[0] = par_args;
        Py_INCREF( closure[0] );
        closure[1] = par_kwargs;
        Py_INCREF( closure[1] );

        tmp_return_value = Nuitka_Generator_New(
            genobj_1_tempdir_of_function_39_tempdir_of_numpy$testing$utils_context,
            const_str_plain_tempdir,
#if PYTHON_VERSION >= 350
            NULL,
#endif
            codeobj_8e85d29cfafad5e08d87eabd867e8ec0,
            closure,
            2
        );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_39_tempdir_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kwargs );
    Py_DECREF( par_kwargs );
    par_kwargs = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_39_tempdir_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static void genobj_1_tempdir_of_function_39_tempdir_of_numpy$testing$utils_context( Nuitka_GeneratorObject *generator )
{
    CHECK_OBJECT( (PyObject *)generator );
    assert( Nuitka_Generator_Check( (PyObject *)generator ) );

    // Local variable initialization
    PyObject *var_tmpdir = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_expression_name_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_generator = NULL;


    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_generator, codeobj_85a710849982088049252d2a8b21a1e6, module_numpy$testing$utils );
    generator->m_frame = cache_frame_generator;
    Py_INCREF( generator->m_frame );

#if PYTHON_VERSION >= 340
    generator->m_frame->f_gen = (PyObject *)generator;
#endif

    Py_CLEAR( generator->m_frame->f_back );

    generator->m_frame->f_back = PyThreadState_GET()->frame;
    Py_INCREF( generator->m_frame->f_back );

    PyThreadState_GET()->frame = generator->m_frame;
    Py_INCREF( generator->m_frame );

#if PYTHON_VERSION >= 340
    generator->m_frame->f_executing += 1;
#endif

#if PYTHON_VERSION >= 300
    // Accept currently existing exception as the one to publish again when we
    // yield or yield from.

    PyThreadState *thread_state = PyThreadState_GET();

    generator->m_frame->f_exc_type = thread_state->exc_type;
    if ( generator->m_frame->f_exc_type == Py_None ) generator->m_frame->f_exc_type = NULL;
    Py_XINCREF( generator->m_frame->f_exc_type );
    generator->m_frame->f_exc_value = thread_state->exc_value;
    Py_XINCREF( generator->m_frame->f_exc_value );
    generator->m_frame->f_exc_traceback = thread_state->exc_traceback;
    Py_XINCREF( generator->m_frame->f_exc_traceback );
#endif

    // Framed code:
    // Throwing into not started generators is possible. As they don't stand any
    // chance to deal with them, we might as well create traceback on the
    // outside,
    if ( generator->m_exception_type )
    {
        generator->m_yielded = NULL;

        exception_type = generator->m_exception_type;
        generator->m_exception_type = NULL;

        exception_value = generator->m_exception_value;
        generator->m_exception_value = NULL;

        exception_tb = generator->m_exception_tb;;
        generator->m_exception_tb = NULL;

        if (exception_tb == NULL)
        {
            exception_lineno = 1759;
            goto frame_exception_exit_1;
        }
        else
        {
            goto function_exception_exit;
        }
    }

    tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_mkdtemp );

    if (unlikely( tmp_dircall_arg1_1 == NULL ))
    {
        tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_mkdtemp );
    }

    if ( tmp_dircall_arg1_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "mkdtemp" );
        exception_tb = NULL;

        exception_lineno = 1767;
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg2_1 = PyCell_GET( generator->m_closure[0] );

    if ( tmp_dircall_arg2_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "args" );
        exception_tb = NULL;

        exception_lineno = 1767;
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg3_1 = PyCell_GET( generator->m_closure[1] );

    if ( tmp_dircall_arg3_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "kwargs" );
        exception_tb = NULL;

        exception_lineno = 1767;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_dircall_arg1_1 );
    Py_INCREF( tmp_dircall_arg2_1 );
    Py_INCREF( tmp_dircall_arg3_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_assign_source_1 = impl_function_1_complex_call_helper_star_list_star_dict_of___internal__( dir_call_args );
    }
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1767;
        goto frame_exception_exit_1;
    }
    assert( var_tmpdir == NULL );
    var_tmpdir = tmp_assign_source_1;

    tmp_expression_name_1 = var_tmpdir;

    tmp_unused = YIELD( generator, INCREASE_REFCOUNT( tmp_expression_name_1 ) );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1768;
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_shutil );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_shutil );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "shutil" );
        exception_tb = NULL;

        exception_lineno = 1769;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_rmtree );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1769;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_tmpdir;

    generator->m_frame->f_lineno = 1769;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1769;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if PYTHON_VERSION >= 340
    generator->m_frame->f_executing -= 1;
#endif

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->f_exc_type );
    Py_CLEAR( generator->m_frame->f_exc_value );
    Py_CLEAR( generator->m_frame->f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    goto frame_no_exception_1;

    frame_exception_exit_1:;

    // If it's not an exit exception, consider and create a traceback for it.
    if ( !EXCEPTION_MATCH_GENERATOR( exception_type ) )
    {
        int needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_tb->tb_frame != generator->m_frame )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( generator->m_frame, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( generator->m_closure[0]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_args,
                    generator->m_closure[0]->ob_ref
                );

                assert( res == 0 );
            }

            if ( generator->m_closure[1]->ob_ref )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_kwargs,
                    generator->m_closure[1]->ob_ref
                );

                assert( res == 0 );
            }

            if ( var_tmpdir )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_tmpdir,
                    var_tmpdir
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

#if PYTHON_VERSION >= 300
    Py_CLEAR( generator->m_frame->f_exc_type );
    Py_CLEAR( generator->m_frame->f_exc_value );
    Py_CLEAR( generator->m_frame->f_exc_traceback );
#endif

    Py_DECREF( generator->m_frame );
    // Return the error.
    goto try_except_handler_1;
    frame_no_exception_1:;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( var_tmpdir );
    var_tmpdir = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)var_tmpdir );
    Py_DECREF( var_tmpdir );
    var_tmpdir = NULL;


    RESTORE_ERROR_OCCURRED( PyExc_StopIteration, NULL, NULL );
    Py_INCREF( PyExc_StopIteration );

    generator->m_yielded = NULL;
    return;

    function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    generator->m_yielded = NULL;
    return;

}


NUITKA_LOCAL_MODULE PyObject *impl_class_4_clear_and_catch_warnings_of_numpy$testing$utils( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var___doc__ = NULL;
    PyObject *var_class_modules = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var___enter__ = NULL;
    PyObject *var___exit__ = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_defaults_1;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_digest_f3aa1440a461949e616dcc68ee318c24;
    assert( var___doc__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___doc__ = tmp_assign_source_2;

    tmp_assign_source_3 = const_tuple_empty;
    assert( var_class_modules == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_class_modules = tmp_assign_source_3;

    tmp_defaults_1 = const_tuple_false_tuple_empty_tuple;
    tmp_assign_source_4 = MAKE_FUNCTION_function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ) );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_4;

    tmp_assign_source_5 = MAKE_FUNCTION_function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  );
    assert( var___enter__ == NULL );
    var___enter__ = tmp_assign_source_5;

    tmp_assign_source_6 = MAKE_FUNCTION_function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  );
    assert( var___exit__ == NULL );
    var___exit__ = tmp_assign_source_6;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var___doc__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___doc__,
            var___doc__
        );

        assert( res == 0 );
    }

    if ( var_class_modules )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_class_modules,
            var_class_modules
        );

        assert( res == 0 );
    }

    if ( var___init__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___init__,
            var___init__
        );

        assert( res == 0 );
    }

    if ( var___enter__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___enter__,
            var___enter__
        );

        assert( res == 0 );
    }

    if ( var___exit__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___exit__,
            var___exit__
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var___doc__ );
    Py_DECREF( var___doc__ );
    var___doc__ = NULL;

    CHECK_OBJECT( (PyObject *)var_class_modules );
    Py_DECREF( var_class_modules );
    var_class_modules = NULL;

    CHECK_OBJECT( (PyObject *)var___init__ );
    Py_DECREF( var___init__ );
    var___init__ = NULL;

    CHECK_OBJECT( (PyObject *)var___enter__ );
    Py_DECREF( var___enter__ );
    var___enter__ = NULL;

    CHECK_OBJECT( (PyObject *)var___exit__ );
    Py_DECREF( var___exit__ );
    var___exit__ = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_record = python_pars[ 1 ];
    PyObject *par_modules = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_object_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_set_arg_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_affaaf4d719268a18c5a686b7dee4168, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_set_arg_1 = par_modules;

    tmp_source_name_1 = PySet_New( tmp_set_arg_1 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1813;
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_union );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1813;
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_class_modules );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1813;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1813;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1813;
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_modules, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1813;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_assattr_name_2 = PyDict_New();
    tmp_assattr_target_2 = par_self;

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__warnreg_copies, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 1814;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "clear_and_catch_warnings" );
        exception_tb = NULL;

        exception_lineno = 1815;
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    tmp_source_name_3 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain___init__ );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = par_record;

    tmp_dict_key_1 = const_str_plain_record;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->f_lineno = 1815;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1815;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_record )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_record,
                    par_record
                );

                assert( res == 0 );
            }

            if ( par_modules )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_modules,
                    par_modules
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_record );
    Py_DECREF( par_record );
    par_record = NULL;

    CHECK_OBJECT( (PyObject *)par_modules );
    Py_DECREF( par_modules );
    par_modules = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_record );
    Py_DECREF( par_record );
    par_record = NULL;

    CHECK_OBJECT( (PyObject *)par_modules );
    Py_DECREF( par_modules );
    par_modules = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_mod = NULL;
    PyObject *var_mod_reg = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_frame_locals;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_object_name_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_c8ab0713973ccc44e3ab70252cc07fb1, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_source_name_1 = par_self;

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_modules );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1818;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1818;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1818;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_mod;
        var_mod = tmp_assign_source_3;
        Py_INCREF( var_mod );
        Py_XDECREF( old );
    }

    tmp_hasattr_source_1 = var_mod;

    tmp_hasattr_attr_1 = const_str_plain___warningregistry__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1819;
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = var_mod;

    tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___warningregistry__ );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1820;
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_mod_reg;
        var_mod_reg = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_source_name_3 = var_mod_reg;

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_copy );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1821;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1821;
    tmp_ass_subvalue_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    Py_DECREF( tmp_called_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1821;
        goto try_except_handler_2;
    }
    tmp_source_name_4 = par_self;

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__warnreg_copies );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1821;
        goto try_except_handler_2;
    }
    tmp_ass_subscript_1 = var_mod;

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1821;
        goto try_except_handler_2;
    }
    tmp_source_name_5 = var_mod_reg;

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_clear );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1822;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1822;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1822;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1818;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "clear_and_catch_warnings" );
        exception_tb = NULL;

        exception_lineno = 1823;
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    tmp_source_name_6 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1823;
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___enter__ );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1823;
        goto frame_exception_exit_1;
    }
    frame_function->f_lineno = 1823;
    tmp_return_value = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    Py_DECREF( tmp_called_name_3 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1823;
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto try_return_handler_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( var_mod )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_mod,
                    var_mod
                );

                assert( res == 0 );
            }

            if ( var_mod_reg )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_mod_reg,
                    var_mod_reg
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_mod );
    var_mod = NULL;

    Py_XDECREF( var_mod_reg );
    var_mod_reg = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_mod );
    var_mod = NULL;

    Py_XDECREF( var_mod_reg );
    var_mod_reg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_exc_info = python_pars[ 1 ];
    PyObject *var_mod = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_frame_locals;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_object_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_type_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static PyFrameObject *cache_frame_function = NULL;

    PyFrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_98138bf4ed25d13866efd10b9cec44d9, module_numpy$testing$utils );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    Py_INCREF( frame_function );
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

#if PYTHON_VERSION >= 340
    frame_function->f_executing += 1;
#endif

    // Framed code:
    tmp_type_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );

    if (unlikely( tmp_type_name_1 == NULL ))
    {
        tmp_type_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings );
    }

    if ( tmp_type_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "clear_and_catch_warnings" );
        exception_tb = NULL;

        exception_lineno = 1826;
        goto frame_exception_exit_1;
    }

    tmp_object_name_1 = par_self;

    tmp_source_name_1 = BUILTIN_SUPER( tmp_type_name_1, tmp_object_name_1 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1826;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___exit__ );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1826;
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = par_exc_info;

    Py_INCREF( tmp_dircall_arg2_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1};
        tmp_unused = impl_function_6_complex_call_helper_star_list_of___internal__( dir_call_args );
    }
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1826;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = par_self;

    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_modules );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1827;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1827;
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            frame_function->f_lineno = 1827;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    {
        PyObject *old = var_mod;
        var_mod = tmp_assign_source_3;
        Py_INCREF( var_mod );
        Py_XDECREF( old );
    }

    tmp_hasattr_source_1 = var_mod;

    tmp_hasattr_attr_1 = const_str_plain___warningregistry__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1828;
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_4 = var_mod;

    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___warningregistry__ );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1829;
        goto try_except_handler_2;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_clear );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1829;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1829;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1829;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_compare_left_1 = var_mod;

    tmp_source_name_5 = par_self;

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__warnreg_copies );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1830;
        goto try_except_handler_2;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_7 = var_mod;

    tmp_source_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain___warningregistry__ );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1831;
        goto try_except_handler_2;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_update );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1831;
        goto try_except_handler_2;
    }
    tmp_source_name_8 = par_self;

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__warnreg_copies );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1831;
        goto try_except_handler_2;
    }
    tmp_subscript_name_1 = var_mod;

    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1831;
        goto try_except_handler_2;
    }
    frame_function->f_lineno = 1831;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1831;
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1827;
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif
    // Put the previous frame back on top.
    popFrameStack();
#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );
    goto frame_no_exception_1;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    {
        bool needs_detach = false;

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
            needs_detach = true;
        }
        else if ( exception_lineno != -1 )
        {
            PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_function, exception_lineno );
            traceback_new->tb_next = exception_tb;
            exception_tb = traceback_new;

            needs_detach = true;
        }

        if (needs_detach)
        {

            tmp_frame_locals = PyDict_New();
            if ( par_self )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_self,
                    par_self
                );

                assert( res == 0 );
            }

            if ( par_exc_info )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_exc_info,
                    par_exc_info
                );

                assert( res == 0 );
            }

            if ( var_mod )
            {
                int res = PyDict_SetItem(
                    tmp_frame_locals,
                    const_str_plain_mod,
                    var_mod
                );

                assert( res == 0 );
            }



            detachFrame( exception_tb, tmp_frame_locals );
        }
    }

    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_function->f_executing -= 1;
#endif
    Py_DECREF( frame_function );

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_info );
    Py_DECREF( par_exc_info );
    par_exc_info = NULL;

    Py_XDECREF( var_mod );
    var_mod = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_exc_info );
    Py_DECREF( par_exc_info );
    par_exc_info = NULL;

    Py_XDECREF( var_mod );
    var_mod = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_function_10_jiffies_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_10_jiffies_of_numpy$testing$utils,
        const_str_plain_jiffies,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_93f4b121ec830060d3ee45a03e212aaa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_58cd5d23011fe45d68c661820d95e72a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_11_jiffies_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_11_jiffies_of_numpy$testing$utils,
        const_str_plain_jiffies,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3f2b26218a09d13378fbe840b5a42d0d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_58cd5d23011fe45d68c661820d95e72a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_12_build_err_msg_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_12_build_err_msg_of_numpy$testing$utils,
        const_str_plain_build_err_msg,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_033604a5dde6d855150cecf0e266f33b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_13_assert_equal_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_13_assert_equal_of_numpy$testing$utils,
        const_str_plain_assert_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8838e1559d7858c5c5fc0fb43fdca72b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_70e70eb6e19e3ba7a8df4bc2c8ec15e1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_14_print_assert_equal_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_14_print_assert_equal_of_numpy$testing$utils,
        const_str_plain_print_assert_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5cbcc38223452863a1215e2af673137c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_9070b22dec0007c1ed173e33a0aa0267
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_15_assert_almost_equal_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_15_assert_almost_equal_of_numpy$testing$utils,
        const_str_plain_assert_almost_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_41969be122ed93b49137ea1ebeb38ab0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_81dc02c5320ca87464caf6ab2dc34793
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_16_assert_approx_equal_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_16_assert_approx_equal_of_numpy$testing$utils,
        const_str_plain_assert_approx_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9fc789f06cba154e0a2541c13da7f923,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_456ba859d4899c52c81b368fddf2b93e
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_17_assert_array_compare_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_17_assert_array_compare_of_numpy$testing$utils,
        const_str_plain_assert_array_compare,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cf7e4fb007c611d7dea94190d4a66a81,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_18_assert_array_equal_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_18_assert_array_equal_of_numpy$testing$utils,
        const_str_plain_assert_array_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_09ef3af3431a4fa1129a67fa2c1de11e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_e6c9ce73383c66ad08c690eb2446230f
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_19_assert_array_almost_equal_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_19_assert_array_almost_equal_of_numpy$testing$utils,
        const_str_plain_assert_array_almost_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_874200c3ed7fb0f73a4df53e0e9b1954,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_10016e38cd632602d89b215a3ff5e326
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_1___init___of_class_1_WarningMessage_of_numpy$testing$utils,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a6ccce2decf1b651db1c2fa11a115723,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_1___init___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3575a0e9fbc395e93c9cd8a07c227ba5,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_2_WarningManager_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_1___init___of_class_2_WarningManager_of_numpy$testing$utils,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9ecb26975b952a181c2d41916c1878f4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_1___init___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_affaaf4d719268a18c5a686b7dee4168,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils( PyCellObject *closure_actual, PyCellObject *closure_decimal, PyCellObject *closure_desired, PyCellObject *closure_err_msg, PyCellObject *closure_verbose )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(5 * sizeof(PyCellObject *));
    closure[0] = closure_actual;
    Py_INCREF( closure[0] );
    closure[1] = closure_decimal;
    Py_INCREF( closure[1] );
    closure[2] = closure_desired;
    Py_INCREF( closure[2] );
    closure[3] = closure_err_msg;
    Py_INCREF( closure[3] );
    closure[4] = closure_verbose;
    Py_INCREF( closure[4] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1__build_err_msg_of_function_15_assert_almost_equal_of_numpy$testing$utils,
        const_str_plain__build_err_msg,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_526b6bc1518281356090ffa6209cb91d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        5
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils( PyCellObject *closure_np )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(1 * sizeof(PyCellObject *));
    closure[0] = closure_np;
    Py_INCREF( closure[0] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1__diff_of_function_33_nulp_diff_of_numpy$testing$utils,
        const_str_plain__diff,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f46d6f13257c231e287f664132352d97,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_assert__of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_1_assert__of_numpy$testing$utils,
        const_str_plain_assert_,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_66e310b6382dcc8bee7ef8f0d5a806e1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_aee23a7bc27675cbddeb9e3733927de8
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils( PyCellObject *closure_around, PyCellObject *closure_array, PyCellObject *closure_decimal, PyCellObject *closure_float_, PyCellObject *closure_issubdtype, PyCellObject *closure_npany, PyCellObject *closure_number, PyCellObject *closure_result_type )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(8 * sizeof(PyCellObject *));
    closure[0] = closure_around;
    Py_INCREF( closure[0] );
    closure[1] = closure_array;
    Py_INCREF( closure[1] );
    closure[2] = closure_decimal;
    Py_INCREF( closure[2] );
    closure[3] = closure_float_;
    Py_INCREF( closure[3] );
    closure[4] = closure_issubdtype;
    Py_INCREF( closure[4] );
    closure[5] = closure_npany;
    Py_INCREF( closure[5] );
    closure[6] = closure_number;
    Py_INCREF( closure[6] );
    closure[7] = closure_result_type;
    Py_INCREF( closure[7] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_compare_of_function_19_assert_array_almost_equal_of_numpy$testing$utils,
        const_str_plain_compare,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1b5e769d1ab43c8483d069aae12da6cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        8
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils( PyCellObject *closure_atol, PyCellObject *closure_equal_nan, PyCellObject *closure_np, PyCellObject *closure_rtol )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(4 * sizeof(PyCellObject *));
    closure[0] = closure_atol;
    Py_INCREF( closure[0] );
    closure[1] = closure_equal_nan;
    Py_INCREF( closure[1] );
    closure[2] = closure_np;
    Py_INCREF( closure[2] );
    closure[3] = closure_rtol;
    Py_INCREF( closure[3] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_compare_of_function_30_assert_allclose_of_numpy$testing$utils,
        const_str_plain_compare,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a31fcecd29c0c1003e04b552a4f105ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils( PyCellObject *closure__AssertRaisesContext )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(1 * sizeof(PyCellObject *));
    closure[0] = closure__AssertRaisesContext;
    Py_INCREF( closure[0] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_impl_of_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain_impl,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c924695e3d917a7e69c51bff702e46aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils( PyCellObject *closure_msg )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(1 * sizeof(PyCellObject *));
    closure[0] = closure_msg;
    Py_INCREF( closure[0] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_lambda_of_function_23_rundocs_of_numpy$testing$utils,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_89a43f46680c3f0d4ec63f81244a810a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(3 * sizeof(PyCellObject *));
    closure[0] = closure_dtype;
    Py_INCREF( closure[0] );
    closure[1] = closure_o;
    Py_INCREF( closure[1] );
    closure[2] = closure_s;
    Py_INCREF( closure[2] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9906050be76d57fd965f5de66a14598d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        3
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils( PyCellObject *closure_comparison )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(1 * sizeof(PyCellObject *));
    closure[0] = closure_comparison;
    Py_INCREF( closure[0] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_safe_comparison_of_function_17_assert_array_compare_of_numpy$testing$utils,
        const_str_plain_safe_comparison,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_753834d880feddf88ba10a2a5814f57b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils( PyCellObject *closure_log )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(1 * sizeof(PyCellObject *));
    closure[0] = closure_log;
    Py_INCREF( closure[0] );


    PyObject *result = Nuitka_Function_New(
        impl_function_1_showwarning_of_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils,
        const_str_plain_showwarning,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bedbec43eef32e147159ef476305f109,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_20_assert_array_less_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_20_assert_array_less_of_numpy$testing$utils,
        const_str_plain_assert_array_less,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eed94b1bf413990886124f4252687f2e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_9f56a9d5b59582b4c0da971506f2216a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_21_runstring_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_21_runstring_of_numpy$testing$utils,
        const_str_plain_runstring,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_12d12328d75fe88aa971be74bf134475,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_22_assert_string_equal_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_22_assert_string_equal_of_numpy$testing$utils,
        const_str_plain_assert_string_equal,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_42d4d08591aaf7b9488da449f1a61731,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_9fe74df5f37fb0f3159d9349320195f0
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_23_rundocs_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_23_rundocs_of_numpy$testing$utils,
        const_str_plain_rundocs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_da65c2aed225a04117b73452ab716f1b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_6f8248c0cd0a61aee0231b6be5326ece
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_24_raises_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_24_raises_of_numpy$testing$utils,
        const_str_plain_raises,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cd0d3ab68268b8b182327a55f30686c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_25_assert_raises_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_25_assert_raises_of_numpy$testing$utils,
        const_str_plain_assert_raises,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e4e8dd9562b52d56409fe506920e113b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_8f7e46a753006e8bd692e624f140d763
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_26_assert_raises_regex_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain_assert_raises_regex,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e67db4e37ff46531ff4ac7fd61eae93a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_80faa6a434267444203aa2503ce280fc
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_27_decorate_methods_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_27_decorate_methods_of_numpy$testing$utils,
        const_str_plain_decorate_methods,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a16362c40d4a926aa17d83f5f9b86aab,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_33b666deea9552cec7dcfd3e4a99577a
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_28_measure_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_28_measure_of_numpy$testing$utils,
        const_str_plain_measure,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a0c8eabde612888da6da6c8216f40247,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_6d3284250f43666c7365582071a75109
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_29__assert_valid_refcount_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_29__assert_valid_refcount_of_numpy$testing$utils,
        const_str_plain__assert_valid_refcount,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_81e84cbbcb43fd608f0de5831954e2fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_5e34d323ebf92513bcf9eee50bcad1a1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2___enter___of_class_2_WarningManager_of_numpy$testing$utils,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_129f616448917821adcf6ec6720fa727,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2___enter___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c8ab0713973ccc44e3ab70252cc07fb1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2___str___of_class_1_WarningMessage_of_numpy$testing$utils,
        const_str_plain___str__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5ba100fadd74ce880b2ab679d91f1887,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2_failureException_of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain_failureException,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_983e6316f9929e0f980bcff6d97c595b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_gisnan_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2_gisnan_of_numpy$testing$utils,
        const_str_plain_gisnan,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1c0c8ae2b2973eef06c5a77f4c37c5c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_ff575ecee9f5e6569e4868830fcd1828
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_2_isnumber_of_function_17_assert_array_compare_of_numpy$testing$utils,
        const_str_plain_isnumber,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b8a8c9f2a0a9f64c3d7fa1de07f74944,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(3 * sizeof(PyCellObject *));
    closure[0] = closure_dtype;
    Py_INCREF( closure[0] );
    closure[1] = closure_o;
    Py_INCREF( closure[1] );
    closure[2] = closure_s;
    Py_INCREF( closure[2] );


    PyObject *result = Nuitka_Function_New(
        impl_function_2_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5232c97b289a40c836390c2babeee349,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        3
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_30_assert_allclose_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_30_assert_allclose_of_numpy$testing$utils,
        const_str_plain_assert_allclose,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_edae6eb33a8c360aab01cb7a8ffbe19e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_3720bdeeb610c78f6c12dfac8edb8c59
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils,
        const_str_plain_assert_array_almost_equal_nulp,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cf664cdcbe5f723bdc04dbe913ac524e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_4b7c0e7f23efc5fa89db71ab487de5e1
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_32_assert_array_max_ulp_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_32_assert_array_max_ulp_of_numpy$testing$utils,
        const_str_plain_assert_array_max_ulp,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_96500b0fb70eb99b7f6b07ae329a54d6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_a4d91958b6481ca3e50f61fc19ae9d9b
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_33_nulp_diff_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_33_nulp_diff_of_numpy$testing$utils,
        const_str_plain_nulp_diff,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_620b2341fdcebf2f55d1a9bce92c1454,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_93bdfe3c415d4fa99cb2dd3e286cd6d4
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_34__integer_repr_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_34__integer_repr_of_numpy$testing$utils,
        const_str_plain__integer_repr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cd5bb3d79c37ce8371d5f35c9ec85905,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_35_integer_repr_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_35_integer_repr_of_numpy$testing$utils,
        const_str_plain_integer_repr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b88dc4f1201a03e15379a75926b9b64d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_205d9edff1d3f9adea34722be04b48c3
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_36_assert_warns_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_36_assert_warns_of_numpy$testing$utils,
        const_str_plain_assert_warns,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e21fdf4eeb0bfc5a06db8cfc887f8959,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_77842bb9b08e5dafb20eb78d1603a7b5
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_37_assert_no_warnings_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_37_assert_no_warnings_of_numpy$testing$utils,
        const_str_plain_assert_no_warnings,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_49a0f05b2207530323b591c3cb8e653e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_f4e551f0ba39cf5d79afe90ee6966e81
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_38__gen_alignment_data_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_38__gen_alignment_data_of_numpy$testing$utils,
        const_str_plain__gen_alignment_data,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_35df8855789420c66c74432cc8a8fca2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_903d6b58b25be7a46249f406f02b7d41
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_39_tempdir_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_39_tempdir_of_numpy$testing$utils,
        const_str_plain_tempdir,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_85a710849982088049252d2a8b21a1e6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_6880cd150b36fa901d13829084b91966
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_3___enter___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain___enter__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_34b823b74bf81bac3faa20ccc6baf903,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_3___exit___of_class_2_WarningManager_of_numpy$testing$utils,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_85689a2364b31f10b51f5a64448c6719,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_3___exit___of_class_4_clear_and_catch_warnings_of_numpy$testing$utils,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_98138bf4ed25d13866efd10b9cec44d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils( PyObject *defaults, PyCellObject *closure_err_msg, PyCellObject *closure_header, PyCellObject *closure_precision, PyCellObject *closure_verbose, PyCellObject *closure_x, PyCellObject *closure_y )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(6 * sizeof(PyCellObject *));
    closure[0] = closure_err_msg;
    Py_INCREF( closure[0] );
    closure[1] = closure_header;
    Py_INCREF( closure[1] );
    closure[2] = closure_precision;
    Py_INCREF( closure[2] );
    closure[3] = closure_verbose;
    Py_INCREF( closure[3] );
    closure[4] = closure_x;
    Py_INCREF( closure[4] );
    closure[5] = closure_y;
    Py_INCREF( closure[5] );


    PyObject *result = Nuitka_Function_New(
        impl_function_3_chk_same_position_of_function_17_assert_array_compare_of_numpy$testing$utils,
        const_str_plain_chk_same_position,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e3989f5cbc0c9c5f85a84f34cdc23b4d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_119597c8dc0968aaf226da43c6fe7f86,
        closure,
        6
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_gisfinite_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_3_gisfinite_of_numpy$testing$utils,
        const_str_plain_gisfinite,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b4615d1c987539c7be06569babf9195e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_13df72bccf988d02cd7b35fa667a8f38
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils( PyCellObject *closure_dtype, PyCellObject *closure_o, PyCellObject *closure_s )
{
    // Copy the parameter default values and closure values over.
    PyCellObject **closure = (PyCellObject **)malloc(3 * sizeof(PyCellObject *));
    closure[0] = closure_dtype;
    Py_INCREF( closure[0] );
    closure[1] = closure_o;
    Py_INCREF( closure[1] );
    closure[2] = closure_s;
    Py_INCREF( closure[2] );


    PyObject *result = Nuitka_Function_New(
        impl_function_3_lambda_of_genobj_1__gen_alignment_data_of_function_38__gen_alignment_data_of_numpy$testing$utils,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7487d2f1e13229893d72b28b1203255b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None,
        closure,
        3
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_4___exit___of_class_1__AssertRaisesContext_of_function_26_assert_raises_regex_of_numpy$testing$utils,
        const_str_plain___exit__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_22425dfac68b1934190c6706cc5558bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_4_gisinf_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_4_gisinf_of_numpy$testing$utils,
        const_str_plain_gisinf,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bb2b89f10ff585abc6ba8f01c4c3a9d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_c73eac2486e2c9ab7692c43bd0d41203
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_5_rand_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_5_rand_of_numpy$testing$utils,
        const_str_plain_rand,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b85bf12bd445c14057852582143d7759,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_763dafaf263503aed0533c163ee5f659
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_6_GetPerformanceAttributes_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_6_GetPerformanceAttributes_of_numpy$testing$utils,
        const_str_plain_GetPerformanceAttributes,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7b878763c93d266c7fcdc81b053a237f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_7_memusage_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_7_memusage_of_numpy$testing$utils,
        const_str_plain_memusage,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_05bc7f151fd8ff6105aec533bff08469,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        Py_None
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_8_memusage_of_numpy$testing$utils( PyObject *defaults )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_8_memusage_of_numpy$testing$utils,
        const_str_plain_memusage,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ee2b3ab5579611fe12a028b5b350b0e2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_8b83d5866bfb89b1d61fc7b4d1c462b2
    );

    return result;
}



static PyObject *MAKE_FUNCTION_function_9_memusage_of_numpy$testing$utils(  )
{
    PyObject *result = Nuitka_Function_New(
        impl_function_9_memusage_of_numpy$testing$utils,
        const_str_plain_memusage,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_31e6dd57e5e17cef27fc808b38efcb43,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_numpy$testing$utils,
        const_str_digest_f4e00ed389370710d6e3415961014f9a
    );

    return result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_numpy$testing$utils =
{
    PyModuleDef_HEAD_INIT,
    "numpy.testing.utils",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( numpy$testing$utils )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_numpy$testing$utils );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    // Initialize the compiled types of Nuitka.
    PyType_Ready( &Nuitka_Generator_Type );
    PyType_Ready( &Nuitka_Function_Type );
    PyType_Ready( &Nuitka_Method_Type );
    PyType_Ready( &Nuitka_Frame_Type );
#if PYTHON_VERSION >= 350
    PyType_Ready( &Nuitka_Coroutine_Type );
    PyType_Ready( &Nuitka_CoroutineWrapper_Type );
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

#endif

#if _NUITKA_MODULE
    // Enable meta path based loader if not already done.
    setupMetaPathBasedLoader();
#endif

    createModuleConstants();
    createModuleCodeObjects();

    // puts( "in initnumpy$testing$utils" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_numpy$testing$utils = Py_InitModule4(
        "numpy.testing.utils",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No __doc__ is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    module_numpy$testing$utils = PyModule_Create( &mdef_numpy$testing$utils );
#endif

    moduledict_numpy$testing$utils = (PyDictObject *)((PyModuleObject *)module_numpy$testing$utils)->md_dict;

    CHECK_OBJECT( module_numpy$testing$utils );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_fd912075b9e13a7a79631dfbc68fa9a7, module_numpy$testing$utils );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    PyObject *module_dict = PyModule_GetDict( module_numpy$testing$utils );

    if ( PyDict_GetItem( module_dict, const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

#ifndef __NUITKA_NO_ASSERT__
        int res =
#endif
            PyDict_SetItem( module_dict, const_str_plain___builtins__, value );

        assert( res == 0 );
    }

#if PYTHON_VERSION >= 330
#if _MODULE_LOADER
    PyDict_SetItem( module_dict, const_str_plain___loader__, metapath_based_loader );
#else
    PyDict_SetItem( module_dict, const_str_plain___loader__, Py_None );
#endif
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_class_creation_3__bases = NULL;
    PyObject *tmp_class_creation_3__class_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_3__class = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_4__class = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_bases_name_2;
    PyObject *tmp_bases_name_3;
    PyObject *tmp_bases_name_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_GtE_1;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    int tmp_cmp_In_3;
    int tmp_cmp_In_4;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_defaults_8;
    PyObject *tmp_defaults_9;
    PyObject *tmp_defaults_10;
    PyObject *tmp_defaults_11;
    PyObject *tmp_defaults_12;
    PyObject *tmp_defaults_13;
    PyObject *tmp_defaults_14;
    PyObject *tmp_defaults_15;
    PyObject *tmp_defaults_16;
    PyObject *tmp_defaults_17;
    PyObject *tmp_defaults_18;
    PyObject *tmp_defaults_19;
    PyObject *tmp_defaults_20;
    PyObject *tmp_defaults_21;
    PyObject *tmp_defaults_22;
    PyObject *tmp_defaults_23;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_name_3;
    PyObject *tmp_dict_name_4;
    PyObject *tmp_import_globals_1;
    PyObject *tmp_import_globals_2;
    PyObject *tmp_import_globals_3;
    PyObject *tmp_import_globals_4;
    PyObject *tmp_import_globals_5;
    PyObject *tmp_import_globals_6;
    PyObject *tmp_import_globals_7;
    PyObject *tmp_import_globals_8;
    PyObject *tmp_import_globals_9;
    PyObject *tmp_import_globals_10;
    PyObject *tmp_import_globals_11;
    PyObject *tmp_import_globals_12;
    PyObject *tmp_import_globals_13;
    PyObject *tmp_import_globals_14;
    PyObject *tmp_import_globals_15;
    PyObject *tmp_import_globals_16;
    PyObject *tmp_import_globals_17;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_import_name_from_10;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_key_name_3;
    PyObject *tmp_key_name_4;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    Py_ssize_t tmp_slice_index_upper_1;
    Py_ssize_t tmp_slice_index_upper_2;
    PyObject *tmp_slice_source_1;
    PyObject *tmp_slice_source_2;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyFrameObject *frame_module;


    // Module code.
    tmp_assign_source_1 = const_str_digest_8e1fb0dba5305fae554d7725ccda8ffe;
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = const_str_digest_dc6af44bedb1bd2ed8631e928612f8de;
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = PyObject_GetAttrString(PyImport_ImportModule("__future__"), "division");
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_division, tmp_assign_source_3 );
    tmp_assign_source_4 = PyObject_GetAttrString(PyImport_ImportModule("__future__"), "absolute_import");
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_absolute_import, tmp_assign_source_4 );
    tmp_assign_source_5 = PyObject_GetAttrString(PyImport_ImportModule("__future__"), "print_function");
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_print_function, tmp_assign_source_5 );
    // Frame without reuse.
    frame_module = MAKE_MODULE_FRAME( codeobj_d59398517c300e4bb781b79213b13652, module_numpy$testing$utils );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_module );
    assert( Py_REFCNT( frame_module ) == 1 );

#if PYTHON_VERSION >= 340
    frame_module->f_executing += 1;
#endif

    // Framed code:
    tmp_import_globals_1 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 7;
    tmp_assign_source_6 = IMPORT_MODULE( const_str_plain_os, tmp_import_globals_1, tmp_import_globals_1, Py_None, const_int_0 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 7;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os, tmp_assign_source_6 );
    tmp_import_globals_2 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 8;
    tmp_assign_source_7 = IMPORT_MODULE( const_str_plain_sys, tmp_import_globals_2, tmp_import_globals_2, Py_None, const_int_0 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 8;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys, tmp_assign_source_7 );
    tmp_import_globals_3 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 9;
    tmp_assign_source_8 = IMPORT_MODULE( const_str_plain_re, tmp_import_globals_3, tmp_import_globals_3, Py_None, const_int_0 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_re, tmp_assign_source_8 );
    tmp_import_globals_4 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 10;
    tmp_assign_source_9 = IMPORT_MODULE( const_str_plain_operator, tmp_import_globals_4, tmp_import_globals_4, Py_None, const_int_0 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 10;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_operator, tmp_assign_source_9 );
    tmp_import_globals_5 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 11;
    tmp_assign_source_10 = IMPORT_MODULE( const_str_plain_warnings, tmp_import_globals_5, tmp_import_globals_5, Py_None, const_int_0 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings, tmp_assign_source_10 );
    tmp_import_globals_6 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 12;
    tmp_import_name_from_1 = IMPORT_MODULE( const_str_plain_functools, tmp_import_globals_6, tmp_import_globals_6, const_tuple_str_plain_partial_tuple, const_int_0 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_partial );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_11 );
    tmp_import_globals_7 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 13;
    tmp_assign_source_12 = IMPORT_MODULE( const_str_plain_shutil, tmp_import_globals_7, tmp_import_globals_7, Py_None, const_int_0 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 13;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_shutil, tmp_assign_source_12 );
    tmp_import_globals_8 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 14;
    tmp_assign_source_13 = IMPORT_MODULE( const_str_plain_contextlib, tmp_import_globals_8, tmp_import_globals_8, Py_None, const_int_0 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_contextlib, tmp_assign_source_13 );
    tmp_import_globals_9 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 15;
    tmp_import_name_from_2 = IMPORT_MODULE( const_str_plain_tempfile, tmp_import_globals_9, tmp_import_globals_9, const_tuple_str_plain_mkdtemp_tuple, const_int_0 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_mkdtemp );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_mkdtemp, tmp_assign_source_14 );
    tmp_import_globals_10 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 16;
    tmp_import_name_from_3 = IMPORT_MODULE( const_str_plain_nosetester, tmp_import_globals_10, tmp_import_globals_10, const_tuple_str_plain_import_nose_tuple, const_int_pos_1 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_import_nose );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_import_nose, tmp_assign_source_15 );
    tmp_import_globals_11 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 17;
    tmp_import_name_from_4 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_11, tmp_import_globals_11, const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, const_int_0 );
    if ( tmp_import_name_from_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_16 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_float32 );
    Py_DECREF( tmp_import_name_from_4 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_float32, tmp_assign_source_16 );
    tmp_import_globals_12 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 17;
    tmp_import_name_from_5 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_12, tmp_import_globals_12, const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, const_int_0 );
    if ( tmp_import_name_from_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_17 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_empty );
    Py_DECREF( tmp_import_name_from_5 );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_empty, tmp_assign_source_17 );
    tmp_import_globals_13 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 17;
    tmp_import_name_from_6 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_13, tmp_import_globals_13, const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, const_int_0 );
    if ( tmp_import_name_from_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_18 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_arange );
    Py_DECREF( tmp_import_name_from_6 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_arange, tmp_assign_source_18 );
    tmp_import_globals_14 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 17;
    tmp_import_name_from_7 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_14, tmp_import_globals_14, const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, const_int_0 );
    if ( tmp_import_name_from_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_19 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_array_repr );
    Py_DECREF( tmp_import_name_from_7 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_array_repr, tmp_assign_source_19 );
    tmp_import_globals_15 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 17;
    tmp_import_name_from_8 = IMPORT_MODULE( const_str_digest_4dcaa53e76b317037ea1e395a40c5c89, tmp_import_globals_15, tmp_import_globals_15, const_tuple_67cbd1c28cbabbc57077461585c71131_tuple, const_int_0 );
    if ( tmp_import_name_from_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_20 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_ndarray );
    Py_DECREF( tmp_import_name_from_8 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_ndarray, tmp_assign_source_20 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 19;
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_version_info );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 19;
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_0;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 19;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_GtE_1 = RICH_COMPARE_BOOL_GE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_GtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 19;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_GtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_import_globals_16 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 20;
    tmp_import_name_from_9 = IMPORT_MODULE( const_str_plain_io, tmp_import_globals_16, tmp_import_globals_16, const_tuple_str_plain_StringIO_tuple, const_int_0 );
    if ( tmp_import_name_from_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_21 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_StringIO );
    Py_DECREF( tmp_import_name_from_9 );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_StringIO, tmp_assign_source_21 );
    goto branch_end_1;
    branch_no_1:;
    tmp_import_globals_17 = ((PyModuleObject *)module_numpy$testing$utils)->md_dict;
    frame_module->f_lineno = 22;
    tmp_import_name_from_10 = IMPORT_MODULE( const_str_plain_StringIO, tmp_import_globals_17, tmp_import_globals_17, const_tuple_str_plain_StringIO_tuple, const_int_0 );
    if ( tmp_import_name_from_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;
        goto frame_exception_exit_1;
    }
    tmp_assign_source_22 = IMPORT_NAME( tmp_import_name_from_10, const_str_plain_StringIO );
    Py_DECREF( tmp_import_name_from_10 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_StringIO, tmp_assign_source_22 );
    branch_end_1:;
    tmp_assign_source_23 = LIST_COPY( const_list_cc63f582defe892cc1040360b3f654ab_list );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_23 );
    tmp_assign_source_24 = const_int_0;
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_verbose, tmp_assign_source_24 );
    tmp_defaults_1 = const_tuple_str_empty_tuple;
    tmp_assign_source_25 = MAKE_FUNCTION_function_1_assert__of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_1 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_, tmp_assign_source_25 );
    tmp_assign_source_26 = MAKE_FUNCTION_function_2_gisnan_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisnan, tmp_assign_source_26 );
    tmp_assign_source_27 = MAKE_FUNCTION_function_3_gisfinite_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisfinite, tmp_assign_source_27 );
    tmp_assign_source_28 = MAKE_FUNCTION_function_4_gisinf_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_gisinf, tmp_assign_source_28 );
    tmp_assign_source_29 = MAKE_FUNCTION_function_5_rand_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_rand, tmp_assign_source_29 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 121;
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_str_plain_nt;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ_NORECURSE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 121;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_defaults_2 = const_tuple_none_int_neg_1_none_none_tuple;
    tmp_assign_source_30 = MAKE_FUNCTION_function_6_GetPerformanceAttributes_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_2 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_GetPerformanceAttributes, tmp_assign_source_30 );
    tmp_defaults_3 = const_tuple_str_plain_python_int_0_tuple;
    tmp_assign_source_31 = MAKE_FUNCTION_function_7_memusage_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_3 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_memusage, tmp_assign_source_31 );
    goto branch_end_2;
    branch_no_2:;
    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = 5;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 155;
        goto frame_exception_exit_1;
    }

    tmp_slice_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_platform );
    if ( tmp_slice_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 155;
        goto frame_exception_exit_1;
    }
    tmp_compare_left_3 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    Py_DECREF( tmp_slice_source_1 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 155;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_str_plain_linux;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ_NORECURSE( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 155;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_defaults_4 = PyTuple_New( 1 );
    tmp_left_name_1 = const_str_digest_43e8d9e479afe33589f6c45c6a84edf4;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_defaults_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 157;
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_getpid );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_4 );

        exception_lineno = 157;
        goto frame_exception_exit_1;
    }
    frame_module->f_lineno = 157;
    tmp_right_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    Py_DECREF( tmp_called_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_4 );

        exception_lineno = 157;
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_4 );

        exception_lineno = 157;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_1 );
    tmp_assign_source_32 = MAKE_FUNCTION_function_8_memusage_of_numpy$testing$utils( tmp_defaults_4 );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_memusage, tmp_assign_source_32 );
    goto branch_end_3;
    branch_no_3:;
    tmp_assign_source_33 = MAKE_FUNCTION_function_9_memusage_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_memusage, tmp_assign_source_33 );
    branch_end_3:;
    branch_end_2:;
    tmp_sliceslicedel_index_lower_2 = 0;
    tmp_slice_index_upper_2 = 5;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_sys );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sys );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "sys" );
        exception_tb = NULL;

        exception_lineno = 178;
        goto frame_exception_exit_1;
    }

    tmp_slice_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_platform );
    if ( tmp_slice_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 178;
        goto frame_exception_exit_1;
    }
    tmp_compare_left_4 = LOOKUP_INDEX_SLICE( tmp_slice_source_2, tmp_sliceslicedel_index_lower_2, tmp_slice_index_upper_2 );
    Py_DECREF( tmp_slice_source_2 );
    if ( tmp_compare_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 178;
        goto frame_exception_exit_1;
    }
    tmp_compare_right_4 = const_str_plain_linux;
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ_NORECURSE( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );

        exception_lineno = 178;
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_4 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_defaults_5 = PyTuple_New( 2 );
    tmp_left_name_2 = const_str_digest_43e8d9e479afe33589f6c45c6a84edf4;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_os );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_os );
    }

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_defaults_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "os" );
        exception_tb = NULL;

        exception_lineno = 179;
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_getpid );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_5 );

        exception_lineno = 179;
        goto frame_exception_exit_1;
    }
    frame_module->f_lineno = 179;
    tmp_right_name_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    Py_DECREF( tmp_called_name_2 );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_5 );

        exception_lineno = 179;
        goto frame_exception_exit_1;
    }
    tmp_tuple_element_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_defaults_5 );

        exception_lineno = 179;
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_defaults_5, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = PyList_New( 0 );
    PyTuple_SET_ITEM( tmp_defaults_5, 1, tmp_tuple_element_2 );
    tmp_assign_source_34 = MAKE_FUNCTION_function_10_jiffies_of_numpy$testing$utils( tmp_defaults_5 );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_jiffies, tmp_assign_source_34 );
    goto branch_end_4;
    branch_no_4:;
    tmp_defaults_6 = PyTuple_New( 1 );
    tmp_tuple_element_3 = PyList_New( 0 );
    PyTuple_SET_ITEM( tmp_defaults_6, 0, tmp_tuple_element_3 );
    tmp_assign_source_35 = MAKE_FUNCTION_function_11_jiffies_of_numpy$testing$utils( tmp_defaults_6 );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_jiffies, tmp_assign_source_35 );
    branch_end_4:;
    tmp_defaults_7 = const_tuple_8db0a0d4af591fef292bd375da2002e2_tuple;
    tmp_assign_source_36 = MAKE_FUNCTION_function_12_build_err_msg_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_7 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_build_err_msg, tmp_assign_source_36 );
    tmp_defaults_8 = const_tuple_str_empty_true_tuple;
    tmp_assign_source_37 = MAKE_FUNCTION_function_13_assert_equal_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_8 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_equal, tmp_assign_source_37 );
    tmp_assign_source_38 = MAKE_FUNCTION_function_14_print_assert_equal_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_print_assert_equal, tmp_assign_source_38 );
    tmp_defaults_9 = const_tuple_int_pos_7_str_empty_true_tuple;
    tmp_assign_source_39 = MAKE_FUNCTION_function_15_assert_almost_equal_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_9 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_almost_equal, tmp_assign_source_39 );
    tmp_defaults_10 = const_tuple_int_pos_7_str_empty_true_tuple;
    tmp_assign_source_40 = MAKE_FUNCTION_function_16_assert_approx_equal_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_10 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_approx_equal, tmp_assign_source_40 );
    tmp_defaults_11 = const_tuple_str_empty_true_str_empty_int_pos_6_tuple;
    tmp_assign_source_41 = MAKE_FUNCTION_function_17_assert_array_compare_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_11 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_compare, tmp_assign_source_41 );
    tmp_defaults_12 = const_tuple_str_empty_true_tuple;
    tmp_assign_source_42 = MAKE_FUNCTION_function_18_assert_array_equal_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_12 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_equal, tmp_assign_source_42 );
    tmp_defaults_13 = const_tuple_int_pos_6_str_empty_true_tuple;
    tmp_assign_source_43 = MAKE_FUNCTION_function_19_assert_array_almost_equal_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_13 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_almost_equal, tmp_assign_source_43 );
    tmp_defaults_14 = const_tuple_str_empty_true_tuple;
    tmp_assign_source_44 = MAKE_FUNCTION_function_20_assert_array_less_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_14 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_less, tmp_assign_source_44 );
    tmp_assign_source_45 = MAKE_FUNCTION_function_21_runstring_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_runstring, tmp_assign_source_45 );
    tmp_assign_source_46 = MAKE_FUNCTION_function_22_assert_string_equal_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_string_equal, tmp_assign_source_46 );
    tmp_defaults_15 = const_tuple_none_true_tuple;
    tmp_assign_source_47 = MAKE_FUNCTION_function_23_rundocs_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_15 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_rundocs, tmp_assign_source_47 );
    tmp_assign_source_48 = MAKE_FUNCTION_function_24_raises_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_raises, tmp_assign_source_48 );
    tmp_assign_source_49 = MAKE_FUNCTION_function_25_assert_raises_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises, tmp_assign_source_49 );
    tmp_assign_source_50 = Py_None;
    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex_impl, tmp_assign_source_50 );
    tmp_defaults_16 = const_tuple_none_tuple;
    tmp_assign_source_51 = MAKE_FUNCTION_function_26_assert_raises_regex_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_16 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_raises_regex, tmp_assign_source_51 );
    tmp_defaults_17 = const_tuple_none_tuple;
    tmp_assign_source_52 = MAKE_FUNCTION_function_27_decorate_methods_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_17 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_decorate_methods, tmp_assign_source_52 );
    tmp_defaults_18 = const_tuple_int_pos_1_none_tuple;
    tmp_assign_source_53 = MAKE_FUNCTION_function_28_measure_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_18 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_measure, tmp_assign_source_53 );
    tmp_assign_source_54 = MAKE_FUNCTION_function_29__assert_valid_refcount_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain__assert_valid_refcount, tmp_assign_source_54 );
    tmp_defaults_19 = const_tuple_float_1e_minus_07_int_0_false_str_empty_true_tuple;
    tmp_assign_source_55 = MAKE_FUNCTION_function_30_assert_allclose_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_19 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_allclose, tmp_assign_source_55 );
    tmp_defaults_20 = const_tuple_int_pos_1_tuple;
    tmp_assign_source_56 = MAKE_FUNCTION_function_31_assert_array_almost_equal_nulp_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_20 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_almost_equal_nulp, tmp_assign_source_56 );
    tmp_defaults_21 = const_tuple_int_pos_1_none_tuple;
    tmp_assign_source_57 = MAKE_FUNCTION_function_32_assert_array_max_ulp_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_21 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_array_max_ulp, tmp_assign_source_57 );
    tmp_defaults_22 = const_tuple_none_tuple;
    tmp_assign_source_58 = MAKE_FUNCTION_function_33_nulp_diff_of_numpy$testing$utils( INCREASE_REFCOUNT( tmp_defaults_22 ) );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_nulp_diff, tmp_assign_source_58 );
    tmp_assign_source_59 = MAKE_FUNCTION_function_34__integer_repr_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain__integer_repr, tmp_assign_source_59 );
    tmp_assign_source_60 = MAKE_FUNCTION_function_35_integer_repr_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_integer_repr, tmp_assign_source_60 );
    tmp_assign_source_61 = PyTuple_New( 1 );
    tmp_tuple_element_4 = LOOKUP_BUILTIN( const_str_plain_object );
    assert( tmp_tuple_element_4 != NULL );
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_assign_source_61, 0, tmp_tuple_element_4 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_61;

    tmp_assign_source_62 = impl_class_1_WarningMessage_of_numpy$testing$utils( NULL );
    assert( tmp_assign_source_62 != NULL );
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_62;

    // Tried code:
    tmp_compare_left_5 = const_str_plain___metaclass__;
    tmp_compare_right_5 = tmp_class_creation_1__class_dict;

    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_5, tmp_compare_left_5 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_63 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_63 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1533;
        goto try_except_handler_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_bases_name_1 = tmp_class_creation_1__bases;

    tmp_assign_source_63 = SELECT_METACLASS( tmp_bases_name_1, GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_63;

    tmp_called_name_3 = tmp_class_creation_1__metaclass;

    tmp_args_element_name_1 = const_str_plain_WarningMessage;
    tmp_args_element_name_2 = tmp_class_creation_1__bases;

    tmp_args_element_name_3 = tmp_class_creation_1__class_dict;

    frame_module->f_lineno = 1533;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_64 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_64 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1533;
        goto try_except_handler_1;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_64;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_65 = tmp_class_creation_1__class;

    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_WarningMessage, tmp_assign_source_65 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_assign_source_66 = PyTuple_New( 1 );
    tmp_tuple_element_5 = LOOKUP_BUILTIN( const_str_plain_object );
    assert( tmp_tuple_element_5 != NULL );
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_assign_source_66, 0, tmp_tuple_element_5 );
    assert( tmp_class_creation_2__bases == NULL );
    tmp_class_creation_2__bases = tmp_assign_source_66;

    tmp_assign_source_67 = impl_class_2_WarningManager_of_numpy$testing$utils( NULL );
    assert( tmp_assign_source_67 != NULL );
    assert( tmp_class_creation_2__class_dict == NULL );
    tmp_class_creation_2__class_dict = tmp_assign_source_67;

    // Tried code:
    tmp_compare_left_6 = const_str_plain___metaclass__;
    tmp_compare_right_6 = tmp_class_creation_2__class_dict;

    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_6, tmp_compare_left_6 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_dict_name_2 = tmp_class_creation_2__class_dict;

    tmp_key_name_2 = const_str_plain___metaclass__;
    tmp_assign_source_68 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_assign_source_68 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1565;
        goto try_except_handler_2;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_bases_name_2 = tmp_class_creation_2__bases;

    tmp_assign_source_68 = SELECT_METACLASS( tmp_bases_name_2, GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_2:;
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_68;

    tmp_called_name_4 = tmp_class_creation_2__metaclass;

    tmp_args_element_name_4 = const_str_plain_WarningManager;
    tmp_args_element_name_5 = tmp_class_creation_2__bases;

    tmp_args_element_name_6 = tmp_class_creation_2__class_dict;

    frame_module->f_lineno = 1565;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_69 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_69 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1565;
        goto try_except_handler_2;
    }
    assert( tmp_class_creation_2__class == NULL );
    tmp_class_creation_2__class = tmp_assign_source_69;

    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    tmp_assign_source_70 = tmp_class_creation_2__class;

    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_WarningManager, tmp_assign_source_70 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__bases );
    Py_DECREF( tmp_class_creation_2__bases );
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    tmp_assign_source_71 = MAKE_FUNCTION_function_36_assert_warns_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_warns, tmp_assign_source_71 );
    tmp_assign_source_72 = MAKE_FUNCTION_function_37_assert_no_warnings_of_numpy$testing$utils(  );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_assert_no_warnings, tmp_assign_source_72 );
    tmp_defaults_23 = PyTuple_New( 3 );
    tmp_tuple_element_6 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_float32 );

    if (unlikely( tmp_tuple_element_6 == NULL ))
    {
        tmp_tuple_element_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_float32 );
    }

    if ( tmp_tuple_element_6 == NULL )
    {
        Py_DECREF( tmp_defaults_23 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "float32" );
        exception_tb = NULL;

        exception_lineno = 1689;
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_defaults_23, 0, tmp_tuple_element_6 );
    tmp_tuple_element_6 = const_str_plain_binary;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_defaults_23, 1, tmp_tuple_element_6 );
    tmp_tuple_element_6 = const_int_pos_24;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_defaults_23, 2, tmp_tuple_element_6 );
    tmp_assign_source_73 = MAKE_FUNCTION_function_38__gen_alignment_data_of_numpy$testing$utils( tmp_defaults_23 );
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain__gen_alignment_data, tmp_assign_source_73 );
    tmp_assign_source_74 = PyTuple_New( 1 );
    tmp_tuple_element_7 = PyExc_Exception;
    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_assign_source_74, 0, tmp_tuple_element_7 );
    assert( tmp_class_creation_3__bases == NULL );
    tmp_class_creation_3__bases = tmp_assign_source_74;

    tmp_assign_source_75 = impl_class_3_IgnoreException_of_numpy$testing$utils( NULL );
    assert( tmp_assign_source_75 != NULL );
    assert( tmp_class_creation_3__class_dict == NULL );
    tmp_class_creation_3__class_dict = tmp_assign_source_75;

    // Tried code:
    tmp_compare_left_7 = const_str_plain___metaclass__;
    tmp_compare_right_7 = tmp_class_creation_3__class_dict;

    tmp_cmp_In_3 = PySequence_Contains( tmp_compare_right_7, tmp_compare_left_7 );
    assert( !(tmp_cmp_In_3 == -1) );
    if ( tmp_cmp_In_3 == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_dict_name_3 = tmp_class_creation_3__class_dict;

    tmp_key_name_3 = const_str_plain___metaclass__;
    tmp_assign_source_76 = DICT_GET_ITEM( tmp_dict_name_3, tmp_key_name_3 );
    if ( tmp_assign_source_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1755;
        goto try_except_handler_3;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_bases_name_3 = tmp_class_creation_3__bases;

    tmp_assign_source_76 = SELECT_METACLASS( tmp_bases_name_3, GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_3:;
    assert( tmp_class_creation_3__metaclass == NULL );
    tmp_class_creation_3__metaclass = tmp_assign_source_76;

    tmp_called_name_5 = tmp_class_creation_3__metaclass;

    tmp_args_element_name_7 = const_str_plain_IgnoreException;
    tmp_args_element_name_8 = tmp_class_creation_3__bases;

    tmp_args_element_name_9 = tmp_class_creation_3__class_dict;

    frame_module->f_lineno = 1755;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_77 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_77 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1755;
        goto try_except_handler_3;
    }
    assert( tmp_class_creation_3__class == NULL );
    tmp_class_creation_3__class = tmp_assign_source_77;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    tmp_assign_source_78 = tmp_class_creation_3__class;

    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_IgnoreException, tmp_assign_source_78 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class );
    Py_DECREF( tmp_class_creation_3__class );
    tmp_class_creation_3__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__bases );
    Py_DECREF( tmp_class_creation_3__bases );
    tmp_class_creation_3__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__class_dict );
    Py_DECREF( tmp_class_creation_3__class_dict );
    tmp_class_creation_3__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_3__metaclass );
    Py_DECREF( tmp_class_creation_3__metaclass );
    tmp_class_creation_3__metaclass = NULL;

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_contextlib );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_contextlib );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "contextlib" );
        exception_tb = NULL;

        exception_lineno = 1759;
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_contextmanager );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1759;
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = MAKE_FUNCTION_function_39_tempdir_of_numpy$testing$utils(  );
    frame_module->f_lineno = 1759;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_assign_source_79 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_10 );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1759;
        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_tempdir, tmp_assign_source_79 );
    // Tried code:
    tmp_assign_source_80 = PyTuple_New( 1 );
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_warnings );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_assign_source_80 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "warnings" );
        exception_tb = NULL;

        exception_lineno = 1772;
        goto try_except_handler_4;
    }

    tmp_tuple_element_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_catch_warnings );
    if ( tmp_tuple_element_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_80 );

        exception_lineno = 1772;
        goto try_except_handler_4;
    }
    PyTuple_SET_ITEM( tmp_assign_source_80, 0, tmp_tuple_element_8 );
    assert( tmp_class_creation_4__bases == NULL );
    tmp_class_creation_4__bases = tmp_assign_source_80;

    tmp_assign_source_81 = impl_class_4_clear_and_catch_warnings_of_numpy$testing$utils( NULL );
    assert( tmp_assign_source_81 != NULL );
    assert( tmp_class_creation_4__class_dict == NULL );
    tmp_class_creation_4__class_dict = tmp_assign_source_81;

    tmp_compare_left_8 = const_str_plain___metaclass__;
    tmp_compare_right_8 = tmp_class_creation_4__class_dict;

    tmp_cmp_In_4 = PySequence_Contains( tmp_compare_right_8, tmp_compare_left_8 );
    assert( !(tmp_cmp_In_4 == -1) );
    if ( tmp_cmp_In_4 == 1 )
    {
        goto condexpr_true_4;
    }
    else
    {
        goto condexpr_false_4;
    }
    condexpr_true_4:;
    tmp_dict_name_4 = tmp_class_creation_4__class_dict;

    tmp_key_name_4 = const_str_plain___metaclass__;
    tmp_assign_source_82 = DICT_GET_ITEM( tmp_dict_name_4, tmp_key_name_4 );
    if ( tmp_assign_source_82 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1772;
        goto try_except_handler_4;
    }
    goto condexpr_end_4;
    condexpr_false_4:;
    tmp_bases_name_4 = tmp_class_creation_4__bases;

    tmp_assign_source_82 = SELECT_METACLASS( tmp_bases_name_4, GET_STRING_DICT_VALUE( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_4:;
    assert( tmp_class_creation_4__metaclass == NULL );
    tmp_class_creation_4__metaclass = tmp_assign_source_82;

    tmp_called_name_7 = tmp_class_creation_4__metaclass;

    tmp_args_element_name_11 = const_str_plain_clear_and_catch_warnings;
    tmp_args_element_name_12 = tmp_class_creation_4__bases;

    tmp_args_element_name_13 = tmp_class_creation_4__class_dict;

    frame_module->f_lineno = 1772;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_assign_source_83 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_7, call_args );
    }

    if ( tmp_assign_source_83 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1772;
        goto try_except_handler_4;
    }
    assert( tmp_class_creation_4__class == NULL );
    tmp_class_creation_4__class = tmp_assign_source_83;

    goto try_end_4;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif
    popFrameStack();

    assertFrameObject( frame_module );
    Py_DECREF( frame_module );

    goto frame_no_exception_1;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_module, exception_lineno );
    }
    else if ( exception_tb->tb_frame != frame_module )
    {
        PyTracebackObject *traceback_new = MAKE_TRACEBACK( frame_module, exception_lineno );
        traceback_new->tb_next = exception_tb;
        exception_tb = traceback_new;
    }

    // Put the previous frame back on top.
    popFrameStack();

#if PYTHON_VERSION >= 340
    frame_module->f_executing -= 1;
#endif
    Py_DECREF( frame_module );

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_1:;
    tmp_assign_source_84 = tmp_class_creation_4__class;

    UPDATE_STRING_DICT0( moduledict_numpy$testing$utils, (Nuitka_StringObject *)const_str_plain_clear_and_catch_warnings, tmp_assign_source_84 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class );
    Py_DECREF( tmp_class_creation_4__class );
    tmp_class_creation_4__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__bases );
    Py_DECREF( tmp_class_creation_4__bases );
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__class_dict );
    Py_DECREF( tmp_class_creation_4__class_dict );
    tmp_class_creation_4__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_4__metaclass );
    Py_DECREF( tmp_class_creation_4__metaclass );
    tmp_class_creation_4__metaclass = NULL;


    return MOD_RETURN_VALUE( module_numpy$testing$utils );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
